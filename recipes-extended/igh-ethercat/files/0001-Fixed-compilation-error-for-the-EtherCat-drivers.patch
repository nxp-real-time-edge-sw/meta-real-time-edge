From 599a359834a190998ae293cd3106bb1939fbbb81 Mon Sep 17 00:00:00 2001
From: XianyuWei <xianyu.wei@nxp.com>
Date: Tue, 24 Jul 2018 14:14:03 +0800
Subject: [PATCH 1/7] Fixed compilation error for the EtherCat drivers.

There were some errors in compiling the module
because EtherCat 1.5.2 did not support the Linux kernel 4.x well.
The 'alloc_netdev' and 'sock_create_kern' interfaces
have been modified in the kernel,
so this patch is added to solve the compilation error.

Signed-off-by: XianyuWei <xianyu.wei@nxp.com>
Signed-off-by: Jerry Huang <jerry.huang@nxp.com>
Signed-off-by: weixy <xianyu.wei@nxp.com>
Signed-off-by: Wenbin Song <wenbin.song@nxp.com>
Upstream-Status: Pending
---
 configure.ac         |   2 +-
 devices/generic.c    |   7 +-
 examples/mini/mini.c |   5 +-
 examples/user/main.c | 390 ++++++++++++++++---------------------------
 master/cdev.c        |  10 +-
 master/ethernet.c    |   4 +-
 master/master.c      |   9 +-
 7 files changed, 163 insertions(+), 264 deletions(-)

diff --git a/configure.ac b/configure.ac
index b2011e9..ab115c8 100644
--- a/configure.ac
+++ b/configure.ac
@@ -41,7 +41,7 @@ AC_PREREQ(2.59)
 #
 AC_INIT([ethercat],[1.5.2],[fp@igh-essen.com])
 AC_CONFIG_AUX_DIR([autoconf])
-AM_INIT_AUTOMAKE([-Wall -Werror dist-bzip2])
+AM_INIT_AUTOMAKE([-Wall -Werror dist-bzip2 subdir-objects])
 AC_PREFIX_DEFAULT([/opt/etherlab])
 AC_CONFIG_HEADERS([config.h])
 AC_CONFIG_SRCDIR([config.h.in])
diff --git a/devices/generic.c b/devices/generic.c
index 9c03878..4be3f44 100644
--- a/devices/generic.c
+++ b/devices/generic.c
@@ -149,7 +149,8 @@ int ec_gen_device_init(
     dev->socket = NULL;
     dev->rx_buf = NULL;
 
-    dev->netdev = alloc_netdev(sizeof(ec_gen_device_t *), &null, ether_setup);
+    dev->netdev = alloc_netdev(sizeof(ec_gen_device_t *),
+                &null, NET_NAME_UNKNOWN, ether_setup);
     if (!dev->netdev) {
         return -ENOMEM;
     }
@@ -207,8 +208,8 @@ int ec_gen_device_create_socket(
         return -ENOMEM;
     }
 
-    ret = sock_create_kern(PF_PACKET, SOCK_RAW, htons(ETH_P_ETHERCAT),
-            &dev->socket);
+	ret = sock_create_kern(&init_net, PF_PACKET, SOCK_RAW,
+			htons(ETH_P_ETHERCAT), &dev->socket);
     if (ret) {
         printk(KERN_ERR PFX "Failed to create socket (ret = %i).\n", ret);
         return ret;
diff --git a/examples/mini/mini.c b/examples/mini/mini.c
index 2f7bb53..a66feae 100644
--- a/examples/mini/mini.c
+++ b/examples/mini/mini.c
@@ -307,7 +307,7 @@ void read_voe(void)
 
 /*****************************************************************************/
 
-void cyclic_task(unsigned long data)
+void cyclic_task(struct timer_list *t)
 {
     // receive process data
     down(&master_sem);
@@ -492,8 +492,7 @@ int __init init_mini_module(void)
 #endif
 
     printk(KERN_INFO PFX "Starting cyclic sample thread.\n");
-    init_timer(&timer);
-    timer.function = cyclic_task;
+    timer_setup(&timer, cyclic_task, 0);
     timer.expires = jiffies + 10;
     add_timer(&timer);
 
diff --git a/examples/user/main.c b/examples/user/main.c
index 790c38d..fa5fc65 100644
--- a/examples/user/main.c
+++ b/examples/user/main.c
@@ -33,6 +33,7 @@
 #include <string.h>
 #include <sys/resource.h>
 #include <sys/time.h>
+#include <time.h>
 #include <sys/types.h>
 #include <unistd.h>
 
@@ -43,12 +44,21 @@
 /****************************************************************************/
 
 // Application parameters
-#define FREQUENCY 100
+#define FREQUENCY 1000
+#define CLOCK_TO_USE CLOCK_REALTIME
+/*#define MEASURE_TIMING*/
 #define PRIORITY 1
 
+#define NSEC_PER_SEC (1000000000L)
+#define PERIOD_NS (NSEC_PER_SEC / FREQUENCY)
+#define DIFF_NS(A, B) (((B).tv_sec - (A).tv_sec) * NSEC_PER_SEC + \
+	(B).tv_nsec - (A).tv_nsec)
+
+#define TIMESPEC2NS(T) ((uint64_t) (T).tv_sec * NSEC_PER_SEC + (T).tv_nsec)
+
 // Optional features
 #define CONFIGURE_PDOS  1
-#define SDO_ACCESS      0
+#define N 10
 
 /****************************************************************************/
 
@@ -59,118 +69,97 @@ static ec_master_state_t master_state = {};
 static ec_domain_t *domain1 = NULL;
 static ec_domain_state_t domain1_state = {};
 
-static ec_slave_config_t *sc_ana_in = NULL;
+static ec_slave_config_t *sc;
 static ec_slave_config_state_t sc_ana_in_state = {};
 
 // Timer
 static unsigned int sig_alarms = 0;
 static unsigned int user_alarms = 0;
-
 /****************************************************************************/
 
 // process data
 static uint8_t *domain1_pd = NULL;
-
 #define BusCouplerPos  0, 0
-#define DigOutSlavePos 0, 2
-#define AnaInSlavePos  0, 3
-#define AnaOutSlavePos 0, 4
+#define DigOutSlavePos 0, 1
 
 #define Beckhoff_EK1100 0x00000002, 0x044c2c52
-#define Beckhoff_EL2004 0x00000002, 0x07d43052
-#define Beckhoff_EL2032 0x00000002, 0x07f03052
-#define Beckhoff_EL3152 0x00000002, 0x0c503052
-#define Beckhoff_EL3102 0x00000002, 0x0c1e3052
-#define Beckhoff_EL4102 0x00000002, 0x10063052
+#define Beckhoff_EL2008 0x00000002, 0x07d83052
 
 // offsets for PDO entries
-static unsigned int off_ana_in_status;
-static unsigned int off_ana_in_value;
-static unsigned int off_ana_out;
-static unsigned int off_dig_out;
+static unsigned int o_dig_out[8], bo_dig_out[8];
 
 const static ec_pdo_entry_reg_t domain1_regs[] = {
-    {AnaInSlavePos,  Beckhoff_EL3102, 0x3101, 1, &off_ana_in_status},
-    {AnaInSlavePos,  Beckhoff_EL3102, 0x3101, 2, &off_ana_in_value},
-    {AnaOutSlavePos, Beckhoff_EL4102, 0x3001, 1, &off_ana_out},
-    {DigOutSlavePos, Beckhoff_EL2032, 0x3001, 1, &off_dig_out},
-    {}
+	{DigOutSlavePos, Beckhoff_EL2008,
+		0x7000, 1, &o_dig_out[0], &bo_dig_out[0]},
+	{DigOutSlavePos, Beckhoff_EL2008,
+		0x7010, 1, &o_dig_out[1], &bo_dig_out[1]},
+	{DigOutSlavePos, Beckhoff_EL2008,
+		0x7020, 1, &o_dig_out[2], &bo_dig_out[2]},
+	{DigOutSlavePos, Beckhoff_EL2008,
+		0x7030, 1, &o_dig_out[3], &bo_dig_out[3]},
+	{DigOutSlavePos, Beckhoff_EL2008,
+		0x7040, 1, &o_dig_out[4], &bo_dig_out[4]},
+	{DigOutSlavePos, Beckhoff_EL2008,
+		0x7050, 1, &o_dig_out[5], &bo_dig_out[5]},
+	{DigOutSlavePos, Beckhoff_EL2008,
+		0x7060, 1, &o_dig_out[6], &bo_dig_out[6]},
+	{DigOutSlavePos, Beckhoff_EL2008,
+		0x7070, 1, &o_dig_out[7], &bo_dig_out[7]},
+	{}
 };
 
 static unsigned int counter = 0;
-static unsigned int blink = 0;
+static unsigned int blink_out_0 = 0x01;
+const struct timespec cycletime = {0, PERIOD_NS};
 
 /*****************************************************************************/
 
-#if CONFIGURE_PDOS
-
-// Analog in --------------------------
-
-static ec_pdo_entry_info_t el3102_pdo_entries[] = {
-    {0x3101, 1,  8}, // channel 1 status
-    {0x3101, 2, 16}, // channel 1 value
-    {0x3102, 1,  8}, // channel 2 status
-    {0x3102, 2, 16}, // channel 2 value
-    {0x6401, 1, 16}, // channel 1 value (alt.)
-    {0x6401, 2, 16}  // channel 2 value (alt.)
-};
-
-static ec_pdo_info_t el3102_pdos[] = {
-    {0x1A00, 2, el3102_pdo_entries},
-    {0x1A01, 2, el3102_pdo_entries + 2}
-};
+struct timespec timespec_add(struct timespec time1, struct timespec time2)
+{
+	struct timespec result;
 
-static ec_sync_info_t el3102_syncs[] = {
-    {2, EC_DIR_OUTPUT},
-    {3, EC_DIR_INPUT, 2, el3102_pdos},
-    {0xff}
-};
+	if ((time1.tv_nsec + time2.tv_nsec) >= NSEC_PER_SEC) {
+		result.tv_sec = time1.tv_sec + time2.tv_sec + 1;
+		result.tv_nsec = time1.tv_nsec + time2.tv_nsec - NSEC_PER_SEC;
+	} else {
+		result.tv_sec = time1.tv_sec + time2.tv_sec;
+		result.tv_nsec = time1.tv_nsec + time2.tv_nsec;
+	}
 
-// Analog out -------------------------
+	return result;
+}
 
-static ec_pdo_entry_info_t el4102_pdo_entries[] = {
-    {0x3001, 1, 16}, // channel 1 value
-    {0x3002, 1, 16}, // channel 2 value
-};
+/*****************************************************************************/
 
-static ec_pdo_info_t el4102_pdos[] = {
-    {0x1600, 1, el4102_pdo_entries},
-    {0x1601, 1, el4102_pdo_entries + 1}
-};
+#if CONFIGURE_PDOS
 
-static ec_sync_info_t el4102_syncs[] = {
-    {2, EC_DIR_OUTPUT, 2, el4102_pdos},
-    {3, EC_DIR_INPUT},
-    {0xff}
+static ec_pdo_entry_info_t el2008_channels[] = {
+	{0x7000, 1, 1}, // Value 1
+	{0x7010, 1, 1}, // Value 2
+	{0x7020, 1, 1}, // Value 3
+	{0x7030, 1, 1}, // Value 4
+	{0x7040, 1, 1}, // Value 4
+	{0x7050, 1, 1}, // Value 4
+	{0x7060, 1, 1}, // Value 4
+	{0x7070, 1, 1}  // Value 4
 };
 
-// Digital out ------------------------
-
-static ec_pdo_entry_info_t el2004_channels[] = {
-    {0x3001, 1, 1}, // Value 1
-    {0x3001, 2, 1}, // Value 2
-    {0x3001, 3, 1}, // Value 3
-    {0x3001, 4, 1}  // Value 4
+static ec_pdo_info_t el2008_pdos[] = {
+	{0x1600, 1, &el2008_channels[0]},
+	{0x1601, 1, &el2008_channels[1]},
+	{0x1602, 1, &el2008_channels[2]},
+	{0x1603, 1, &el2008_channels[3]},
+	{0x1604, 1, &el2008_channels[4]},
+	{0x1605, 1, &el2008_channels[5]},
+	{0x1606, 1, &el2008_channels[6]},
+	{0x1607, 1, &el2008_channels[7]}
 };
 
-static ec_pdo_info_t el2004_pdos[] = {
-    {0x1600, 1, &el2004_channels[0]},
-    {0x1601, 1, &el2004_channels[1]},
-    {0x1602, 1, &el2004_channels[2]},
-    {0x1603, 1, &el2004_channels[3]}
+static ec_sync_info_t el2008_syncs[] = {
+	{0, EC_DIR_OUTPUT, 8, el2008_pdos},
+	{0xff}
 };
 
-static ec_sync_info_t el2004_syncs[] = {
-    {0, EC_DIR_OUTPUT, 4, el2004_pdos},
-    {1, EC_DIR_INPUT},
-    {0xff}
-};
-#endif
-
-/*****************************************************************************/
-
-#if SDO_ACCESS
-static ec_sdo_request_t *sdo;
 #endif
 
 /*****************************************************************************/
@@ -193,7 +182,7 @@ void check_domain1_state(void)
 
 void check_master_state(void)
 {
-    ec_master_state_t ms;
+	ec_master_state_t ms;
 
     ecrt_master_state(master, &ms);
 
@@ -211,12 +200,13 @@ void check_master_state(void)
 
 void check_slave_config_states(void)
 {
-    ec_slave_config_state_t s;
+	ec_slave_config_state_t s;
 
-    ecrt_slave_config_state(sc_ana_in, &s);
+	ecrt_slave_config_state(sc, &s);
 
     if (s.al_state != sc_ana_in_state.al_state)
         printf("AnaIn: State 0x%02X.\n", s.al_state);
+
     if (s.online != sc_ana_in_state.online)
         printf("AnaIn: %s.\n", s.online ? "online" : "offline");
     if (s.operational != sc_ana_in_state.operational)
@@ -227,77 +217,59 @@ void check_slave_config_states(void)
 }
 
 /*****************************************************************************/
-
-#if SDO_ACCESS
-void read_sdo(void)
+void cyclic_task_nanosleep(void)
 {
-    switch (ecrt_sdo_request_state(sdo)) {
-        case EC_REQUEST_UNUSED: // request was not used yet
-            ecrt_sdo_request_read(sdo); // trigger first read
-            break;
-        case EC_REQUEST_BUSY:
-            fprintf(stderr, "Still busy...\n");
-            break;
-        case EC_REQUEST_SUCCESS:
-            fprintf(stderr, "SDO value: 0x%04X\n",
-                    EC_READ_U16(ecrt_sdo_request_data(sdo)));
-            ecrt_sdo_request_read(sdo); // trigger next read
-            break;
-        case EC_REQUEST_ERROR:
-            fprintf(stderr, "Failed to read SDO!\n");
-            ecrt_sdo_request_read(sdo); // retry reading
-            break;
-    }
-}
+	struct timespec wakeupTime;
+#ifdef MEASURE_TIMING
+	int i = 0;
+	struct timeval tv[N];
 #endif
 
-/****************************************************************************/
-
-void cyclic_task()
-{
-    // receive process data
-    ecrt_master_receive(master);
-    ecrt_domain_process(domain1);
-
-    // check process data state (optional)
-    check_domain1_state();
-
-    if (counter) {
-        counter--;
-    } else { // do this at 1 Hz
-        counter = FREQUENCY;
-
-        // calculate new process data
-        blink = !blink;
-
-        // check for master state (optional)
-        check_master_state();
-
-        // check for islave configuration state(s) (optional)
-        check_slave_config_states();
-
-#if SDO_ACCESS
-        // read process data SDO
-        read_sdo();
+    // get current time
+	clock_gettime(CLOCK_TO_USE, &wakeupTime);
+#ifdef MEASURE_TIMING
+	while (i < N) {
+#else
+	while (1) {
 #endif
-
-    }
-
-#if 0
-    // read process data
-    printf("AnaIn: state %u value %u\n",
-            EC_READ_U8(domain1_pd + off_ana_in_status),
-            EC_READ_U16(domain1_pd + off_ana_in_value));
+		wakeupTime = timespec_add(wakeupTime, cycletime);
+		clock_nanosleep(CLOCK_TO_USE, TIMER_ABSTIME, &wakeupTime, NULL);
+
+		// receive process data
+		ecrt_master_receive(master);
+		ecrt_domain_process(domain1);
+
+		// check process data state (optional)
+		check_domain1_state();
+		EC_WRITE_BIT(domain1_pd + o_dig_out[0], bo_dig_out[0],
+				blink_out_0 ? 0x01 : 0x00);
+
+		if (counter) {
+			counter--;
+		} else { // 1hz
+			counter = FREQUENCY;
+			blink_out_0 = !blink_out_0;
+		}
+
+		// check for master state (optional)
+		check_master_state();
+		// check for islave configuration state(s) (optional)
+		check_slave_config_states();
+
+		// send process data
+		ecrt_domain_queue(domain1);
+
+#ifdef MEASURE_TIMING
+		gettimeofday(&tv[i++], NULL);
 #endif
+		ecrt_master_send(master);
+	}
 
-#if 1
-    // write process data
-    EC_WRITE_U8(domain1_pd + off_dig_out, blink ? 0x06 : 0x09);
+#ifdef MEASURE_TIMING
+	sleep(3);
+	for (i = 0; i < N; i++)
+		printf("%d %u.%06u\n", i, tv[i].tv_sec, tv[i].tv_usec);
 #endif
-
-    // send process data
-    ecrt_domain_queue(domain1);
-    ecrt_master_send(master);
 }
 
 /****************************************************************************/
@@ -314,123 +286,49 @@ void signal_handler(int signum) {
 
 int main(int argc, char **argv)
 {
-    ec_slave_config_t *sc;
     struct sigaction sa;
     struct itimerval tv;
 
+    // Requests an EtherCAT master for realtime operation.
     master = ecrt_request_master(0);
-    if (!master)
-        return -1;
+	if (!master)
+		return -1;
 
+	// Creates a new process data domain
     domain1 = ecrt_master_create_domain(master);
-    if (!domain1)
-        return -1;
-
-    if (!(sc_ana_in = ecrt_master_slave_config(
-                    master, AnaInSlavePos, Beckhoff_EL3102))) {
-        fprintf(stderr, "Failed to get slave configuration.\n");
-        return -1;
-    }
-
-#if SDO_ACCESS
-    fprintf(stderr, "Creating SDO requests...\n");
-    if (!(sdo = ecrt_slave_config_create_sdo_request(sc_ana_in, 0x3102, 2, 2))) {
-        fprintf(stderr, "Failed to create SDO request.\n");
-        return -1;
-    }
-    ecrt_sdo_request_timeout(sdo, 500); // ms
-#endif
+	if (!domain1)
+		return -1;
 
 #if CONFIGURE_PDOS
-    printf("Configuring PDOs...\n");
-    if (ecrt_slave_config_pdos(sc_ana_in, EC_END, el3102_syncs)) {
-        fprintf(stderr, "Failed to configure PDOs.\n");
-        return -1;
-    }
-
-    if (!(sc = ecrt_master_slave_config(
-                    master, AnaOutSlavePos, Beckhoff_EL4102))) {
+    // Obtains a slave configuration
+	sc = ecrt_master_slave_config(master, DigOutSlavePos, Beckhoff_EL2008);
+	if (!sc) {
         fprintf(stderr, "Failed to get slave configuration.\n");
         return -1;
-    }
-
-    if (ecrt_slave_config_pdos(sc, EC_END, el4102_syncs)) {
-        fprintf(stderr, "Failed to configure PDOs.\n");
-        return -1;
-    }
+	}
 
-    if (!(sc = ecrt_master_slave_config(
-                    master, DigOutSlavePos, Beckhoff_EL2032))) {
-        fprintf(stderr, "Failed to get slave configuration.\n");
-        return -1;
+    // Configuring PDOs
+	printf("Configuring PDOs...\n");
+	if (ecrt_slave_config_pdos(sc, EC_END, el2008_syncs)) {
+		fprintf(stderr, "Failed to configure PDOs.\n");
+		return -1;
     }
 
-    if (ecrt_slave_config_pdos(sc, EC_END, el2004_syncs)) {
-        fprintf(stderr, "Failed to configure PDOs.\n");
-        return -1;
+	if (ecrt_domain_reg_pdo_entry_list(domain1, domain1_regs)) {
+		fprintf(stderr, "OUT PDO entry registration failed!\n");
+		return -1;
     }
 #endif
 
-    // Create configuration for bus coupler
-    sc = ecrt_master_slave_config(master, BusCouplerPos, Beckhoff_EK1100);
-    if (!sc)
-        return -1;
-
-    if (ecrt_domain_reg_pdo_entry_list(domain1, domain1_regs)) {
-        fprintf(stderr, "PDO entry registration failed!\n");
-        return -1;
-    }
-
     printf("Activating master...\n");
-    if (ecrt_master_activate(master))
-        return -1;
+	if (ecrt_master_activate(master))
+		return -1;
 
-    if (!(domain1_pd = ecrt_domain_data(domain1))) {
-        return -1;
-    }
-
-#if PRIORITY
-    pid_t pid = getpid();
-    if (setpriority(PRIO_PROCESS, pid, -19))
-        fprintf(stderr, "Warning: Failed to set priority: %s\n",
-                strerror(errno));
-#endif
-
-    sa.sa_handler = signal_handler;
-    sigemptyset(&sa.sa_mask);
-    sa.sa_flags = 0;
-    if (sigaction(SIGALRM, &sa, 0)) {
-        fprintf(stderr, "Failed to install signal handler!\n");
-        return -1;
-    }
-
-    printf("Starting timer...\n");
-    tv.it_interval.tv_sec = 0;
-    tv.it_interval.tv_usec = 1000000 / FREQUENCY;
-    tv.it_value.tv_sec = 0;
-    tv.it_value.tv_usec = 1000;
-    if (setitimer(ITIMER_REAL, &tv, NULL)) {
-        fprintf(stderr, "Failed to start timer: %s\n", strerror(errno));
-        return 1;
-    }
-
-    printf("Started.\n");
-    while (1) {
-        pause();
-
-#if 0
-        struct timeval t;
-        gettimeofday(&t, NULL);
-        printf("%u.%06u\n", t.tv_sec, t.tv_usec);
-#endif
-
-        while (sig_alarms != user_alarms) {
-            cyclic_task();
-            user_alarms++;
-        }
-    }
+	domain1_pd = ecrt_domain_data(domain1);
+	if (!domain1_pd)
+		return -1;
 
+	cyclic_task_nanosleep();
     return 0;
 }
 
-/****************************************************************************/
diff --git a/master/cdev.c b/master/cdev.c
index c920522..7ded08e 100644
--- a/master/cdev.c
+++ b/master/cdev.c
@@ -62,7 +62,7 @@ static int eccdev_mmap(struct file *, struct vm_area_struct *);
 #define PAGE_FAULT_VERSION KERNEL_VERSION(2, 6, 23)
 
 #if LINUX_VERSION_CODE >= PAGE_FAULT_VERSION
-static int eccdev_vma_fault(struct vm_area_struct *, struct vm_fault *);
+static unsigned int eccdev_vma_fault(struct vm_fault *);
 #else
 static struct page *eccdev_vma_nopage(
         struct vm_area_struct *, unsigned long, int *);
@@ -252,13 +252,12 @@ int eccdev_mmap(
  *
  * \return Zero on success, otherwise a negative error code.
  */
-static int eccdev_vma_fault(
-        struct vm_area_struct *vma, /**< Virtual memory area. */
+static unsigned int eccdev_vma_fault(
         struct vm_fault *vmf /**< Fault data. */
         )
 {
     unsigned long offset = vmf->pgoff << PAGE_SHIFT;
-    ec_cdev_priv_t *priv = (ec_cdev_priv_t *) vma->vm_private_data;
+	ec_cdev_priv_t *priv = (ec_cdev_priv_t *) vmf->vma->vm_private_data;
     struct page *page;
 
     if (offset >= priv->ctx.process_data_size) {
@@ -273,9 +272,6 @@ static int eccdev_vma_fault(
     get_page(page);
     vmf->page = page;
 
-    EC_MASTER_DBG(priv->cdev->master, 1, "Vma fault, virtual_address = %p,"
-            " offset = %lu, page = %p\n", vmf->virtual_address, offset, page);
-
     return 0;
 }
 
diff --git a/master/ethernet.c b/master/ethernet.c
index 4dda1fe..81a33e7 100644
--- a/master/ethernet.c
+++ b/master/ethernet.c
@@ -148,7 +148,9 @@ int ec_eoe_init(
 
     snprintf(eoe->datagram.name, EC_DATAGRAM_NAME_SIZE, name);
 
-    if (!(eoe->dev = alloc_netdev(sizeof(ec_eoe_t *), name, ether_setup))) {
+	eoe->dev = alloc_netdev(sizeof(ec_eoe_t *), name, NET_NAME_UNKNOWN,
+			ether_setup);
+	if (!eoe->dev) {
         EC_SLAVE_ERR(slave, "Unable to allocate net_device %s"
                 " for EoE handler!\n", name);
         ret = -ENODEV;
diff --git a/master/master.c b/master/master.c
index f59a141..7a67722 100644
--- a/master/master.c
+++ b/master/master.c
@@ -44,6 +44,7 @@
 #include <linux/device.h>
 #include <linux/version.h>
 #include <linux/hrtimer.h>
+#include <uapi/linux/sched/types.h>
 #include "globals.h"
 #include "slave.h"
 #include "slave_config.h"
@@ -1634,8 +1635,6 @@ static int ec_master_operation_thread(void *priv_data)
  */
 void ec_master_eoe_start(ec_master_t *master /**< EtherCAT master */)
 {
-    struct sched_param param = { .sched_priority = 0 };
-
     if (master->eoe_thread) {
         EC_MASTER_WARN(master, "EoE already running!\n");
         return;
@@ -1660,8 +1659,12 @@ void ec_master_eoe_start(ec_master_t *master /**< EtherCAT master */)
         master->eoe_thread = NULL;
         return;
     }
-
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 9, 0)
+    sched_set_normal(master->eoe_thread, 19);
+#else
+    struct sched_param param = { .sched_priority = 0 };
     sched_setscheduler(master->eoe_thread, SCHED_NORMAL, &param);
+#endif
     set_user_nice(master->eoe_thread, 0);
 }
 
-- 
2.25.1

