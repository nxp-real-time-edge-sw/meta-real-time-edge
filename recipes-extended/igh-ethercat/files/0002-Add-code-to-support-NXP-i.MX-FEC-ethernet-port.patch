From 4010d4372fa8e4416358616591f662c219eca0f6 Mon Sep 17 00:00:00 2001
From: Hongbo Wang <hongbo.wang@nxp.com>
Date: Thu, 23 Nov 2023 22:05:20 +0800
Subject: [PATCH 2/2] Add code to support NXP i.MX FEC ethernet port

the verified platform: i.MX8MP, i.MX8MM and i.MX93

Readme_For_User_Space_IGH_EtherCAT.txt is document for this feature

compilation steps:
./bootstrap
./configure --prefix=$PWD/ecat_build/ --enable-usecat=yes --enable-8139too=no --enable-tool=yes --enable-eoe=no --build=arm
make
make install

** Note-1:
if user's board has larger memory than 4G bytes,
using this patch, don't need limit memory in 4GB.

user should allocate enough hugepages firstly, make sure that there are
hugepages within 4G bytes, like following:
  echo 2048 > /sys/kernel/mm/hugepages/hugepages-2048kB/nr_hugepages

then allocate hugepage for user space IgH, after that user can free surplus
hugepage to Linux kernel, like this:
  echo 64 > /sys/kernel/mm/hugepages/hugepages-2048kB/nr_hugepages

** Note-2:
add simple example for user space motor control

Usage:
  ./ec_motor_example [encode_rate] [axle_num]

For example:
  1 motors:
    ./ec_motor_example or ./ec_motor_example 131072 1

  6 motors:
    ./ec_motor_example 131072 6

** Note-3:
add support for i.MXRT1180 EtherCAT slave

Usage for i.MXRT1180 motors:
    ./ec_motor_example or ./ec_motor_example 131072 1

Signed-off-by: Yuhang Wang <yuhang.wang@nxp.com>
Signed-off-by: Lyrix Liu <lyrix.liu@nxp.com>
Signed-off-by: Hongbo Wang <hongbo.wang@nxp.com>
---
 Readme_For_User_Space_IGH_EtherCAT.txt | 216 +++++++++
 compile.sh                             |  21 +
 configure.ac                           |  10 +-
 devices/nxp_userspace/usm_main.c       | 308 +++++++++++++
 devices/nxp_userspace/usm_main.h       |  41 ++
 emulation/linux/jiffies.h              |  15 +-
 emulation/linux/kthread.h              |  39 +-
 emulation/linux/skbuff.h               |   5 +-
 emulation/linux/wait.h                 |   2 +-
 examples/Makefile.am                   |   5 +
 examples/motor_control/Makefile.am     |  42 ++
 examples/motor_control/main.c          | 589 +++++++++++++++++++++++++
 globals.h                              |   5 +-
 include/ecrt.h                         |  15 +-
 lib/common.c                           |   1 +
 libecat.mri                            |   5 +
 master/Makefile.am                     |   7 +-
 master/cdev.c                          | 127 ++++--
 master/cdev.h                          |   9 +-
 master/datagram.h                      |   5 +-
 master/device.c                        |  38 +-
 master/device.h                        |  11 +-
 master/ethercat_master.c               |  38 +-
 master/globals.h                       |   4 +
 master/ioctl.c                         |  42 +-
 master/ioctl.h                         |   3 +-
 master/master.c                        | 147 +++++-
 master/master.h                        |  23 +-
 master/module.c                        |  54 ++-
 master/slave.h                         |  10 +
 master/slave_config.c                  |  24 +
 tool/CommandAlias.cpp                  |   8 +-
 tool/CommandData.cpp                   |   6 +-
 tool/CommandDomains.cpp                |   8 +-
 tool/CommandDownload.cpp               |  22 +-
 tool/CommandFoeRead.cpp                |   6 +-
 tool/CommandFoeWrite.cpp               |  10 +-
 tool/CommandRegRead.cpp                |   8 +-
 tool/CommandRegWrite.cpp               |  18 +-
 tool/CommandSiiRead.cpp                |   6 +-
 tool/CommandSiiWrite.cpp               |  12 +-
 tool/CommandSoeRead.cpp                |  10 +-
 tool/CommandSoeWrite.cpp               |  12 +-
 tool/CommandUpload.cpp                 |  10 +-
 tool/Makefile.am                       |   9 +-
 tool/MasterDevice.cpp                  | 147 +++++-
 tool/MasterDevice.h                    |  22 +
 47 files changed, 2042 insertions(+), 133 deletions(-)
 create mode 100644 Readme_For_User_Space_IGH_EtherCAT.txt
 create mode 100755 compile.sh
 create mode 100644 devices/nxp_userspace/usm_main.c
 create mode 100644 devices/nxp_userspace/usm_main.h
 create mode 100644 examples/motor_control/Makefile.am
 create mode 100644 examples/motor_control/main.c
 create mode 100644 libecat.mri

diff --git a/Readme_For_User_Space_IGH_EtherCAT.txt b/Readme_For_User_Space_IGH_EtherCAT.txt
new file mode 100644
index 00000000..7e465b39
--- /dev/null
+++ b/Readme_For_User_Space_IGH_EtherCAT.txt
@@ -0,0 +1,216 @@
+
+		Readme for user space IGH EtherCAT stack
+
+
+1. Why need user space IGH EtherCAT stack?
+
+  As we know, IGH EtherCAT stack has both code in kernel space and user space.
+In kernel space, it has integrated lots of drivers for different networking
+devices, in user space, it supplies one library(libetherat.so/.a) for user's
+application, user can set/get device's running parameters using API of this library,
+the API will write/read data via ioctl mechanism of Linux kernel.
+
+  Ioctl will invoke the routine implemented in master module(ec_master.ko),
+then master module will call the RX/TX function in different drivers. Ioctl is
+system call supplied by Linux, so the updates for running parameters will
+trigger system call of kernel, it will bring in more jitter of system.
+
+  On the other hand, there are mainly two importmant threads for using IGH EtherCAT
+stack, one is master operation thread running in kernel space, it's responsible
+for parsing the frames received from EtherCAT devices. another thread is RT
+thread implemented by user, it will trigger RX/TX functionality cyclically
+according to cycle time. Due to these two threads are running in different
+spaces, so it needs context switch between user space and kernel space, this will
+also increase system jitter and time latency.
+
+  In IGH EtherCAT stack, there are different drivers for devices, so it depends
+on the version of Linux kernel. When you want to compile IGH EtherCAT stack, you
+have to point out clearly the path of kernel, otherwise it will report error.
+
+2. How to resolve the above issues in user space IGH EtherCAT stack?
+
+    For user space IGH EtherCAT stack, it's wholely running in user space, so
+it doesn't need ioctl, user can invoke the functions of master module directly,
+this can avoid system call, it can decrease jitter of system obviously.
+
+    From the perspective of threads, in user space stack, master operation
+thread is also running in user space, so we can refactor OP thread to one
+callback function, this callback function will be called in user's cyclic RT
+thread, so there is only one main thread in whole system, it will avoid context
+switch. This can also improve the performance, such as jitter and latency etc..
+
+    Regarding dependence on Linux kernel, user space IGH EtherCAT stack have no
+code that ran in kernel space, so it's wholely independent of any kernel version.
+
+3. New API of user space IGH EtherCAT stack
+
+3.1 ecus_init
+
+/*
+ * initialize the context for user space EtherCAT stack
+ *
+ * master_count:	the number of ethernet ports as EtherCAT master device
+ * master_macs:		the MAC list of ethernet ports as EtherCAT master device
+ * backup_count:	the number of ethernet ports as EtherCAT backup device
+ * backup_macs:		the MAC list of ethernet ports as EtherCAT backup device
+ * debug_level:		the level of debug, 0 in default
+ * cycle_ns:		the cycle time of user's RT thread, unit: nanoseconds
+ * core_mask:		the mask of CPU affinity, 0x01:core0, 0x02:core1, 0x0F:core0-3
+ *
+ * NOTE: user space stack only supports NXP FEC ethernet port currently
+ *	 The verified platform have i.MX8MP, i.MX8MM and i.MX93.
+ *
+ *	 the MAC address is fixed to "04:13:07:02:00:13"
+ *	 For core_mask, we can isolate this core from Linux, like "isolcpus=1" for Uboot
+ **/
+int ecus_init(uint32_t master_count, const char *const *master_macs,
+              uint32_t backup_count, const char *const *backup_macs,
+              uint32_t debug_level, uint32_t cycle_ns, uint32_t core_mask);
+
+3.2 ecus_done
+
+/*
+ * clean up the context for user space EtherCAT stack
+ **/
+int ecus_done(void);
+
+3.3 ecus_slave_is_ready
+
+/*
+ * Check whether the slave is in ready status (PREOP)
+ *
+ * master_index:	the index of the master that slave is attached
+ * alias:		the alias of the related slave
+ * position:		the position of the related slave
+ **/
+int ecus_slave_is_ready(uint32_t master_index, uint16_t alias, uint16_t position);
+
+3.4 ecus_master_operation_loop
+
+/*
+ * master operation callback function that should be invoked in user's RT thread
+ *
+ * master:	the pointer of the corresponding master
+ * cycle:	denote whether this calling will calculate jiffies for master FSM
+ *
+ * Note: this function should be called twice in one loop of RT thread,
+ *	 the first one is called after RX, the second one is called after TX.
+ *	 only the first one should set cycle = 1
+ **/
+int ecus_master_operation_loop(ec_master_t *master, int cycle);
+
+3.5 ecus_bind_cpu_core
+
+/*
+ * Set the CPU affinity for user's RT thread
+ *
+ * core_mask:		the mask of CPU affinity, 0x01:core0, 0x02:core1, 0x0F:core0-3
+ **/
+int ecus_bind_cpu_core(uint32_t core_mask);
+
+4. How to use user space EtherCAT stack?
+
+User space IGH EtherCAT stack will be compiled out a library named "libethercat_master.a/.so",
+user's application should link this new library by "-lethercat_master",
+
+I will take the below code as example (cycle time: 1ms)
+
+static char *smaster_macs[1] = {
+	"04:13:07:02:00:13",
+};
+
+static void *user_cycle_thread(void *p)
+{
+	ec_master_t *ec_master;
+
+	/* ec_master = ... ; */
+
+	/* bind RT thread to CPU core 1 */
+	ecus_bind_cpu_core(0x02);
+
+	while (1) {
+		ecrt_master_receive(ec_master);
+
+		/* call operation function after RX */
+		ecus_master_operation_loop(ec_master, 1);
+
+		...
+
+		ecrt_master_send(ec_master);
+
+		/* call operation function after TX */
+		ecus_master_operation_loop(ec_master, 0);
+
+		usleep(1000);
+	}
+}
+
+int main()
+{
+	const char **masters = (const char **)smaster_macs;
+
+	/*
+	  initialize user space stack: one master, zero backup, cycle time:1ms,
+	  user's RT thread will run on core1
+	   */
+	ecus_init(1, masters, 0, NULL, 0, 1000000, 0x02);
+
+	/*  waiting for slave to be ready status */
+	for (...) {
+		ready = ecus_slave_is_ready(0, slave_alias, slave_position);
+		if (ready)
+			break;
+		sleep(1);
+	}
+
+	start user_cycle_thread as RT thread ...
+
+	waiting for user_cycle_thread to finish
+
+	/* exit user space EtherCAT */
+	ecus_done();
+
+	return 0;
+}
+
+NOTE:
+For user space IGH EtherCAT, should use *-dpdk.dtb for Linux kernel, for example:
+- imx8mm-evk-dpdk.dtb
+- imx8mp-evk-dpdk.dtb
+- imx93-11x11-evk-dpdk.dtb
+
+5. How to run user's EtherCAT application
+
+Before running application, we should set hugepage related configuration:
+
+# mkdir -p /dev/hugepages
+# mount -t hugetlbfs hugetlbfs /dev/hugepages
+# echo 448 > /sys/kernel/mm/hugepages/hugepages-2048kB/nr_hugepages
+
+Then we can start user's application:
+# ./user_app
+
+6. How to use EtherCAT tool to show EtherCAT device's information?
+
+Because EtherCAT tool(named ethercat_userspace) will invoke ioctl to scan and
+show EtherCAT devices, for conveniency of using EtherCAT tool, we have
+implemented one virtual ioctl interface to support this tool. one backend
+program(named ethercat_master) will supply the service for the tool.
+
+Firstly we should run the backend program:
+# mkdir -p /dev/hugepages
+# mount -t hugetlbfs hugetlbfs /dev/hugepages
+# echo 448 > /sys/kernel/mm/hugepages/hugepages-2048kB/nr_hugepages
+# ./ethercat_master &
+
+Then we can run EtherCAT tool:
+# ./ethercat_userspace slaves -v
+
+or
+
+# ./ethercat_userspace cstruct
+
+Note:
+1. If want to run user's application, should exit and close ethercat_master program.
+2. For i.MX platforms, should limit DDR memory in 4G bytes via 'mem' variable in U-Boot bootargs.
+	Example: 'mem=4096M'
diff --git a/compile.sh b/compile.sh
new file mode 100755
index 00000000..617abcb7
--- /dev/null
+++ b/compile.sh
@@ -0,0 +1,21 @@
+#!/bin/bash
+
+echo $PWD
+
+if [ "$1" == "rebuild" ]; then
+rm -fr $PWD/ecat_build
+mkdir $PWD/ecat_build
+rm ./configure
+rm ./config.status
+
+rm -fr autoconf/ autom4te.cache/ master/.libs/
+find . -name ".deps" | xargs rm -fr
+
+./bootstrap
+./configure --prefix=$PWD/ecat_build/ --enable-usecat=yes --enable-8139too=no --enable-tool=yes --enable-eoe=no --build=arm
+fi
+
+make
+make install
+
+ar -M < ./libecat.mri
diff --git a/configure.ac b/configure.ac
index 953af99d..3fcb5b60 100644
--- a/configure.ac
+++ b/configure.ac
@@ -80,7 +80,7 @@ AC_ARG_ENABLE([usecat],
 )
 
 if test "x${enable_usecat}" = "x1"; then
-    AC_DEFINE([EC_USERSPACE_MASTER], [1], [Userspace EtherCAT library enabled])
+    AC_DEFINE([EC_USERSPACE_MASTER_NEW], [1], [Userspace EtherCAT library enabled])
     AC_MSG_RESULT([yes])
 else
     AC_MSG_RESULT([no])
@@ -93,7 +93,12 @@ AC_SUBST(ENABLE_USERSPACE_MASTER,[$enable_usecat])
 # Linux sources
 #------------------------------------------------------------------------------
 
-if test "x${enable_usecat}" = "x0"; then
+if test "x${enable_usecat}" = "x1"; then
+	version=[`uname -r`]
+	modulesdir=/lib/modules/${version}
+	sourcedir=`cd ${modulesdir}/build && pwd -P`
+	AC_SUBST(LINUX_SOURCE_DIR,[$sourcedir])
+else
 AC_ARG_WITH([linux-dir],
     AC_HELP_STRING(
         [--with-linux-dir=<DIR>],
@@ -1068,6 +1073,7 @@ AC_CONFIG_FILES([
         examples/tty/Kbuild
         examples/tty/Makefile
         examples/user/Makefile
+        examples/motor_control/Makefile
         examples/xenomai/Makefile
         examples/xenomai_posix/Makefile
         include/Makefile
diff --git a/devices/nxp_userspace/usm_main.c b/devices/nxp_userspace/usm_main.c
new file mode 100644
index 00000000..28972ec7
--- /dev/null
+++ b/devices/nxp_userspace/usm_main.c
@@ -0,0 +1,308 @@
+/* SPDX-License-Identifier: BSD-3-Clause
+ * Copyright 2023 NXP
+ */
+
+#define _GNU_SOURCE
+#include <pthread.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/err.h>
+#include <linux/version.h>
+#include <linux/netdevice.h>
+#include <linux/if_arp.h> /* ARPHRD_ETHER */
+#include <linux/etherdevice.h>
+#include <sys/sysinfo.h>
+
+#include "../globals.h"
+#include "../ecdev.h"
+#include "device.h"
+#include "usm_main.h"
+
+#define PFX "nxp_us_drv: "
+
+MODULE_DESCRIPTION("NXP user space driver module");
+MODULE_LICENSE("GPL");
+MODULE_VERSION(EC_MASTER_VERSION);
+
+
+int __init ec_usm_init_module(void);
+void __exit ec_usm_cleanup_module(void);
+
+typedef struct {
+    struct net_device *netdev;
+    ec_device_t *ecdev;
+    uint8_t *rx_buf[MAX_RX_BD_RING_SIZE];
+    uint8_t *tx_buf[MAX_TX_BD_RING_SIZE];
+    uint32_t rx_idxs[MAX_RX_BD_RING_SIZE];
+    uint16_t rx_lens[MAX_RX_BD_RING_SIZE];
+    int rx_cnt;
+} ec_usm_device_t;
+
+static ec_usm_device_t sec_usm_dev;
+static uint32_t score_mask = 0x02;
+
+extern int ec_master_set_noop_mode(uint32_t cycle_ns);
+static int ec_usm_device_xmit(ec_usm_device_t *, struct sk_buff *);
+static void ec_usm_device_poll(ec_usm_device_t *);
+
+static int ecus_set_core_mask(uint32_t core_mask)
+{
+    if (core_mask == 0)
+        return -1;
+
+    score_mask = core_mask;
+    return 0;
+}
+
+uint32_t ecus_get_core_mask(void)
+{
+    return score_mask;
+}
+
+int ecus_bind_cpu_core(uint32_t core_mask)
+{
+    pthread_t thread;
+    cpu_set_t cpuset;
+    int core_num = 0;
+    int ret = 0;
+    int i = 0;
+
+    thread = pthread_self();
+    core_num = get_nprocs();
+
+    CPU_ZERO(&cpuset);
+
+    if (core_num == 1) {
+        CPU_SET(0, &cpuset);
+        goto set_tag;
+    }
+
+    for (i = 0; i < 32; i++) {
+        if (core_mask & (0x01 << i))
+            CPU_SET(i, &cpuset);
+    }
+
+set_tag:
+    ret = pthread_setaffinity_np(thread, sizeof(cpu_set_t), &cpuset);
+    if (ret != 0)
+        printk(KERN_ERR PFX "pthread_setaffinity_np failed!\n");
+
+    return ret;
+}
+
+static int ec_usm_netdev_open(struct net_device *dev)
+{
+    return 0;
+}
+
+static int ec_usm_netdev_stop(struct net_device *dev)
+{
+    return 0;
+}
+
+static int ec_usm_netdev_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+    ec_usm_device_t *usm_dev = &sec_usm_dev;
+
+    return ec_usm_device_xmit(usm_dev, skb);
+}
+
+static void ec_usm_poll(struct net_device *dev)
+{
+    ec_usm_device_t *usm_dev = &sec_usm_dev;
+
+    return ec_usm_device_poll(usm_dev);
+}
+
+static const struct net_device_ops ec_usm_netdev_ops = {
+    .ndo_open       = ec_usm_netdev_open,
+    .ndo_stop       = ec_usm_netdev_stop,
+    .ndo_start_xmit = ec_usm_netdev_xmit,
+};
+
+static inline void ec_usm_ether_setup(struct net_device *netdev)
+{
+    uint8_t smac[6] = {0x04, 0x13, 0x07, 0x02, 0x00, 0x13};
+
+    memcpy(netdev->dev_addr, smac, 6);
+    netdev->type = ARPHRD_ETHER;
+    netdev->ifindex = 0;
+}
+
+/** Init userspace-master device.
+ */
+static int ec_usm_device_init(ec_usm_device_t *dev)
+{
+    ec_usm_device_t **priv;
+    int i = 0;
+
+    dev->ecdev = NULL;
+    dev->netdev = alloc_netdev(sizeof(ec_usm_device_t *), "ecat0", NET_NAME_UNKNOWN, ec_usm_ether_setup);
+    if (!dev->netdev)
+        return -ENOMEM;
+
+    dev->netdev->netdev_ops = &ec_usm_netdev_ops;
+
+    for (i = 0; i < MAX_RX_BD_RING_SIZE; i++)
+        dev->rx_buf[i] = us_drv_get_rx_buf(i);
+
+    for (i = 0; i < MAX_TX_BD_RING_SIZE; i++)
+        dev->tx_buf[i] = us_drv_get_tx_buf(i);
+
+    priv = netdev_priv(dev->netdev);
+    *priv = dev;
+
+    return 0;
+}
+
+/** Clear userspace-master device.
+ */
+static void ec_usm_device_clear(ec_usm_device_t *dev)
+{
+    if (dev->ecdev) {
+        ecdev_close(dev->ecdev);
+        ecdev_withdraw(dev->ecdev);
+    }
+
+    free_netdev(dev->netdev);
+}
+
+/** Offer userspace-master device to master.
+ */
+static int ec_usm_device_offer(ec_usm_device_t *dev)
+{
+    int ret = 0;
+
+    dev->ecdev = ecdev_offer(dev->netdev, ec_usm_poll, THIS_MODULE);
+    if (!dev->ecdev) {
+        printk("%s(): ecdev_offer failed!\n", __func__);
+        return -1;
+    }
+
+    ret = ecdev_open(dev->ecdev);
+    if (ret) {
+        ecdev_withdraw(dev->ecdev);
+        dev->ecdev = NULL;
+        return -2;
+    }
+
+    ecdev_set_link(dev->ecdev, netif_carrier_ok(dev->netdev));
+
+    return ret;
+}
+
+static int ec_usm_device_xmit(ec_usm_device_t *dev, struct sk_buff *skb)
+{
+    size_t len = skb->len;
+    int ret = 0;
+
+    ret = us_drv_send(skb->data, skb->len, 0);
+    return (ret == len) ? NETDEV_TX_OK : NETDEV_TX_BUSY;
+}
+
+/** Polls the device.
+ */
+static void ec_usm_device_poll(ec_usm_device_t *dev)
+{
+    uint8_t *rx_buf = NULL;
+    uint32_t rx_idx = 0;
+    uint16_t rx_len = 0;
+    int i = 0;
+
+    dev->rx_cnt = us_drv_recv(NULL, dev->rx_lens, dev->rx_idxs);
+    if (dev->rx_cnt <= 0)
+        return;
+
+    for (i = 0; i < dev->rx_cnt; i++) {
+        rx_idx = dev->rx_idxs[i];
+        rx_buf = dev->rx_buf[rx_idx];
+        rx_len = dev->rx_lens[i];
+
+        ecdev_receive(dev->ecdev, rx_buf, rx_len);
+    }
+
+    return;
+}
+
+/** Offer device.
+ */
+static int ec_usm_offer_device(ec_usm_device_t *usm_dev)
+{
+    int ret = 0;
+
+    ret = ec_usm_device_init(usm_dev);
+    if (ret)
+        return ret;
+
+    ret = ec_usm_device_offer(usm_dev);
+    if (ret)
+        return ret;
+
+    return ret;
+}
+
+/** Clear devices.
+ */
+static void ec_usm_clear_devices(void)
+{
+    ec_usm_device_t *usm_dev = &sec_usm_dev;
+
+    ec_usm_device_clear(usm_dev);
+}
+
+/** Initialize userspace-master net devices.
+ * it should be called before ecus_init
+ */
+int ec_usm_net_init(uint32_t cycle_ns, uint32_t core_mask)
+{
+    int ret = 0;
+
+    ec_master_set_noop_mode(cycle_ns);
+
+    ecus_set_core_mask(core_mask);
+
+    ret = us_drv_lib_init(LINK_100M);
+    if (ret)
+        goto err_tag;
+
+    printf("%s(): cycle_ns:%d core_mask:0x%02X\n", __func__, cycle_ns, ecus_get_core_mask());
+
+err_tag:
+    if (ret)
+        printf("%s(): run failed! ret:%d\n", __func__, ret);
+
+    return ret;
+}
+
+/** Module initialization.
+ *
+ * Initializes \a master_count masters.
+ * \return 0 on success, else < 0
+ */
+int __init ec_usm_init_module(void)
+{
+    int ret = 0;
+
+    printk(KERN_INFO PFX "EtherCAT master driver, ver:%s\n", EC_MASTER_VERSION);
+
+    ret = ec_usm_offer_device(&sec_usm_dev);
+    if (ret) {
+        printk("%s(): offer userspace-master device failed!\n", __func__);
+        ret = -1;
+    }
+
+    return ret;
+}
+
+/** Module cleanup.
+ *
+ * Clears all master instances.
+ */
+void __exit ec_usm_cleanup_module(void)
+{
+    ec_usm_clear_devices();
+    us_drv_lib_exit(0);
+}
+
+module_init(ec_usm_init_module);
+module_exit(ec_usm_cleanup_module);
diff --git a/devices/nxp_userspace/usm_main.h b/devices/nxp_userspace/usm_main.h
new file mode 100644
index 00000000..e43a5b7b
--- /dev/null
+++ b/devices/nxp_userspace/usm_main.h
@@ -0,0 +1,41 @@
+/* SPDX-License-Identifier: BSD-3-Clause
+ * Copyright 2024 NXP
+ */
+
+#ifndef __US_DRV_LIB__
+#define __US_DRV_LIB__
+
+#include <sys/mman.h>
+#include <sys/stat.h>
+#include <sys/sysinfo.h>
+#include <fcntl.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdint.h>
+#include <unistd.h>
+
+
+#ifndef MAX_TX_BD_RING_SIZE
+#define MAX_TX_BD_RING_SIZE	(16)
+#endif
+
+#ifndef MAX_RX_BD_RING_SIZE
+#define MAX_RX_BD_RING_SIZE	(16)
+#endif
+
+#define SIZE_OF(x) (sizeof(x)/sizeof(x[0]))
+
+#define LINK_100M	(100)
+#define LINK_1000M	(1000)
+
+int us_drv_lib_init(int link);
+int us_drv_lib_exit(int stat);
+
+uint8_t* us_drv_get_rx_buf(int idx);
+uint8_t* us_drv_get_tx_buf(int idx);
+
+int us_drv_recv(void *buf, uint16_t *plen, uint32_t *pindex);
+int us_drv_send(void *buf, uint16_t len, uint32_t addr);
+
+#endif
diff --git a/emulation/linux/jiffies.h b/emulation/linux/jiffies.h
index eb736b7a..c977b6dc 100644
--- a/emulation/linux/jiffies.h
+++ b/emulation/linux/jiffies.h
@@ -37,16 +37,29 @@ typedef u64 cycles_t;
 
 static const unsigned int cpu_khz = 1000;  // unit of get_cycles()
 
+#ifdef EC_USERSPACE_MASTER_NEW
+int ec_master_in_noop_mode(void);
+uint64_t ec_master_cycle_us(void);
+#define HZ (250)
+#else
+#define HZ (1000)
+#endif
+
 static inline cycles_t get_cycles(void)
 {
     struct timeval TVal;
+
+#ifdef EC_USERSPACE_MASTER_NEW
+    if (ec_master_in_noop_mode())
+        return ec_master_cycle_us();
+#endif
+
     // thanks to VDSO, gettimeofday() does not require a system call
     if (gettimeofday (&TVal, NULL) < 0)
         return -1;
     return (cycles_t) TVal.tv_sec * 1000000 + TVal.tv_usec;
 }
 
-#define HZ 1000
 #define jiffies ((unsigned long) (get_cycles () / (cpu_khz * 1000 / HZ)))
 
 #endif
diff --git a/emulation/linux/kthread.h b/emulation/linux/kthread.h
index 82adf54a..1d18513c 100644
--- a/emulation/linux/kthread.h
+++ b/emulation/linux/kthread.h
@@ -1,6 +1,7 @@
 #ifndef _LINUX_KTHREAD_H
 #define _LINUX_KTHREAD_H
 
+#include <limits.h>
 #include <pthread.h>
 #include <signal.h>
 #include <string.h>
@@ -25,15 +26,26 @@ static inline void dummy_signal_handler(int sig)
     (void) sig;
 }
 
+#ifdef EC_USERSPACE_MASTER_NEW
+int ecus_bind_cpu_core(uint32_t core_mask);
+uint32_t ecus_get_core_mask(void);
+#endif
+
 static inline void *task_run(void *arg)
 {
     current_task = (struct task_struct *) arg;
     prctl(PR_SET_NAME, current_task->name);
+
+#ifdef EC_USERSPACE_MASTER_NEW
+    ecus_bind_cpu_core(ecus_get_core_mask());
+#else
     struct sigaction a;
     memset(&a, 0, sizeof (a));
     a.sa_handler = dummy_signal_handler;
     sigemptyset(&a.sa_mask);
     sigaction(SIGUSR1, &a, NULL);
+#endif
+
     current_task->thread_func(current_task->data);
     return NULL;
 }
@@ -41,6 +53,29 @@ static inline void *task_run(void *arg)
 static inline struct task_struct *kthread_run(int (*thread_func)(void *), void *data, const char *namefmt, ...)
 {
     struct task_struct *task = malloc(sizeof(struct task_struct));
+    pthread_attr_t *pthattr = NULL;
+    int ret = 0;
+
+#ifdef EC_USERSPACE_MASTER_NEW
+    struct sched_param param;
+    pthread_attr_t thattr;
+
+    pthread_attr_init(&thattr);
+    pthread_attr_setstacksize(&thattr, PTHREAD_STACK_MIN);
+    ret = pthread_attr_setschedpolicy(&thattr, SCHED_FIFO);
+    if (ret) {
+        fprintf(stderr, "%s\n", strerror(ret));
+    }
+
+    param.sched_priority = sched_get_priority_max(SCHED_FIFO) - 5;
+    ret = pthread_attr_setschedparam(&thattr, &param);
+    if (ret) {
+        printf(" OP pthread setschedparam failed. ");
+        fprintf(stderr, "%s\n", strerror(ret));
+    }
+    pthattr = &thattr;
+#endif
+
     if (!task)
         return ERR_PTR(-ENOMEM);
     task->thread_func = thread_func;
@@ -50,7 +85,7 @@ static inline struct task_struct *kthread_run(int (*thread_func)(void *), void *
     vsnprintf(task->name, sizeof(task->name), namefmt, args);
     va_end(args);
     task->should_stop = 0;
-    int ret = pthread_create(&task->thread, NULL, task_run, task);
+    ret = pthread_create(&task->thread, pthattr, task_run, task);
     if (ret == 0)
         return task;
     free(task);
@@ -59,7 +94,9 @@ static inline struct task_struct *kthread_run(int (*thread_func)(void *), void *
 
 static inline void kthread_stop(struct task_struct *task)
 {
+#ifndef EC_USERSPACE_MASTER_NEW
     pthread_kill(task->thread, SIGUSR1);  // interrupt blocking system calls
+#endif
     task->should_stop = 1;
     pthread_join(task->thread, NULL);
     free(task);
diff --git a/emulation/linux/skbuff.h b/emulation/linux/skbuff.h
index 569d5768..4b433a41 100644
--- a/emulation/linux/skbuff.h
+++ b/emulation/linux/skbuff.h
@@ -12,6 +12,7 @@ struct sk_buff
     struct net_device   *dev;
     int                 ip_summed;
     uint16_t            protocol;
+    uint16_t            free_buf;
 };
 
 #define eth_type_trans(SKB, DEV) 0
@@ -22,6 +23,7 @@ static inline struct sk_buff *dev_alloc_skb(unsigned int length)
     if(!buf)
         return buf;
     buf->len = 0;
+    buf->free_buf = 1;
     buf->data = buf->head = buf->tail = malloc(length);
     if (!buf->head) {
         free(buf);
@@ -32,7 +34,8 @@ static inline struct sk_buff *dev_alloc_skb(unsigned int length)
 
 static inline void dev_kfree_skb(struct sk_buff *skb)
 {
-    free(skb->head);
+    if (skb->free_buf)
+        free(skb->head);
     free(skb);
 }
 
diff --git a/emulation/linux/wait.h b/emulation/linux/wait.h
index 66df6f22..61e75973 100644
--- a/emulation/linux/wait.h
+++ b/emulation/linux/wait.h
@@ -1,6 +1,6 @@
 #ifndef _LINUX_WAIT_H
 #define _LINUX_WAIT_H
-
+#define __USE_GNU
 #include <pthread.h>
 
 struct __wait_queue_head
diff --git a/examples/Makefile.am b/examples/Makefile.am
index 9dcbef2c..0a39ef18 100644
--- a/examples/Makefile.am
+++ b/examples/Makefile.am
@@ -54,6 +54,10 @@ SUBDIRS += \
 endif
 endif
 
+if ENABLE_USERSPACE_MASTER
+SUBDIRS += motor_control
+endif
+
 DIST_SUBDIRS = \
 	dc_rtai \
 	dc_user \
@@ -63,6 +67,7 @@ DIST_SUBDIRS = \
 	rtai_rtdm_dc \
 	tty \
 	user \
+	motor_control \
 	xenomai \
 	xenomai_posix
 
diff --git a/examples/motor_control/Makefile.am b/examples/motor_control/Makefile.am
new file mode 100644
index 00000000..12b3f230
--- /dev/null
+++ b/examples/motor_control/Makefile.am
@@ -0,0 +1,42 @@
+#------------------------------------------------------------------------------
+#
+#  $Id$
+#
+#  Copyright 2024 NXP
+#
+#  This file is part of the IgH EtherCAT Master.
+#
+#  The IgH EtherCAT Master is free software; you can redistribute it and/or
+#  modify it under the terms of the GNU General Public License version 2, as
+#  published by the Free Software Foundation.
+#
+#  The IgH EtherCAT Master is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
+#  Public License for more details.
+#
+#  You should have received a copy of the GNU General Public License along with
+#  the IgH EtherCAT Master; if not, write to the Free Software Foundation,
+#  Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+#
+#  ---
+#
+#  The license mentioned above concerns the source code only. Using the
+#  EtherCAT technology and brand is only permitted in compliance with the
+#  industrial property and similar rights of Beckhoff Automation GmbH.
+#
+#------------------------------------------------------------------------------
+
+noinst_PROGRAMS = ec_motor_example
+
+ec_motor_example_SOURCES = main.c
+ec_motor_example_CFLAGS = -I$(top_srcdir)/include -Wall
+
+if ENABLE_USERSPACE_MASTER
+ec_motor_example_CFLAGS += -DEC_MASTER_IN_USERSPACE
+ec_motor_example_LDFLAGS = -L$(top_builddir)/master/.libs -L$(top_builddir)/devices/nxp_userspace -lethercat_master -lpthread
+else
+ec_motor_example_LDFLAGS = -L$(top_builddir)/lib/.libs
+endif
+
+#------------------------------------------------------------------------------
diff --git a/examples/motor_control/main.c b/examples/motor_control/main.c
new file mode 100644
index 00000000..6c2b9229
--- /dev/null
+++ b/examples/motor_control/main.c
@@ -0,0 +1,589 @@
+/*****************************************************************************
+ *
+ *  $Id$
+ *
+ *  Copyright 2024 NXP
+ *
+ *  This file is part of the IgH EtherCAT Master.
+ *
+ *  The IgH EtherCAT Master is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License version 2, as
+ *  published by the Free Software Foundation.
+ *
+ *  The IgH EtherCAT Master is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
+ *  Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with the IgH EtherCAT Master; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *  ---
+ *
+ *  The license mentioned above concerns the source code only. Using the
+ *  EtherCAT technology and brand is only permitted in compliance with the
+ *  industrial property and similar rights of Beckhoff Automation GmbH.
+ *
+ ****************************************************************************/
+
+#include <errno.h>
+#include <signal.h>
+#include <stdio.h>
+#include <string.h>
+#include <sys/resource.h>
+#include <sys/time.h>
+#include <time.h>
+#include <sys/types.h>
+#include <unistd.h>
+
+#include "ecrt.h"
+
+#define ECAT_RT1180
+#define RT1180_VID (0x0CC2)
+#define RT1180_PID (0x0002)
+
+static int srt1180_flag = 0;
+
+typedef struct _ec_reg_pdo_cfg_t {
+	uint16_t index;
+	uint8_t subindex;
+	int32_t *poffset;
+} ec_reg_pdo_cfg_t;
+
+typedef enum {
+	no_ready_to_switch_on = 0,
+	switch_on_disable,
+	ready_to_switch_on,
+	switched_on,
+	operation_enable,
+	quick_stop_active,
+	fault_reaction_active,
+	fault,
+	none
+} servo_axle_state;
+
+typedef enum {
+	op_mode_no = 0,
+	op_mode_pp = 1,
+	op_mode_vl = 2,
+	op_mode_pv = 3,
+	op_mode_hm = 6,
+	op_mode_ip = 7,
+	op_mode_csp = 8,
+	op_mode_csv = 9,
+	op_mode_cst = 10
+} mode_of_operation;
+
+typedef struct _motor_axle_info_t {
+	uint32_t product_code;
+	uint32_t vendor_id;
+	int32_t base_pos;
+	int32_t cur_pos;
+	float fratio;
+	int init_flag;
+	int ctrl_flag;
+	int pos_idx;
+	int sec_cnt;
+} motor_axle_info_t;
+
+#define contrlword_shutdown(c)			(((c) | 0x6) & ~0x81)
+#define contrlword_switch_on(c) 		(((c) | 0x7) & ~0x88)
+#define contrlword_enable_operation(c)		(((c) | 0xF) & ~0x80)
+#define contrlword_fault_reset(c)		((c) | 0x80)
+
+#define EC_BIND_CORE_MASK (0x02)  /* working on core1 in default */
+
+#define NUM_OF(x) (sizeof(x) / sizeof(x[0]))
+#define NSEC_PER_SEC (1000000000L)
+#define CYCLE_TIME_NS (1000000)  /* cycle time: 1ms */
+#define TIMESPEC2NS(T) ((uint64_t) (T).tv_sec * NSEC_PER_SEC + (T).tv_nsec)
+
+#define FREE(p) do {if (p) free(p);} while(0)
+#define RET_ERR(r, s) do {printf("Error:%d, %s", (r), (s)); ret = (r); goto ret_tag;} while(0)
+
+static ec_master_t *sec_master = NULL;
+static ec_domain_t *sec_domain = NULL;
+
+static uint32_t sec_rate = 2 << 16;
+static uint32_t sec_axle_num = 1;
+
+static motor_axle_info_t *sp_axle_info = NULL;
+static uint8_t *sec_domain_pd = NULL;
+static uint8_t *sp_axle_data = NULL;
+static int sall_op_flag = 0;
+static int sloop_flag = 1;
+static int sexit_flag = 0;
+
+static inline struct timespec timespec_add(struct timespec t1, struct timespec t2)
+{
+	struct timespec result;
+
+	if ((t1.tv_nsec + t2.tv_nsec) >= NSEC_PER_SEC) {
+		result.tv_sec = t1.tv_sec + t2.tv_sec + 1;
+		result.tv_nsec = t1.tv_nsec + t2.tv_nsec - NSEC_PER_SEC;
+	} else {
+		result.tv_sec = t1.tv_sec + t2.tv_sec;
+		result.tv_nsec = t1.tv_nsec + t2.tv_nsec;
+	}
+
+	return result;
+}
+
+static ec_reg_pdo_cfg_t sec_reg_pdo_cfg[] = {
+	{0x6040, 0x0},  /* controlword */
+	{0x6041, 0x0},  /* statusword */
+	{0x6064, 0x0},  /* actual_position */
+	{0x6060, 0x0},  /* op_mode */
+	{0x6061, 0x0},
+	{0x607A, 0x0},  /* target_position */
+	{0x60FF, 0x0},
+};
+#define sec_ctrl_word(x)	(*(sec_reg_pdo_cfg[0].poffset + (x)))
+#define sec_stat_word(x)	(*(sec_reg_pdo_cfg[1].poffset + (x)))
+#define sec_actual_pos(x)	(*(sec_reg_pdo_cfg[2].poffset + (x)))
+#define sec_op_mode(x)		(*(sec_reg_pdo_cfg[3].poffset + (x)))
+#define sec_target_pos(x)	(*(sec_reg_pdo_cfg[5].poffset + (x)))
+
+static ec_pdo_entry_info_t sec_rx_pdo_entry[] = {
+	{0x6040, 0, 16},  /* controlword */
+	{0x607A, 0, 32},  /* target_position */
+	{0x60FF, 0, 32},  /* target_velocity */
+	{0x6060, 0, 8},   /* op_mode */
+#ifdef ECAT_RT1180
+	{0x0000, 0, 8},   /* gap */
+#endif
+};
+
+static ec_pdo_entry_info_t sec_tx_pdo_entry[] = {
+	{0x6041, 0, 16},  /* statusword */
+	{0x6064, 0, 32},  /* actual_position */
+	{0x606c, 0, 32},  /* actual_velocity */
+	{0x6061, 0, 8},   /* op_mode_display */
+#ifdef ECAT_RT1180
+	{0x0000, 0, 8},   /* gap */
+#endif
+};
+
+static ec_pdo_info_t sec_rx_pdo[] = {
+	{0x1600, NUM_OF(sec_rx_pdo_entry), sec_rx_pdo_entry},
+#ifdef ECAT_RT1180
+	{0x1610, NUM_OF(sec_rx_pdo_entry), sec_rx_pdo_entry},
+#endif
+};
+
+static ec_pdo_info_t sec_tx_pdo[] = {
+	{0x1a00, NUM_OF(sec_tx_pdo_entry), sec_tx_pdo_entry},
+#ifdef ECAT_RT1180
+	{0x1a10, NUM_OF(sec_tx_pdo_entry), sec_tx_pdo_entry},
+#endif
+};
+
+static ec_sync_info_t sec_sync_mgr[] = {
+	{2, EC_DIR_OUTPUT, NUM_OF(sec_rx_pdo), sec_rx_pdo},
+	{3, EC_DIR_INPUT, NUM_OF(sec_tx_pdo), sec_tx_pdo},
+};
+
+#ifdef ECAT_RT1180
+static int get_pdo_entry_offset(void)
+{
+	ec_pdo_entry_info_t *pe = sec_rx_pdo_entry;
+	int bl = 0;
+	int i = 0;
+
+	for (i = 0; i < NUM_OF(sec_rx_pdo_entry); i++)
+		bl += pe[i].bit_length;
+
+	return (bl / 8);
+}
+#endif
+
+static int update_axle_config(int axle_num)
+{
+	ec_reg_pdo_cfg_t *pe = sec_reg_pdo_cfg;
+	int num = NUM_OF(sec_reg_pdo_cfg);
+	uint8_t *p = NULL;
+	int len = 0;
+	int i = 0;
+
+	len = sizeof(int32_t) * axle_num;
+	p = (uint8_t*)calloc(num, len);
+	if (!p)
+		return -1;
+
+	sp_axle_data = p;
+	for (i = 0; i < num; i++) {
+		pe[i].poffset = (int32_t*)p;
+		p += len;
+	}
+
+#ifdef ECAT_RT1180
+	if (!srt1180_flag) {
+		ec_sync_info_t *psync = NULL;
+		ec_pdo_info_t *pdo = NULL;
+		int j = 0;
+
+		for (i = 0; i < NUM_OF(sec_sync_mgr); i++) {
+			psync = sec_sync_mgr + i;
+			psync->n_pdos--;
+
+			for (j = 0; j < psync->n_pdos; j++) {
+				pdo = psync->pdos + j;
+				pdo->n_entries--;
+			}
+		}
+	}
+#endif
+
+	return 0;
+}
+
+static servo_axle_state get_axle_state(uint16_t status_word)
+{
+	if ((status_word & 0x4F) == 0x40)
+		return switch_on_disable;
+	if ((status_word & 0x6F) == 0x21)
+		return ready_to_switch_on;
+	if ((status_word & 0x6F) == 0x23)
+		return switched_on;
+	if ((status_word & 0x6F) == 0x27)
+		return operation_enable;
+	if ((status_word & 0x6F) == 0x07)
+		return quick_stop_active;
+	if ((status_word & 0x4F) == 0xF)
+		return fault_reaction_active;
+	if ((status_word & 0x4F) == 0x08)
+		return fault;
+	else
+		return no_ready_to_switch_on;
+}
+
+static int servo_axle_switch_mode(int axle)
+{
+	uint16_t status_word = 0;
+	servo_axle_state s = 0;
+	int ret = -1;
+
+	status_word = EC_READ_U16(sec_domain_pd + sec_stat_word(axle));
+	s = get_axle_state(status_word);
+
+	switch (s) {
+	case (no_ready_to_switch_on):
+	case (switch_on_disable):
+		EC_WRITE_U16(sec_domain_pd + sec_ctrl_word(axle), contrlword_shutdown(0));
+		break;
+	case (ready_to_switch_on):
+		EC_WRITE_U16(sec_domain_pd + sec_ctrl_word(axle), contrlword_switch_on(0));
+		break;
+	case (switched_on):
+		EC_WRITE_U8(sec_domain_pd + sec_op_mode(axle), op_mode_csp);
+		EC_WRITE_U16(sec_domain_pd + sec_ctrl_word(axle), contrlword_enable_operation(0));
+		break;
+	case (operation_enable):
+		ret = 0;
+		break;
+	case (quick_stop_active):
+	case (fault_reaction_active):
+		ret = -3;
+		break;
+	case (fault):
+		EC_WRITE_U16(sec_domain_pd + sec_ctrl_word(axle), contrlword_fault_reset(0));
+		ret = -4;
+		break;
+	default:
+		ret = -2;
+	}
+
+	return ret;
+}
+
+static int update_motor_position(int axle)
+{
+	motor_axle_info_t *paxle = sp_axle_info + axle;
+	int ret = 0;
+
+	ret = servo_axle_switch_mode(axle);
+	if (ret)
+		return ret;
+
+	if (!paxle->init_flag) {
+		paxle->base_pos = EC_READ_U16(sec_domain_pd + sec_actual_pos(axle));
+		paxle->fratio = sec_rate / 1000.0;
+		paxle->init_flag = 1;
+	}
+
+	if (sexit_flag && (paxle->pos_idx == 0)) {
+		paxle->sec_cnt++;
+		if (paxle->sec_cnt > 3000)
+			sloop_flag = 0;
+		return 0;
+	}
+
+	if (paxle->ctrl_flag) {
+		paxle->pos_idx++;
+		if (sexit_flag && (paxle->pos_idx > 0))
+			paxle->ctrl_flag = 0;
+		else if (paxle->pos_idx >= 10000)  /* rotate forward for 10s */
+			paxle->ctrl_flag = 0;
+	} else {
+		paxle->pos_idx--;
+		if (sexit_flag && (paxle->pos_idx < 0))
+			paxle->ctrl_flag = 1;
+		else if (paxle->pos_idx <= -10000)  /* rotate backward for 10s */
+			paxle->ctrl_flag = 1;
+	}
+
+	paxle->cur_pos = paxle->base_pos + paxle->fratio * paxle->pos_idx;
+	EC_WRITE_U32(sec_domain_pd + sec_target_pos(axle), paxle->cur_pos);
+
+	return 0;
+}
+
+void run_main_cycle_task(void)
+{
+	struct timespec cycletime = {0, CYCLE_TIME_NS};
+	ec_master_state_t master_state;
+	struct timespec wakeupTime;
+	struct timespec start_time;
+	int axle = 0;
+
+#ifdef EC_MASTER_IN_USERSPACE
+	ecus_bind_cpu_core(EC_BIND_CORE_MASK);
+#endif
+
+	clock_gettime(CLOCK_REALTIME, &wakeupTime);
+	while (sloop_flag) {
+		wakeupTime = timespec_add(wakeupTime, cycletime);
+		clock_nanosleep(CLOCK_REALTIME, TIMER_ABSTIME, &wakeupTime, NULL);
+		clock_gettime(CLOCK_REALTIME, &start_time);
+
+		/* receive process data */
+		ecrt_master_receive(sec_master);
+		ecrt_domain_process(sec_domain);
+
+		/* time sync and reference clock */
+		ecrt_master_application_time(sec_master, TIMESPEC2NS(start_time));
+		ecrt_master_sync_reference_clock(sec_master);
+		ecrt_master_sync_slave_clocks(sec_master);
+
+#ifdef EC_MASTER_IN_USERSPACE
+		ecus_master_operation_loop(sec_master, 1);
+#endif
+
+		if (sall_op_flag) {
+			for (axle = 0; axle < sec_axle_num; axle++)
+			      update_motor_position(axle);
+		} else {
+			ecrt_master_state(sec_master, &master_state);
+			if (master_state.al_states == 0x08) {
+				sall_op_flag = 1;
+				printf("EtherCAT master is ALL_OP\n");
+			}
+		}
+
+		/* send process data */
+		ecrt_domain_queue(sec_domain);
+		ecrt_master_send(sec_master);
+
+#ifdef EC_MASTER_IN_USERSPACE
+		ecus_master_operation_loop(sec_master, 0);
+#endif
+	}
+}
+
+void signal_handler(int signum)
+{
+	if (sall_op_flag) {
+		sexit_flag = 1;
+		printf("\nSystem will exit after several seconds...\n");
+	} else {
+		sloop_flag = 0;
+		printf("\nSystem will exit...\n");
+	}
+}
+
+#ifdef EC_MASTER_IN_USERSPACE
+#define MAX_MASTER_NUM (32)
+static int smaster_count = 1;
+static char *smaster_macs[MAX_MASTER_NUM] = {
+	"04:13:07:02:00:13",
+};
+
+static int sbackup_count = 0;
+static char *sbackup_macs[MAX_MASTER_NUM];
+
+int is_all_slaves_ready(void)
+{
+	int ready = 0;
+	int i = 0;
+
+	for (i = 0; i < sec_axle_num; i++) {
+		ready = ecus_slave_is_ready(0, 0, i);
+		if (!ready)
+			return 0;
+	}
+
+	return 1;
+}
+#endif
+
+int main(int argc, char **argv)
+{
+#ifdef EC_MASTER_IN_USERSPACE
+	const char **masters = (const char **)smaster_macs;
+	const char **backups = (const char **)sbackup_macs;
+#endif
+	ec_slave_config_t *pslave_config = NULL;
+	motor_axle_info_t *paxle = NULL;
+	char *pmotor_type = "EtherCAT";
+	ec_reg_pdo_cfg_t *prp  = NULL;
+	ec_slave_info_t slave_info;
+	int axle_offset = 0;
+	int32_t pdo_oft = 0;
+	int ecat_flag = 0;
+	int axle = 0;
+	int sec = 0;
+	int ret = 0;
+	int i = 0;
+
+	signal(SIGTERM, signal_handler);
+	signal(SIGINT, signal_handler);
+
+	if (argc > 1) {
+		if (!strcmp(argv[1], "-h") || !strcmp(argv[1], "--help")) {
+			printf("Usage:\n  %s [encode_rate] [axle_num]\n\n", argv[0]);
+			return 0;
+		}
+		sec_rate = strtoul(argv[1], NULL, 0);
+
+		if (argc > 2)
+			sec_axle_num = strtoul(argv[2], NULL, 0);
+	}
+	printf("%s ec_rate:%d axle_num:%d\n", argv[0], sec_rate, sec_axle_num);
+
+#ifdef EC_MASTER_IN_USERSPACE
+	ret = ecus_init(smaster_count, masters, sbackup_count, backups, 0, CYCLE_TIME_NS, EC_BIND_CORE_MASK);
+	if (ret)
+		RET_ERR(-1, "Failed to init userspace EtherCAT!\n");
+
+	ecat_flag = 1;
+	printf("waiting for slaves ");
+	for (sec = 0; sec < 60; sec++) {
+		if (sexit_flag)
+			break;
+
+		if (is_all_slaves_ready()) {
+			printf("\nAll slaves are ready, sec:%d\n", sec);
+			break;
+		}
+		printf(".");
+		sleep(1);
+	}
+	if (sec == 60)
+		RET_ERR(-2, "Timeout to wait for slave to be ready!\n");
+#endif
+	/* Requests an EtherCAT master for realtime operation */
+	sec_master = ecrt_request_master(0);
+	if (!sec_master)
+		RET_ERR(-3, "Failed to request master!\n");
+
+#ifdef ECAT_RT1180
+	/* Check vendor_id and product_code of the firt motor */
+	ret = ecrt_master_get_slave(sec_master, 0, &slave_info);
+	if (ret == 0) {
+		if ((slave_info.vendor_id == RT1180_VID) && (slave_info.product_code == RT1180_PID)) {
+			srt1180_flag = 1;
+			sec_axle_num = 2;  /* For 2-axles slave */
+			pmotor_type = "i.MXRT1180";
+			axle_offset = get_pdo_entry_offset();
+		}
+	}
+#endif
+	sp_axle_info = (motor_axle_info_t*)calloc(sec_axle_num, sizeof(motor_axle_info_t));
+	if (!sp_axle_info)
+		RET_ERR(-3, "Failed to calloc memory for sp_axle_info!\n");
+
+	for (i = 0; i < sec_axle_num; i++) {
+		paxle = sp_axle_info + i;
+
+		ret = ecrt_master_get_slave(sec_master, i, &slave_info);
+		if (ret == 0) {
+			paxle->vendor_id = slave_info.vendor_id;
+			paxle->product_code = slave_info.product_code;
+		} else {
+			RET_ERR(-4, "Failed to get slave information!\n");
+		}
+
+		if (srt1180_flag)
+			break;
+	}
+
+	ret = update_axle_config(sec_axle_num);
+	if (ret)
+		RET_ERR(ret, "Failed to update axle config!\n");
+
+	printf("\n ec_motor_example for %s motor control\n\n", pmotor_type);
+
+	/* Creates a new process data domain */
+	sec_domain = ecrt_master_create_domain(sec_master);
+	if (!sec_domain)
+		RET_ERR(-5, "Failed to create domain for master!\n");
+
+axle_cfg:
+	paxle = sp_axle_info + axle;
+	printf("Configuring for axle-%d vendor_id:0x%X product_code:0x%X\n", axle, paxle->vendor_id, paxle->product_code);
+	/* Obtains slave configuration */
+	pslave_config = ecrt_master_slave_config(sec_master, 0, axle, paxle->vendor_id, paxle->product_code);
+	if (!pslave_config)
+		RET_ERR(-6, "Failed to get slave configuration!\n");
+
+	if (!srt1180_flag) {
+		ecrt_slave_config_sdo32(pslave_config, 0x6083, 0, 0x1000);  /* Profile_acceleration */
+		ecrt_slave_config_sdo32(pslave_config, 0x6084, 0, 0x1000);  /* Profile_deceleration */
+		ecrt_slave_config_sdo32(pslave_config, 0x6085, 0, 0x1000);  /* Quick_stop_deceleration */
+	}
+	ecrt_slave_config_watchdog(pslave_config, 0, 4000);
+	ecrt_slave_config_dc(pslave_config, 0x0300, CYCLE_TIME_NS, 0, 0, 0);
+
+	if (ecrt_slave_config_pdos(pslave_config, NUM_OF(sec_sync_mgr), sec_sync_mgr))
+		RET_ERR(-7, "Failed to configure PDOs!\n");
+
+axle_cfg_1180:
+	for (i = 0; i < NUM_OF(sec_reg_pdo_cfg); i++) {
+		prp = sec_reg_pdo_cfg + i;
+
+		pdo_oft = ecrt_slave_config_reg_pdo_entry(pslave_config, prp->index, prp->subindex, sec_domain, NULL);
+		if (pdo_oft < 0)
+			RET_ERR(-8, "Failed to register PDO entry!\n");
+
+		if (prp->poffset)
+			*(prp->poffset + axle) = (pdo_oft + axle * axle_offset);
+	}
+	if (++axle < sec_axle_num) {
+		if (srt1180_flag)
+			goto axle_cfg_1180;
+		else
+			goto axle_cfg;
+	}
+
+	printf("Activating master...\n");
+	if (ecrt_master_activate(sec_master))
+		RET_ERR(-9, "Failed to activate master!\n");
+
+	sec_domain_pd = ecrt_domain_data(sec_domain);
+	if (!sec_domain_pd)
+		RET_ERR(-10, "Failed to get domain data!\n");
+
+	run_main_cycle_task();
+
+ret_tag:
+	FREE(sp_axle_info);
+	FREE(sp_axle_data);
+
+#ifdef EC_MASTER_IN_USERSPACE
+	if (ecat_flag)
+	      ecus_done();
+#endif
+
+	return 0;
+}
diff --git a/globals.h b/globals.h
index 3460e348..b161cab6 100644
--- a/globals.h
+++ b/globals.h
@@ -57,10 +57,11 @@
 
 /** Master version string
  */
-#define EC_MASTER_VERSION VERSION " " EC_STR(REV)
 
 /*****************************************************************************/
 #ifdef EC_MASTER_IN_USERSPACE
+#define EC_MASTER_VERSION VERSION " (user-space)"
+
 // Always 0-terminate dest; avoid newer GCC's warnings about strncpy when possibly truncating.
 static inline void ec_strncpy(char *dest, const char *src, unsigned long int n)
 {
@@ -70,6 +71,8 @@ static inline void ec_strncpy(char *dest, const char *src, unsigned long int n)
   while (dest < end)
     *dest++ = 0;
 }
+#else
+#define EC_MASTER_VERSION VERSION " " EC_STR(REV)
 #endif  /* EC_MASTER_IN_USERSPACE */
 
 #endif
diff --git a/include/ecrt.h b/include/ecrt.h
index 696ca3b3..c01ab7ad 100644
--- a/include/ecrt.h
+++ b/include/ecrt.h
@@ -541,10 +541,17 @@ extern "C" {
 #endif
 
 #ifdef EC_MASTER_IN_USERSPACE
-int ecrt_init(unsigned int master_count_, const char *const *master_macs,
-              unsigned int backup_count_, const char *const *backup_macs,
-              unsigned int debug_level_);
-void ecrt_done(void);
+int ecus_init(uint32_t master_count, const char *const *master_macs,
+              uint32_t backup_count, const char *const *backup_macs,
+              uint32_t debug_level, uint32_t cycle_ns, uint32_t core_mask);
+int ecus_done(void);
+
+int ecus_slave_is_ready(uint32_t master_index, uint16_t alias, uint16_t position);
+int ecus_master_operation_loop(ec_master_t *master, int cycle);
+int ecus_enable_ioctl_poll(void);
+
+int ecus_bind_cpu_core(uint32_t core_mask);
+uint32_t ecus_get_core_mask(void);
 #endif
 
 /** Returns the version magic of the realtime interface.
diff --git a/lib/common.c b/lib/common.c
index 1d37863d..783bcfb0 100644
--- a/lib/common.c
+++ b/lib/common.c
@@ -96,6 +96,7 @@ ec_master_t *ecrt_open_master(unsigned int master_index)
     master->fd = ioctl_usecat_open(master_index, NULL);
     return master;
 #else
+
     snprintf(path, MAX_PATH_LEN - 1,
 #ifdef USE_RTDM
             "EtherCAT%u",
diff --git a/libecat.mri b/libecat.mri
new file mode 100644
index 00000000..7f2129e6
--- /dev/null
+++ b/libecat.mri
@@ -0,0 +1,5 @@
+create libethercat_master.a
+addlib ./ecat_build/lib/libethercat_master.a
+addlib ./devices/nxp_userspace/libus_drv.a
+save
+end
diff --git a/master/Makefile.am b/master/Makefile.am
index e9cb23f5..90bd440a 100644
--- a/master/Makefile.am
+++ b/master/Makefile.am
@@ -101,12 +101,14 @@ pkgconfigdir = $(libdir)/pkgconfig
 pkgconfig_DATA = libethercat_master.pc
 EXTRA_DIST += libethercat_master.pc.in
 
-libethercat_master_la_LDFLAGS = -version-info 1:0:0
+libethercat_master_la_LDFLAGS = -version-info 1:0:0 \
+	-L../devices/nxp_userspace/ \
+	-lus_drv
 
 libethercat_master_la_CFLAGS = -I$(srcdir)/.. \
 	-I../emulation \
+	-I../devices/nxp_userspace/ \
 	-D__KERNEL__ \
-	-DEC_HAVE_CYCLES \
 	-DEC_USE_HRTIMER \
 	-DEC_MASTER_IN_USERSPACE \
 	-Wall -Werror \
@@ -150,6 +152,7 @@ libethercat_master_la_SOURCES = \
 	sync.c \
 	sync_config.c \
 	voe_handler.c \
+	../devices/nxp_userspace/usm_main.c \
 	../devices/generic.c
 if ENABLE_EOE
 libethercat_master_la_SOURCES += ethernet.c
diff --git a/master/cdev.c b/master/cdev.c
index 467321f8..d5cab647 100644
--- a/master/cdev.c
+++ b/master/cdev.c
@@ -38,6 +38,11 @@
 #include <linux/vmalloc.h>
 #include <linux/mm.h>
 
+#ifdef EC_MASTER_IN_USERSPACE
+#include <sys/ipc.h>
+#include <sys/shm.h>
+#endif
+
 #include "cdev.h"
 #include "master.h"
 #include "slave_config.h"
@@ -56,26 +61,62 @@
 typedef struct {
     ec_cdev_t *cdev; /**< Character device. */
     ec_ioctl_context_t ctx; /**< Context. */
+#ifdef EC_MASTER_IN_USERSPACE
+    void *pmem;
+    int shmid;
+#endif
 } ec_cdev_priv_t;
 
 /*****************************************************************************/
 
 #ifdef EC_MASTER_IN_USERSPACE
 
-static ec_master_t *sec_masters[MAX_MASTER_NUM];
-static ec_cdev_priv_t sec_privs[MAX_MASTER_NUM];
+static int ec_cdev_alloc_share_memory(ec_master_t *master)
+{
+    ec_cdev_priv_t *priv = NULL;
+    uint8_t *pmem = NULL;
+    int shmid = 0;
+    key_t key = 0;
+
+    key = ftok("/tmp/", 0x88A4 + master->index);
+    if (key == -1) {
+        EC_MASTER_ERR(master, "%s(): ftok failed! key:%d\n", __func__, key);
+        return -1;
+    }
+
+    shmid = shmget(key, 4096, IPC_CREAT | 0666);
+    if (shmid < 0) {
+        EC_MASTER_ERR(master, "%s(): shmget failed! shmid:%d\n", __func__, shmid);
+        return -2;
+    }
+
+    pmem = shmat(shmid, NULL, 0);
+    if (!pmem) {
+        EC_MASTER_ERR(master, "%s(): shmat failed! shmid:%d\n", __func__, shmid);
+        return -3;
+    }
+
+    priv = (ec_cdev_priv_t *)master->priv;
+
+    priv->pmem = pmem;
+    priv->shmid = shmid;
+    master->ioctl_mem = pmem + 1024;
+
+    return 0;
+}
 
 int ec_cdev_usecat_start(ec_master_t *master)
 {
     ec_cdev_priv_t *priv = NULL;
 
-    if (master->index >= MAX_MASTER_NUM) {
-        printf("%s: invalid master index:%d!\n", __func__, master->index);
+    priv = malloc(sizeof(*priv));
+    if (!priv) {
+        EC_MASTER_ERR(master, "%s(): malloc for private data failed!\n", __func__);
         return -1;
     }
 
-    priv = sec_privs + master->index;
-    sec_masters[master->index] = master;
+    master->priv = priv;
+    memset(priv, 0, sizeof(*priv));
 
     priv->cdev = &master->cdev;
     priv->ctx.writable = 1;
@@ -83,14 +124,66 @@ int ec_cdev_usecat_start(ec_master_t *master)
     priv->ctx.process_data = NULL;
     priv->ctx.process_data_size = 0;
 
-    return 0;
+    return ec_cdev_alloc_share_memory(master);
 }
 
 int ec_cdev_usecat_stop(ec_master_t *master)
 {
+    ec_cdev_priv_t *priv = (ec_cdev_priv_t *)master->priv;
+
+    if (!priv)
+        return -1;
+
+    if (priv->pmem) {
+        shmdt(priv->pmem);
+        shmctl(priv->shmid, IPC_RMID, NULL);
+    }
+
+    free(priv);
+
     return 0;
 }
 
+static int eccdev_usecat_ioctl(ec_master_t *master, unsigned int cmd, void *arg)
+{
+    ec_cdev_priv_t *priv = (ec_cdev_priv_t *)master->priv;
+
+    return ec_ioctl(master, &priv->ctx, cmd, (void __user *)arg);
+}
+
+int ec_master_ioctl_poll(void *priv_data)
+{
+    ec_master_t *master = (ec_master_t *)priv_data;
+    volatile struct ecat_shm_info *pshm = NULL;
+    ec_cdev_priv_t *priv = NULL;
+    uint8_t *parg = NULL;
+    uint32_t index = 0;
+    int ret = 0;
+
+    priv = (ec_cdev_priv_t *)master->priv;
+
+    pshm = (volatile struct ecat_shm_info *)priv->pmem;
+    parg = (uint8_t*)(priv->pmem + sizeof(*pshm));
+
+    if (pshm->flag != 1)
+        return 0;
+
+    index = pshm->index;
+    if (index != master->index) {
+        EC_MASTER_ERR(master, "%s: index is invalid! %d != %d\n", __func__, index, master->index);
+        return -1;
+    }
+
+    if (pshm->len > 0)
+        ret = eccdev_usecat_ioctl(master, pshm->cmd, parg);
+    else
+        ret = eccdev_usecat_ioctl(master, pshm->cmd, (void*)(*(uint64_t *)parg));
+
+    pshm->flag = 2;
+
+    return ret;
+}
+
 #else /* EC_MASTER_IN_USERSPACE */
 
 /*****************************************************************************/
@@ -171,25 +264,7 @@ void ec_cdev_clear(ec_cdev_t *cdev /**< EtherCAT XML device */)
     cdev_del(&cdev->cdev);
 }
 
-#ifdef EC_MASTER_IN_USERSPACE
-
-int eccdev_usecat_ioctl(int fd, unsigned int cmd, void *arg)
-{
-    ec_cdev_priv_t *priv = NULL;
-    ec_master_t *master = NULL;
-
-    if (fd >= MAX_MASTER_NUM) {
-        printf("%s: fd is invalid! fd:%d\n", __func__, fd);
-        return -1;
-    }
-
-    master = sec_masters[fd];
-    priv = sec_privs + fd;
-
-    return ec_ioctl(master, &priv->ctx, cmd, (void __user *) arg);
-}
-
-#else /* EC_MASTER_IN_USERSPACE */
+#ifndef EC_MASTER_IN_USERSPACE
 
 /******************************************************************************
  * File operations
diff --git a/master/cdev.h b/master/cdev.h
index 1a7bd18a..dcf4f861 100644
--- a/master/cdev.h
+++ b/master/cdev.h
@@ -51,8 +51,15 @@ typedef struct {
     struct cdev cdev; /**< Character device. */
 } ec_cdev_t;
 
-/*****************************************************************************/
 #ifdef EC_MASTER_IN_USERSPACE
+struct ecat_shm_info {
+    uint32_t flag;
+    uint32_t index;
+    uint32_t cmd;
+    uint32_t len;
+} __attribute__((packed));
+
+/*****************************************************************************/
 int ec_cdev_usecat_start(ec_master_t *master);
 int ec_cdev_usecat_stop(ec_master_t *master);
 #endif
diff --git a/master/datagram.h b/master/datagram.h
index e902fbd4..e1b94f99 100644
--- a/master/datagram.h
+++ b/master/datagram.h
@@ -39,10 +39,13 @@
 
 #include <linux/list.h>
 #include <linux/time.h>
-#include <linux/timex.h>
 
 #include "globals.h"
 
+#ifndef EC_USERSPACE_MASTER_NEW
+#include <linux/timex.h>
+#endif
+
 /*****************************************************************************/
 
 /** EtherCAT datagram type.
diff --git a/master/device.c b/master/device.c
index e25c8301..2d5c2376 100644
--- a/master/device.c
+++ b/master/device.c
@@ -60,6 +60,30 @@
  *
  * \return 0 in case of success, else < 0
  */
+#ifdef EC_USERSPACE_MASTER_NEW
+uint8_t* us_drv_get_tx_buf(int idx);
+static inline struct sk_buff *dev_alloc_ecat_skb(int i)
+{
+    struct sk_buff *buf = NULL;
+
+    buf = malloc(sizeof(struct sk_buff));
+    if(!buf)
+        return NULL;
+
+    buf->len = 0;
+    buf->free_buf = 0;
+#ifdef EC_USERSPACE_MASTER_NEW
+    buf->data = buf->head = buf->tail = us_drv_get_tx_buf(i);
+#endif
+    if (!buf->head) {
+        free(buf);
+        return NULL;
+    }
+
+    return buf;
+}
+#endif
+
 int ec_device_init(
         ec_device_t *device, /**< EtherCAT device */
         ec_master_t *master /**< master owning the device */
@@ -82,7 +106,12 @@ int ec_device_init(
     for (i = 0; i < EC_TX_RING_SIZE; i++) {
         device->tx_skb[i] = NULL;
     }
+#ifdef EC_USERSPACE_MASTER_NEW
+    device->tx_ring_index = (unsigned int)-1;
+#else
     device->tx_ring_index = 0;
+#endif
+
 #ifdef EC_HAVE_CYCLES
     device->cycles_poll = 0;
 #endif
@@ -127,7 +156,11 @@ int ec_device_init(
 #endif
 
     for (i = 0; i < EC_TX_RING_SIZE; i++) {
+#ifdef EC_USERSPACE_MASTER_NEW
+        if (!(device->tx_skb[i] = dev_alloc_ecat_skb(i))) {
+#else
         if (!(device->tx_skb[i] = dev_alloc_skb(ETH_FRAME_LEN))) {
+#endif
             EC_MASTER_ERR(master, "Error allocating device socket buffer!\n");
             ret = -ENOMEM;
             goto out_tx_ring;
@@ -144,10 +177,10 @@ int ec_device_init(
 
 out_tx_ring:
     for (i = 0; i < EC_TX_RING_SIZE; i++) {
-        if (device->tx_skb[i]) {
+        if (device->tx_skb[i])
             dev_kfree_skb(device->tx_skb[i]);
-        }
     }
+
 #ifdef EC_DEBUG_IF
     ec_debug_clear(&device->dbg);
 out_return:
@@ -170,6 +203,7 @@ void ec_device_clear(
     }
     for (i = 0; i < EC_TX_RING_SIZE; i++)
         dev_kfree_skb(device->tx_skb[i]);
+
 #ifdef EC_DEBUG_IF
     ec_debug_clear(&device->dbg);
 #endif
diff --git a/master/device.h b/master/device.h
index 2a1b596a..5a9141e0 100644
--- a/master/device.h
+++ b/master/device.h
@@ -49,8 +49,12 @@
  * send the same data twice, if it is called twice.
  */
 #ifdef EC_MASTER_IN_USERSPACE
-#define EC_TX_RING_SIZE 16
+#ifdef EC_USERSPACE_MASTER_NEW
+#define EC_TX_RING_SIZE MAX_TX_BD_RING_SIZE
 #else
+#define EC_TX_RING_SIZE 16
+#endif
+#else  /* EC_MASTER_IN_USERSPACE */
 #define EC_TX_RING_SIZE 2
 #endif
 
@@ -74,6 +78,11 @@ typedef struct {
 
 #endif
 
+#ifdef EC_USERSPACE_MASTER_NEW
+#define MAX_TX_BD_RING_SIZE (16)
+#define MAX_RX_BD_RING_SIZE (16)
+#endif
+
 /*****************************************************************************/
 
 /**
diff --git a/master/ethercat_master.c b/master/ethercat_master.c
index c2d6fde9..b762918c 100644
--- a/master/ethercat_master.c
+++ b/master/ethercat_master.c
@@ -24,6 +24,25 @@
 
 volatile sig_atomic_t stop = 0;
 
+#ifdef EC_USERSPACE_MASTER_NEW
+int ecus_init(uint32_t master_count, const char *const *master_macs,
+              uint32_t backup_count, const char *const *backup_macs,
+              uint32_t debug_level, uint32_t cycle_ns, uint32_t core_mask);
+int ecus_done(void);
+int ecus_enable_ioctl_poll(void);
+
+#define MAX_MASTER_NUM (32)
+
+static int smaster_count = 1;
+static char *smaster_macs[MAX_MASTER_NUM] = {
+    "04:13:07:02:00:13",
+};
+
+static int sbackup_count = 0;
+static char *sbackup_macs[MAX_MASTER_NUM];
+static int sdebug_level = 0;
+#endif  /* EC_USERSPACE_MASTER_NEW */
+
 static void handler(int sig)
 {
     (void)sig;
@@ -44,9 +63,21 @@ int main(int argc, const char **argv)
     unsigned int debug_level = 0;
     unsigned int master_count = 0;
     unsigned int backup_count = 0;
+
+#ifdef EC_USERSPACE_MASTER_NEW
+    const char **masters = (const char **)smaster_macs;
+    const char **backups = (const char **)sbackup_macs;
+
+    ecus_enable_ioctl_poll();
+
+    master_count = smaster_count;
+    backup_count = sbackup_count;
+    debug_level = sdebug_level;
+#else
     const char **masters = alloca(argc * sizeof(const char *));
     const char **backups = alloca(argc * sizeof(const char *));
     int i;
+
     for (i = 1; i < argc; i++) {
         const char *s = argv[i];
         if (strcmp(s, "--help") == 0) {
@@ -77,9 +108,10 @@ int main(int argc, const char **argv)
             return EXIT_FAILURE;
         }
     }
+#endif
 
     /* Initialize. */
-    int r = ecrt_init(master_count, masters, backup_count, backups, debug_level);
+    int r = ecus_init(master_count, masters, backup_count, backups, debug_level, 0, 0x02);
     if (r) {
         fprintf(stderr, "*** Cannot initialize EtherCAT: %s.\n", strerror(-r));
         return EXIT_FAILURE;
@@ -90,7 +122,7 @@ int main(int argc, const char **argv)
     for (j = 0; j < master_count; j++) {
         if (!ecrt_open_master(j)) {
             fprintf(stderr, "*** Cannot open master %i.\n", j);
-            ecrt_done();
+            ecus_done();
             return EXIT_FAILURE;
         }
     }
@@ -101,6 +133,6 @@ int main(int argc, const char **argv)
     signal(SIGHUP,  handler);
     while (!stop)
         pause();
-    ecrt_done();
+    ecus_done();
     return EXIT_SUCCESS;
 }
diff --git a/master/globals.h b/master/globals.h
index 840a160c..8b2b0162 100644
--- a/master/globals.h
+++ b/master/globals.h
@@ -244,8 +244,12 @@ extern const char *ec_device_names[2]; // only main and backup!
  * \param fmt format string (like in printf())
  * \param args arguments (optional)
  */
+#ifdef EC_USERSPACE_MASTER_NEW
+#define EC_DBG(fmt, args...)
+#else
 #define EC_DBG(fmt, args...) \
     printk(KERN_DEBUG "EtherCAT DEBUG: " fmt, ##args)
+#endif
 
 /*****************************************************************************/
 
diff --git a/master/ioctl.c b/master/ioctl.c
index 0cd6b3f1..0235b4c6 100644
--- a/master/ioctl.c
+++ b/master/ioctl.c
@@ -67,7 +67,7 @@ static void ec_ioctl_strcpy(
         )
 {
     if (source) {
-        strncpy(target, source, EC_IOCTL_STRING_SIZE);
+        strncpy(target, source, EC_IOCTL_STRING_SIZE - 1);
         target[EC_IOCTL_STRING_SIZE - 1] = 0;
     } else {
         target[0] = 0;
@@ -812,6 +812,10 @@ static ATTRIBUTES int ec_ioctl_slave_sdo_upload(
         return -EFAULT;
     }
 
+#ifdef EC_MASTER_IN_USERSPACE
+    data.target = master->ioctl_mem;
+#endif
+
     if (!(target = kmalloc(data.target_size, GFP_KERNEL))) {
         EC_MASTER_ERR(master, "Failed to allocate %zu bytes"
                 " for SDO upload.\n", data.target_size);
@@ -858,6 +862,10 @@ static ATTRIBUTES int ec_ioctl_slave_sdo_download(
         return -EFAULT;
     }
 
+#ifdef EC_MASTER_IN_USERSPACE
+    data.data = master->ioctl_mem;
+#endif
+
     if (!(sdo_data = kmalloc(data.data_size, GFP_KERNEL))) {
         EC_MASTER_ERR(master, "Failed to allocate %zu bytes"
                 " for SDO download.\n", data.data_size);
@@ -906,6 +914,10 @@ static ATTRIBUTES int ec_ioctl_slave_sii_read(
         return -EFAULT;
     }
 
+#ifdef EC_MASTER_IN_USERSPACE
+    data.words = (uint16_t*)master->ioctl_mem;
+#endif
+
     if (down_interruptible(&master->master_sem))
         return -EINTR;
 
@@ -960,6 +972,10 @@ static ATTRIBUTES int ec_ioctl_slave_sii_write(
         return 0;
     }
 
+#ifdef EC_MASTER_IN_USERSPACE
+    data.words = (uint16_t*)master->ioctl_mem;
+#endif
+
     byte_size = sizeof(uint16_t) * data.nwords;
     if (!(words = kmalloc(byte_size, GFP_KERNEL))) {
         EC_MASTER_ERR(master, "Failed to allocate %u bytes"
@@ -1047,6 +1063,10 @@ static ATTRIBUTES int ec_ioctl_slave_reg_read(
         return 0;
     }
 
+#ifdef EC_MASTER_IN_USERSPACE
+    io.data = master->ioctl_mem;
+#endif
+
     // init register request
     ret = ec_reg_request_init(&request, io.size);
     if (ret) {
@@ -1126,6 +1146,10 @@ static ATTRIBUTES int ec_ioctl_slave_reg_write(
         return 0;
     }
 
+#ifdef EC_MASTER_IN_USERSPACE
+    io.data = master->ioctl_mem;
+#endif
+
     // init register request
     ret = ec_reg_request_init(&request, io.size);
     if (ret) {
@@ -3814,6 +3838,10 @@ static ATTRIBUTES int ec_ioctl_slave_foe_read(
         return -EFAULT;
     }
 
+#ifdef EC_MASTER_IN_USERSPACE
+    io.buffer = master->ioctl_mem;
+#endif
+
     ec_foe_request_init(&request, io.file_name);
     ret = ec_foe_request_alloc(&request, 10000); // FIXME
     if (ret) {
@@ -3910,6 +3938,10 @@ static ATTRIBUTES int ec_ioctl_slave_foe_write(
         return -EFAULT;
     }
 
+#ifdef EC_MASTER_IN_USERSPACE
+    io.buffer = master->ioctl_mem;
+#endif
+
     ec_foe_request_init(&request, io.file_name);
 
     ret = ec_foe_request_alloc(&request, io.buffer_size);
@@ -3997,6 +4029,10 @@ static ATTRIBUTES int ec_ioctl_slave_soe_read(
         return -EFAULT;
     }
 
+#ifdef EC_MASTER_IN_USERSPACE
+    ioctl.data = master->ioctl_mem;
+#endif
+
     data = kmalloc(ioctl.mem_size, GFP_KERNEL);
     if (!data) {
         EC_MASTER_ERR(master, "Failed to allocate %zu bytes of IDN data.\n",
@@ -4046,6 +4082,10 @@ static ATTRIBUTES int ec_ioctl_slave_soe_write(
         return -EFAULT;
     }
 
+#ifdef EC_MASTER_IN_USERSPACE
+    ioctl.data = master->ioctl_mem;
+#endif
+
     data = kmalloc(ioctl.data_size, GFP_KERNEL);
     if (!data) {
         EC_MASTER_ERR(master, "Failed to allocate %zu bytes of IDN data.\n",
diff --git a/master/ioctl.h b/master/ioctl.h
index 185f04cc..a42e4319 100644
--- a/master/ioctl.h
+++ b/master/ioctl.h
@@ -759,10 +759,9 @@ typedef struct {
 #define copy_from_user(DST, SRC, SIZE) (memcpy((DST), (SRC), (SIZE)), 0)
 #define copy_to_user(DST, SRC, SIZE) (memcpy((DST), (SRC), (SIZE)), 0)
 #define __copy_to_user copy_to_user
-#define MAX_MASTER_NUM (32)
 #define __user
 
-int eccdev_usecat_ioctl(int fd, unsigned int cmd, void *arg);
+int ec_master_ioctl_poll(void *priv_data);
 
 /* Emulated ioctl via TCP connection for userspace master */
 static inline int ioctl_usecat_open(int master_index, const char *host)
diff --git a/master/master.c b/master/master.c
index e07c4a66..c37a087f 100644
--- a/master/master.c
+++ b/master/master.c
@@ -105,6 +105,9 @@ void ec_master_clear_device_stats(ec_master_t *);
 void ec_master_update_device_stats(ec_master_t *);
 
 #ifdef EC_MASTER_IN_USERSPACE
+static int ec_master_start_ioctl_thread(ec_master_t *master);
+static int ec_master_stop_ioctl_thread(ec_master_t *master);
+
 void ec_master_nanosleep(const unsigned long nsecs)
 {
     struct timespec t = { 0, nsecs }, r;
@@ -402,6 +405,7 @@ void ec_master_clear(
     unsigned int dev_idx, i;
 
 #ifdef EC_MASTER_IN_USERSPACE
+    ec_master_stop_ioctl_thread(master);
     ec_cdev_usecat_stop(master);
 #else
 #ifdef EC_RTDM
@@ -1368,7 +1372,19 @@ void ec_master_update_device_stats(
 
 /*****************************************************************************/
 
-#ifndef EC_MASTER_IN_USERSPACE
+#ifdef EC_MASTER_IN_USERSPACE
+
+extern int ec_master_ioctl_poll(void *priv_data);
+static int sec_ioctl_poll_flag = 0;
+
+int ecus_enable_ioctl_poll(void)
+{
+    sec_ioctl_poll_flag = 1;
+    return 0;
+}
+
+#else
+
 #ifdef EC_USE_HRTIMER
 
 /*
@@ -1535,6 +1551,59 @@ void ec_master_exec_slave_fsms(
 
 /*****************************************************************************/
 
+#ifdef EC_MASTER_IN_USERSPACE
+static void* ec_master_ioctl_thread(void *priv_data)
+{
+    ec_master_t *master = (ec_master_t *)priv_data;
+
+    EC_MASTER_INFO(master, "Starting master ioctl thread.\n");
+
+    while (master->ioctl_thread_run) {
+        if (sec_ioctl_poll_flag)
+            ec_master_ioctl_poll(priv_data);
+
+        ec_master_nanosleep(master->send_interval * 30);
+    }
+
+    EC_MASTER_INFO(master, "Exiting master ioctl thread.\n");
+
+    return NULL;
+}
+
+static int ec_master_start_ioctl_thread(ec_master_t *master)
+{
+    int ret = 0;
+
+    if (!master->ioctl_thread) {
+        ret = pthread_create(&master->ioctl_thread_id, NULL, ec_master_ioctl_thread, master);
+        if (ret == 0) {
+            master->ioctl_thread_run = 1;
+            master->ioctl_thread = &master->ioctl_thread_id;
+	} else {
+            EC_MASTER_WARN(master, "Failed to start master IOCTL thread!\n");
+	}
+    }
+
+    return 0;
+}
+
+static int ec_master_stop_ioctl_thread(ec_master_t *master)
+{
+    int ret = 0;
+
+    if (master->ioctl_thread) {
+        master->ioctl_thread_run = 0;
+
+	ret = pthread_join(*master->ioctl_thread, NULL);
+        master->ioctl_thread = NULL;
+    }
+
+    return ret;
+}
+#endif
+
+/*****************************************************************************/
+
 /** Master kernel thread function for IDLE phase.
  */
 static int ec_master_idle_thread(void *priv_data)
@@ -1545,6 +1614,10 @@ static int ec_master_idle_thread(void *priv_data)
     size_t sent_bytes;
 #endif
 
+#ifdef EC_MASTER_IN_USERSPACE
+    ec_master_start_ioctl_thread(master);
+#endif
+
     // send interval in IDLE phase
     ec_master_set_send_interval(master, 1000000 / HZ);
 
@@ -1585,7 +1658,11 @@ static int ec_master_idle_thread(void *priv_data)
 
         if (ec_fsm_master_idle(&master->fsm)) {
 #ifdef EC_USE_HRTIMER
+#ifdef EC_USERSPACE_MASTER_NEW
+            ec_master_nanosleep(master->send_interval * 10);
+#else
             ec_master_nanosleep(master->send_interval * 1000);
+#endif
 #else
             set_current_state(TASK_INTERRUPTIBLE);
             schedule_timeout(1);
@@ -1604,6 +1681,55 @@ static int ec_master_idle_thread(void *priv_data)
     return 0;
 }
 
+#ifdef EC_USERSPACE_MASTER_NEW
+static uint64_t sop_cycle_us_sum;
+static uint32_t sop_cycle_us = 0;
+
+int ec_master_set_noop_mode(uint32_t cycle_ns)
+{
+    sop_cycle_us = cycle_ns / 1000;
+    return 0;
+}
+
+int ec_master_in_noop_mode(void)
+{
+    return (sop_cycle_us > 0);
+}
+
+uint64_t ec_master_cycle_us(void)
+{
+    return sop_cycle_us_sum;
+}
+
+int ecus_master_operation_loop(ec_master_t *master, int cycle)
+{
+    if (!ec_master_in_noop_mode())
+        return 0;
+
+    if (cycle)
+        sop_cycle_us_sum += sop_cycle_us;
+
+    if (master->active) {
+        ec_datagram_output_stats(&master->fsm_datagram);
+
+        if (master->injection_seq_rt == master->injection_seq_fsm) {
+            // output statistics
+            ec_master_output_stats(master);
+
+            if (ec_fsm_master_exec(&master->fsm)) {
+                // Inject datagrams (let the RT thread queue them, see
+                // ecrt_master_send())
+                master->injection_seq_fsm++;
+            }
+
+            ec_master_exec_slave_fsms(master);
+        }
+    }
+
+    return 0;
+}
+#endif
+
 /*****************************************************************************/
 
 /** Master kernel thread function for OPERATION phase.
@@ -1641,7 +1767,11 @@ static int ec_master_operation_thread(void *priv_data)
 
 #ifdef EC_USE_HRTIMER
         // the op thread should not work faster than the sending RT thread
+#ifdef EC_USERSPACE_MASTER_NEW
+        ec_master_nanosleep(master->send_interval * 50);
+#else
         ec_master_nanosleep(master->send_interval * 1000);
+#endif
 #else
         if (ec_fsm_master_idle(&master->fsm)) {
             set_current_state(TASK_INTERRUPTIBLE);
@@ -2361,6 +2491,16 @@ int ecrt_master_activate(ec_master_t *master)
         ec_master_eoe_start(master);
     }
 #endif
+
+#ifdef EC_USERSPACE_MASTER_NEW
+    ec_master_stop_ioctl_thread(master);
+
+    if (ec_master_in_noop_mode()) {
+        master->thread = NULL;
+        goto no_op_tag;
+    }
+#endif
+
     ret = ec_master_thread_start(master, ec_master_operation_thread,
                 "EtherCAT-OP");
     if (ret < 0) {
@@ -2368,6 +2508,9 @@ int ecrt_master_activate(ec_master_t *master)
         return ret;
     }
 
+#ifdef EC_USERSPACE_MASTER_NEW
+no_op_tag:
+#endif
     /* Allow scanning after a topology change. */
     master->allow_scan = 1;
 
@@ -2708,7 +2851,7 @@ int ecrt_master_get_slave(ec_master_t *master, uint16_t slave_position,
     slave_info->sync_count = slave->sii.sync_count;
     slave_info->sdo_count = ec_slave_sdo_count(slave);
     if (slave->sii.name) {
-        strncpy(slave_info->name, slave->sii.name, EC_MAX_STRING_LENGTH);
+        strncpy(slave_info->name, slave->sii.name, EC_MAX_STRING_LENGTH - 1);
     } else {
         slave_info->name[0] = 0;
     }
diff --git a/master/master.h b/master/master.h
index ad761067..411ea57b 100644
--- a/master/master.h
+++ b/master/master.h
@@ -108,6 +108,15 @@
  * \param fmt format string (like in printf())
  * \param args arguments (optional)
  */
+#ifdef EC_USERSPACE_MASTER_NEW
+#define EC_MASTER_DBG(master, level, fmt, args...) \
+    do { \
+        if (master->debug_level > level) { \
+            printk(KERN_DEBUG "EtherCAT DEBUG %u: " fmt, \
+                    master->index, ##args); \
+        } \
+    } while (0)
+#else
 #define EC_MASTER_DBG(master, level, fmt, args...) \
     do { \
         if (master->debug_level >= level) { \
@@ -115,7 +124,7 @@
                     master->index, ##args); \
         } \
     } while (0)
-
+#endif
 
 /** Size of the external datagram ring.
  *
@@ -308,6 +317,13 @@ struct ec_master {
 
     wait_queue_head_t request_queue; /**< Wait queue for external requests
                                        from user space. */
+#ifdef EC_MASTER_IN_USERSPACE
+    pthread_t		ioctl_thread_id;
+    pthread_t		*ioctl_thread; /**< Master IOCTL thread. */
+    uint8_t		*ioctl_mem;
+    uint8_t		ioctl_thread_run;
+    void *priv;
+#endif
 };
 
 /*****************************************************************************/
@@ -383,6 +399,11 @@ void ec_master_request_op(ec_master_t *);
 void ec_master_internal_send_cb(void *);
 void ec_master_internal_receive_cb(void *);
 
+#ifdef EC_USERSPACE_MASTER_NEW
+int ec_master_in_noop_mode(void);
+uint64_t ec_master_cycle_us(void);
+#endif
+
 extern const unsigned int rate_intervals[EC_RATE_COUNT]; // see master.c
 
 /*****************************************************************************/
diff --git a/master/module.c b/master/module.c
index ee39789a..43110542 100644
--- a/master/module.c
+++ b/master/module.c
@@ -699,10 +699,16 @@ ec_master_t *ecrt_open_master(
     return master;
 }
 
+#ifdef EC_USERSPACE_MASTER_NEW
+int ec_usm_net_init(uint32_t cycle_ns, uint32_t core_mask);
+int __init ec_usm_init_module(void);
+void __exit ec_usm_cleanup_module(void);
+#endif
+
 int __init ec_gen_init_module(void);
 void __exit ec_gen_cleanup_module(void);
 
-int ecrt_init(unsigned int master_count_, const char *const *master_macs,
+static int ecrt_init(unsigned int master_count_, const char *const *master_macs,
               unsigned int backup_count_, const char *const *backup_macs,
               unsigned int debug_level_)
 {
@@ -734,15 +740,59 @@ int ecrt_init(unsigned int master_count_, const char *const *master_macs,
     r = ec_init_module();
     if (r)
         return r;
+
+#ifdef EC_USERSPACE_MASTER_NEW
+    r = ec_usm_init_module();
+#endif
+
+#ifndef EC_USERSPACE_MASTER_NEW
     r = ec_gen_init_module();
+#endif
     if (r)
         ec_cleanup_module();
     return r;
 }
 
-void ecrt_done(void)
+static void ecrt_done(void)
 {
+#ifdef EC_USERSPACE_MASTER_NEW
+    ec_usm_cleanup_module();
+#endif
+
+#ifndef EC_USERSPACE_MASTER_NEW
     ec_gen_cleanup_module();
+#endif
     ec_cleanup_module();
 }
+
+int ecus_init(uint32_t master_count, const char *const *master_macs,
+              uint32_t backup_count, const char *const *backup_macs,
+              uint32_t debug_level, uint32_t cycle_ns, uint32_t core_mask)
+{
+    int ret = 0;
+
+#ifdef EC_USERSPACE_MASTER_NEW
+    ret = ec_usm_net_init(cycle_ns, core_mask);
+    if (ret) {
+        EC_ERR("Failed to init NXP userspace driver! ret:%d\n", ret);
+        goto err_tag;
+    }
 #endif
+
+    ret = ecrt_init(master_count, master_macs, backup_count, backup_macs, debug_level);
+    if (ret) {
+        EC_ERR("Failed to init userspace driver! Error:%s.\n", strerror(-ret));
+        goto err_tag;
+    }
+
+err_tag:
+    return ret;
+}
+
+int ecus_done(void)
+{
+    ecrt_done();
+    return 0;
+}
+
+#endif  /* EC_MASTER_IN_USERSPACE */
diff --git a/master/slave.h b/master/slave.h
index b71d57e2..5ffb1286 100644
--- a/master/slave.h
+++ b/master/slave.h
@@ -103,6 +103,15 @@
  * \param fmt format string (like in printf())
  * \param args arguments (optional)
  */
+#ifdef EC_USERSPACE_MASTER_NEW
+#define EC_SLAVE_DBG(slave, level, fmt, args...) \
+    do { \
+        if (slave->master->debug_level > level) { \
+            printk(KERN_DEBUG "EtherCAT DEBUG %u-%u: " fmt, \
+                    slave->master->index, slave->ring_position, ##args); \
+        } \
+    } while (0)
+#else
 #define EC_SLAVE_DBG(slave, level, fmt, args...) \
     do { \
         if (slave->master->debug_level >= level) { \
@@ -110,6 +119,7 @@
                     slave->master->index, slave->ring_position, ##args); \
         } \
     } while (0)
+#endif
 
 /*****************************************************************************/
 
diff --git a/master/slave_config.c b/master/slave_config.c
index 38347872..192aa6ca 100644
--- a/master/slave_config.c
+++ b/master/slave_config.c
@@ -198,6 +198,30 @@ int ec_slave_config_prepare_fmmu(
     return fmmu->logical_start_address;
 }
 
+#ifdef EC_MASTER_IN_USERSPACE
+#define PREOP (0x02)
+ec_master_t *ecrt_open_master(unsigned int master_index);
+
+int ecus_slave_is_ready(uint32_t master_index, uint16_t alias, uint16_t position)
+{
+    ec_master_t *master = NULL;
+    ec_slave_t *slave = NULL;
+
+    master = ecrt_open_master(master_index);
+    if (!master)
+        return 0;
+
+    slave = ec_master_find_slave(master, alias, position);
+    if (!slave)
+        return 0;
+
+    if (slave->current_state < PREOP)
+        return 0;
+
+    return 1;
+}
+#endif
+
 /*****************************************************************************/
 
 /** Attaches the configuration to the addressed slave object.
diff --git a/tool/CommandAlias.cpp b/tool/CommandAlias.cpp
index 87f6435d..9aebfa54 100644
--- a/tool/CommandAlias.cpp
+++ b/tool/CommandAlias.cpp
@@ -143,12 +143,12 @@ void CommandAlias::writeSlaveAlias(
     data.slave_position = slave.position;
     data.offset = 0;
     data.nwords = 8;
-    data.words = new uint16_t[data.nwords];
+    data.words = ioctl_new_buf(uint16_t, data.nwords);
 
     try {
         m.readSii(&data);
     } catch (MasterDeviceException &e) {
-        delete [] data.words;
+        ioctl_del_buf(data.words);
         err << "Failed to read SII: " << e.what();
         throwCommandException(err);
     }
@@ -166,12 +166,12 @@ void CommandAlias::writeSlaveAlias(
     try {
         m.writeSii(&data);
     } catch (MasterDeviceException &e) {
-        delete [] data.words;
+        ioctl_del_buf(data.words);
         err << "Failed to read SII: " << e.what();
         throwCommandException(err);
     }
 
-    delete [] data.words;
+    ioctl_del_buf(data.words);
 }
 
 /*****************************************************************************/
diff --git a/tool/CommandData.cpp b/tool/CommandData.cpp
index 89a31eeb..8a6d55ac 100644
--- a/tool/CommandData.cpp
+++ b/tool/CommandData.cpp
@@ -109,12 +109,12 @@ void CommandData::outputDomainData(
     if (!domain.data_size)
         return;
 
-    processData = new unsigned char[domain.data_size];
+    processData = ioctl_new_buf(uint8_t, domain.data_size);
 
     try {
         m.getData(&data, domain.index, domain.data_size, processData);
     } catch (MasterDeviceException &e) {
-        delete [] processData;
+        ioctl_del_buf(processData);
         throw e;
     }
 
@@ -122,7 +122,7 @@ void CommandData::outputDomainData(
         cout << processData[i];
     cout.flush();
 
-    delete [] processData;
+    ioctl_del_buf(processData);
 }
 
 /****************************************************************************/
diff --git a/tool/CommandDomains.cpp b/tool/CommandDomains.cpp
index 13fc6cb3..fdc9d0a1 100644
--- a/tool/CommandDomains.cpp
+++ b/tool/CommandDomains.cpp
@@ -170,12 +170,12 @@ void CommandDomains::showDomain(
     if (!domain.data_size || getVerbosity() != Verbose)
         return;
 
-    processData = new unsigned char[domain.data_size];
+    processData = ioctl_new_buf(uint8_t, domain.data_size);
 
     try {
         m.getData(&data, domain.index, domain.data_size, processData);
     } catch (MasterDeviceException &e) {
-        delete [] processData;
+        ioctl_del_buf(processData);
         throw e;
     }
 
@@ -196,7 +196,7 @@ void CommandDomains::showDomain(
         dataOffset = fmmu.logical_address - domain.logical_base_address;
         if (dataOffset + fmmu.data_size > domain.data_size) {
             stringstream err;
-            delete [] processData;
+            ioctl_del_buf(processData);
             err << "Fmmu information corrupted!";
             throwCommandException(err);
         }
@@ -211,7 +211,7 @@ void CommandDomains::showDomain(
         cout << endl;
     }
 
-    delete [] processData;
+    ioctl_del_buf(processData);
 }
 
 /*****************************************************************************/
diff --git a/tool/CommandDownload.cpp b/tool/CommandDownload.cpp
index 0ee59d32..b010c0a2 100644
--- a/tool/CommandDownload.cpp
+++ b/tool/CommandDownload.cpp
@@ -173,16 +173,16 @@ void CommandDownload::execute(const StringVector &args)
             throwCommandException(err);
         }
         data.data_size = contents.size();
-        data.data = new uint8_t[data.data_size + 1];
+        data.data = ioctl_new_buf(uint8_t, data.data_size + 1);
 
         try {
             data.data_size = interpretAsType(
                     dataType, contents, data.data, data.data_size);
         } catch (SizeException &e) {
-            delete [] data.data;
+            ioctl_del_buf(data.data);
             throwCommandException(e.what());
         } catch (ios::failure &e) {
-            delete [] data.data;
+            ioctl_del_buf(data.data);
             err << "Invalid value argument '" << args[2]
                 << "' for type '" << dataType->name << "'!";
             throwInvalidUsageException(err);
@@ -195,16 +195,16 @@ void CommandDownload::execute(const StringVector &args)
             data.data_size = DefaultBufferSize;
         }
 
-        data.data = new uint8_t[data.data_size + 1];
+        data.data = ioctl_new_buf(uint8_t, data.data_size + 1);
 
         try {
             data.data_size = interpretAsType(
                     dataType, args[valueIndex], data.data, data.data_size);
         } catch (SizeException &e) {
-            delete [] data.data;
+            ioctl_del_buf(data.data);
             throwCommandException(e.what());
         } catch (ios::failure &e) {
-            delete [] data.data;
+            ioctl_del_buf(data.data);
             err << "Invalid value argument '" << args[2]
                 << "' for type '" << dataType->name << "'!";
             throwInvalidUsageException(err);
@@ -215,10 +215,10 @@ void CommandDownload::execute(const StringVector &args)
         data.data_size = interpretAsType(
                 dataType, args[valueIndex], data.data, data.data_size);
     } catch (SizeException &e) {
-        delete [] data.data;
+        ioctl_del_buf(data.data);
         throwCommandException(e.what());
     } catch (ios::failure &e) {
-        delete [] data.data;
+        ioctl_del_buf(data.data);
         err << "Invalid value argument '" << args[2]
             << "' for type '" << dataType->name << "'!";
         throwInvalidUsageException(err);
@@ -227,17 +227,17 @@ void CommandDownload::execute(const StringVector &args)
     try {
         m.sdoDownload(&data);
     } catch (MasterDeviceSdoAbortException &e) {
-        delete [] data.data;
+        ioctl_del_buf(data.data);
         err << "SDO transfer aborted with code 0x"
             << setfill('0') << hex << setw(8) << e.abortCode
             << ": " << abortText(e.abortCode);
         throwCommandException(err);
     } catch(MasterDeviceException &e) {
-        delete [] data.data;
+        ioctl_del_buf(data.data);
         throw e;
     }
 
-    delete [] data.data;
+    ioctl_del_buf(data.data);
 }
 
 /*****************************************************************************/
diff --git a/tool/CommandFoeRead.cpp b/tool/CommandFoeRead.cpp
index 7221f40b..1a643e03 100644
--- a/tool/CommandFoeRead.cpp
+++ b/tool/CommandFoeRead.cpp
@@ -103,14 +103,14 @@ void CommandFoeRead::execute(const StringVector &args)
      */
     data.offset = 0;
     data.buffer_size = 0x8800;
-    data.buffer = new uint8_t[data.buffer_size];
+    data.buffer = ioctl_new_buf(uint8_t, data.buffer_size);
 
     strncpy(data.file_name, args[0].c_str(), sizeof(data.file_name));
 
     try {
         m.readFoe(&data);
     } catch (MasterDeviceException &e) {
-        delete [] data.buffer;
+        ioctl_del_buf(data.buffer);
         if (data.result) {
             if (data.result == FOE_OPCODE_ERROR) {
                 err << "FoE read aborted with error code 0x"
@@ -132,7 +132,7 @@ void CommandFoeRead::execute(const StringVector &args)
         cout << *(uint8_t *) w ;
     }
 
-    delete [] data.buffer;
+    ioctl_del_buf(data.buffer);
 }
 
 /*****************************************************************************/
diff --git a/tool/CommandFoeWrite.cpp b/tool/CommandFoeWrite.cpp
index abd6a3fb..a57e1fbe 100644
--- a/tool/CommandFoeWrite.cpp
+++ b/tool/CommandFoeWrite.cpp
@@ -126,14 +126,14 @@ void CommandFoeWrite::execute(const StringVector &args)
         m.open(MasterDevice::ReadWrite);
     } catch (MasterDeviceException &e) {
         if (data.buffer_size)
-            delete [] data.buffer;
+            ioctl_del_buf(data.buffer);
         throw e;
     }
 
     slaves = selectedSlaves(m);
     if (slaves.size() != 1) {
         if (data.buffer_size)
-            delete [] data.buffer;
+            ioctl_del_buf(data.buffer);
         throwSingleSlaveRequired(slaves.size());
     }
     data.slave_position = slaves.front().position;
@@ -146,7 +146,7 @@ void CommandFoeWrite::execute(const StringVector &args)
         m.writeFoe(&data);
     } catch (MasterDeviceException &e) {
         if (data.buffer_size)
-            delete [] data.buffer;
+            ioctl_del_buf(data.buffer);
         if (data.result) {
             if (data.result == FOE_OPCODE_ERROR) {
                 err << "FoE write aborted with error code 0x"
@@ -167,7 +167,7 @@ void CommandFoeWrite::execute(const StringVector &args)
     }
 
     if (data.buffer_size)
-        delete [] data.buffer;
+        ioctl_del_buf(data.buffer);
 }
 
 /*****************************************************************************/
@@ -191,7 +191,7 @@ void CommandFoeWrite::loadFoeData(
 
     if (data->buffer_size) {
         // allocate buffer and read file into buffer
-        data->buffer = new uint8_t[data->buffer_size];
+        data->buffer = ioctl_new_buf(uint8_t, data->buffer_size);
         contents.copy((char *) data->buffer, contents.size());
     }
 }
diff --git a/tool/CommandRegRead.cpp b/tool/CommandRegRead.cpp
index d1d83140..27a2dbf7 100644
--- a/tool/CommandRegRead.cpp
+++ b/tool/CommandRegRead.cpp
@@ -150,23 +150,23 @@ void CommandRegRead::execute(const StringVector &args)
     }
     io.slave_position = slaves.front().position;
 
-    io.data = new uint8_t[io.size];
+    io.data = ioctl_new_buf(uint8_t, io.size);
 
     try {
         m.readReg(&io);
     } catch (MasterDeviceException &e) {
-        delete [] io.data;
+        ioctl_del_buf(io.data);
         throw e;
     }
 
     try {
         outputData(cout, dataType, io.data, io.size);
     } catch (SizeException &e) {
-        delete [] io.data;
+        ioctl_del_buf(io.data);
         throwCommandException(e.what());
     }
 
-    delete [] io.data;
+    ioctl_del_buf(io.data);
 }
 
 /*****************************************************************************/
diff --git a/tool/CommandRegWrite.cpp b/tool/CommandRegWrite.cpp
index 9a8a57e9..1e4f72a7 100644
--- a/tool/CommandRegWrite.cpp
+++ b/tool/CommandRegWrite.cpp
@@ -128,16 +128,16 @@ void CommandRegWrite::execute(const StringVector &args)
             io.size = 1024; // FIXME
         }
 
-        io.data = new uint8_t[io.size];
+        io.data = ioctl_new_buf(uint8_t, io.size);
 
         try {
             io.size = interpretAsType(
                     dataType, args[1], io.data, io.size);
         } catch (SizeException &e) {
-            delete [] io.data;
+            ioctl_del_buf(io.data);
             throwCommandException(e.what());
         } catch (ios::failure &e) {
-            delete [] io.data;
+            ioctl_del_buf(io.data);
             err << "Invalid value argument '" << args[1]
                 << "' for type '" << dataType->name << "'!";
             throwInvalidUsageException(err);
@@ -146,7 +146,7 @@ void CommandRegWrite::execute(const StringVector &args)
 
     if ((uint32_t) io.address + io.size > 0xffff) {
         err << "Address and size exceeding 64k!";
-        delete [] io.data;
+        ioctl_del_buf(io.data);
         throwInvalidUsageException(err);
     }
 
@@ -154,13 +154,13 @@ void CommandRegWrite::execute(const StringVector &args)
     try {
         m.open(MasterDevice::ReadWrite);
     } catch (MasterDeviceException &e) {
-        delete [] io.data;
+        ioctl_del_buf(io.data);
         throw e;
     }
 
     slaves = selectedSlaves(m);
     if (slaves.size() != 1) {
-        delete [] io.data;
+        ioctl_del_buf(io.data);
         throwSingleSlaveRequired(slaves.size());
     }
     io.slave_position = slaves.front().position;
@@ -169,7 +169,7 @@ void CommandRegWrite::execute(const StringVector &args)
     try {
         m.writeReg(&io);
     } catch (MasterDeviceException &e) {
-        delete [] io.data;
+        ioctl_del_buf(io.data);
         throw e;
     }
 
@@ -177,7 +177,7 @@ void CommandRegWrite::execute(const StringVector &args)
         cerr << "Register writing finished." << endl;
     }
 
-    delete [] io.data;
+    ioctl_del_buf(io.data);
 }
 
 /*****************************************************************************/
@@ -204,7 +204,7 @@ void CommandRegWrite::loadRegData(
     io->size = contents.size();
 
     // allocate buffer and read file into buffer
-    io->data = new uint8_t[io->size];
+    io->data = ioctl_new_buf(uint8_t, io->size);
     contents.copy((char *) io->data, contents.size());
 }
 
diff --git a/tool/CommandSiiRead.cpp b/tool/CommandSiiRead.cpp
index 1c606e38..8aa7e26a 100644
--- a/tool/CommandSiiRead.cpp
+++ b/tool/CommandSiiRead.cpp
@@ -104,12 +104,12 @@ void CommandSiiRead::execute(const StringVector &args)
 
     data.offset = 0;
     data.nwords = slave->sii_nwords;
-    data.words = new uint16_t[data.nwords];
+    data.words = ioctl_new_buf(uint16_t, data.nwords);
 
     try {
         m.readSii(&data);
     } catch (MasterDeviceException &e) {
-        delete [] data.words;
+        ioctl_del_buf(data.words);
         throw e;
     }
 
@@ -175,7 +175,7 @@ void CommandSiiRead::execute(const StringVector &args)
         }
     }
 
-    delete [] data.words;
+    ioctl_del_buf(data.words);
 }
 
 /****************************************************************************/
diff --git a/tool/CommandSiiWrite.cpp b/tool/CommandSiiWrite.cpp
index ad02b4f1..e449dc13 100644
--- a/tool/CommandSiiWrite.cpp
+++ b/tool/CommandSiiWrite.cpp
@@ -105,7 +105,7 @@ void CommandSiiWrite::execute(const StringVector &args)
         try {
             checkSiiData(&data);
         } catch (CommandException &e) {
-            delete [] data.words;
+            ioctl_del_buf(data.words);
             throw e;
         }
     }
@@ -114,13 +114,13 @@ void CommandSiiWrite::execute(const StringVector &args)
     try {
         m.open(MasterDevice::ReadWrite);
     } catch (MasterDeviceException &e) {
-        delete [] data.words;
+        ioctl_del_buf(data.words);
         throw e;
     }
 
     slaves = selectedSlaves(m);
     if (slaves.size() != 1) {
-        delete [] data.words;
+        ioctl_del_buf(data.words);
         throwSingleSlaveRequired(slaves.size());
     }
     data.slave_position = slaves.front().position;
@@ -130,7 +130,7 @@ void CommandSiiWrite::execute(const StringVector &args)
     try {
         m.writeSii(&data);
     } catch (MasterDeviceException &e) {
-        delete [] data.words;
+        ioctl_del_buf(data.words);
         throw e;
     }
 
@@ -138,7 +138,7 @@ void CommandSiiWrite::execute(const StringVector &args)
         cerr << "SII writing finished." << endl;
     }
 
-    delete [] data.words;
+    ioctl_del_buf(data.words);
 }
 
 /*****************************************************************************/
@@ -166,7 +166,7 @@ void CommandSiiWrite::loadSiiData(
     data->nwords = contents.size() / 2;
 
     // allocate buffer and read file into buffer
-    data->words = new uint16_t[data->nwords];
+    data->words = ioctl_new_buf(uint16_t, data->nwords);
     contents.copy((char *) data->words, contents.size());
 }
 
diff --git a/tool/CommandSoeRead.cpp b/tool/CommandSoeRead.cpp
index 2ad4c0f8..eb2c0379 100644
--- a/tool/CommandSoeRead.cpp
+++ b/tool/CommandSoeRead.cpp
@@ -148,16 +148,16 @@ void CommandSoeRead::execute(const StringVector &args)
         ioctl.mem_size = 1024;
     }
 
-    ioctl.data = new uint8_t[ioctl.mem_size + 1];
+    ioctl.data = ioctl_new_buf(uint8_t, ioctl.mem_size + 1);
 
     try {
         m.readSoe(&ioctl);
     } catch (MasterDeviceSoeException &e) {
-        delete [] ioctl.data;
+        ioctl_del_buf(ioctl.data);
         err << "SoE read command failed with code " << errorMsg(e.errorCode);
         throwCommandException(err);
     } catch (MasterDeviceException &e) {
-        delete [] ioctl.data;
+        ioctl_del_buf(ioctl.data);
         throw e;
     }
 
@@ -166,11 +166,11 @@ void CommandSoeRead::execute(const StringVector &args)
     try {
         outputData(cout, dataType, ioctl.data, ioctl.data_size);
     } catch (SizeException &e) {
-        delete [] ioctl.data;
+        ioctl_del_buf(ioctl.data);
         throwCommandException(e.what());
     }
 
-    delete [] ioctl.data;
+    ioctl_del_buf(ioctl.data);
 }
 
 /*****************************************************************************/
diff --git a/tool/CommandSoeWrite.cpp b/tool/CommandSoeWrite.cpp
index 382ba8d6..3ec75ab6 100644
--- a/tool/CommandSoeWrite.cpp
+++ b/tool/CommandSoeWrite.cpp
@@ -158,16 +158,16 @@ void CommandSoeWrite::execute(const StringVector &args)
         }
     }
 
-    ioctl.data = new uint8_t[memSize];
+    ioctl.data = ioctl_new_buf(uint8_t, memSize);
 
     try {
         ioctl.data_size = interpretAsType(
                 dataType, args[valueArgIndex], ioctl.data, memSize);
     } catch (SizeException &e) {
-        delete [] ioctl.data;
+        ioctl_del_buf(ioctl.data);
         throwCommandException(e.what());
     } catch (ios::failure &e) {
-        delete [] ioctl.data;
+        ioctl_del_buf(ioctl.data);
         err << "Invalid value argument '" << args[valueArgIndex]
             << "' for type '" << dataType->name << "'!";
         throwInvalidUsageException(err);
@@ -176,15 +176,15 @@ void CommandSoeWrite::execute(const StringVector &args)
     try {
         m.writeSoe(&ioctl);
     } catch (MasterDeviceSoeException &e) {
-        delete [] ioctl.data;
+        ioctl_del_buf(ioctl.data);
         err << "SoE write command failed with code " << errorMsg(e.errorCode);
         throwCommandException(err);
     } catch (MasterDeviceException &e) {
-        delete [] ioctl.data;
+        ioctl_del_buf(ioctl.data);
         throw e;
     }
 
-    delete [] ioctl.data;
+    ioctl_del_buf(ioctl.data);
 }
 
 /*****************************************************************************/
diff --git a/tool/CommandUpload.cpp b/tool/CommandUpload.cpp
index 439eeab3..b5f639fa 100644
--- a/tool/CommandUpload.cpp
+++ b/tool/CommandUpload.cpp
@@ -151,18 +151,18 @@ void CommandUpload::execute(const StringVector &args)
         data.target_size = DefaultBufferSize;
     }
 
-    data.target = new uint8_t[data.target_size + 1];
+    data.target = ioctl_new_buf(uint8_t, data.target_size + 1);
 
     try {
         m.sdoUpload(&data);
     } catch (MasterDeviceSdoAbortException &e) {
-        delete [] data.target;
+        ioctl_del_buf(data.target);
         err << "SDO transfer aborted with code 0x"
             << setfill('0') << hex << setw(8) << e.abortCode
             << ": " << abortText(e.abortCode);
         throwCommandException(err);
     } catch (MasterDeviceException &e) {
-        delete [] data.target;
+        ioctl_del_buf(data.target);
         throw e;
     }
 
@@ -171,11 +171,11 @@ void CommandUpload::execute(const StringVector &args)
     try {
         outputData(cout, dataType, data.target, data.data_size);
     } catch (SizeException &e) {
-        delete [] data.target;
+        ioctl_del_buf(data.target);
         throwCommandException(e.what());
     }
 
-    delete [] data.target;
+    ioctl_del_buf(data.target);
 }
 
 /*****************************************************************************/
diff --git a/tool/Makefile.am b/tool/Makefile.am
index 9d551c7d..f865be94 100644
--- a/tool/Makefile.am
+++ b/tool/Makefile.am
@@ -33,9 +33,9 @@
 
 EXTRA_DIST =
 
-bin_PROGRAMS = ethercat
+bin_PROGRAMS = ethercat_userspace
 
-ethercat_SOURCES = \
+ethercat_userspace_SOURCES = \
 	soe_errors.c \
 	Command.cpp \
 	CommandAlias.cpp \
@@ -73,7 +73,7 @@ ethercat_SOURCES = \
 	sii_crc.cpp
 
 if ENABLE_EOE
-ethercat_SOURCES += CommandEoe.cpp
+ethercat_userspace_SOURCES += CommandEoe.cpp
 else
 EXTRA_DIST += CommandEoe.cpp
 endif
@@ -125,9 +125,10 @@ REV = `if test -s $(top_srcdir)/revision; then \
 		hg id -i $(top_srcdir) 2>/dev/null || echo "unknown"; \
 	fi`
 
-ethercat_CXXFLAGS = \
+ethercat_userspace_CXXFLAGS = \
 	-I$(top_srcdir)/include \
 	-I$(top_srcdir)/master \
+	-DEC_MASTER_IN_USERSPACE \
 	-Wall -DREV=$(REV) \
 	-fno-strict-aliasing
 
diff --git a/tool/MasterDevice.cpp b/tool/MasterDevice.cpp
index ca023246..5c487fb1 100644
--- a/tool/MasterDevice.cpp
+++ b/tool/MasterDevice.cpp
@@ -40,6 +40,122 @@ using namespace std;
 
 #include "MasterDevice.h"
 
+#ifdef EC_MASTER_IN_USERSPACE
+#include <sys/ipc.h>
+#include <sys/shm.h>
+
+#define IOCTL_MEM_SIZE (1024 * 3)
+
+extern "C" {
+
+static void *smaster_shmem[MAX_MASTER_NUM];
+
+static uint8_t* alloc_share_memory(int index, int *pshmid)
+{
+    uint8_t *pmem = NULL;
+    int shmid = 0;
+    key_t key = 0;
+
+    key = ftok("/tmp/", 0x88A4 + index);
+    if (key == -1) {
+        printf("%s(): ftok failed! key:%d\n", __func__, key);
+        return NULL;
+    }
+
+    shmid = shmget(key, 4096, 0666);
+    if (shmid < 0) {
+        printf("%s(): shmget failed! shmid:%d\n", __func__, shmid);
+        return NULL;
+    }
+
+    pmem = (uint8_t*)shmat(shmid, NULL, 0);
+    if (!pmem) {
+        printf("%s(): shmat failed! shmid:%d\n", __func__, shmid);
+        return NULL;
+    }
+
+    if (pshmid)
+        *pshmid = shmid;
+
+    return pmem;
+}
+
+uint8_t *ecat_get_ioctl_mem(int size)
+{
+    uint8_t *pmem = NULL;
+    int fd = 0;  /* using fd 0 */
+
+    pmem = (uint8_t*)smaster_shmem[fd];
+    if (!pmem) {
+        printf("%s(): smaster_shmem-%d is NULL!\n", __func__, fd);
+        return NULL;
+    }
+
+    if (size > IOCTL_MEM_SIZE) {
+        printf("%s(): size %d is out of range %d!\n", __func__, size, IOCTL_MEM_SIZE);
+        return NULL;
+    }
+
+    return pmem + (4096 - IOCTL_MEM_SIZE);
+}
+
+int ecat_ioctl_len(int fd, unsigned int cmd, void *arg, int len, int flag)
+{
+    volatile struct ecat_shm_info *pshm = NULL;
+    uint8_t *pmem = NULL;
+    uint8_t *parg = NULL;
+    int cnt = 0;
+
+    if (fd >= MAX_MASTER_NUM) {
+        printf("%s(): invalid fd number! fd:%d\n", __func__, fd);
+        return -1;
+    }
+
+    pmem = (uint8_t*)smaster_shmem[fd];
+    if (!pmem) {
+        printf("%s(): smaster_shmem-%d is NULL!\n", __func__, fd);
+        return -2;
+    }
+
+    pshm = (volatile struct ecat_shm_info *)pmem;
+    parg = (uint8_t*)(pmem + sizeof(*pshm));
+
+    pshm->index = fd;
+    pshm->cmd = cmd;
+
+    if (flag == 0) {
+        pshm->len = 0;
+        *(uint64_t *)parg = (uint64_t)arg;
+    } else if (len > 0) {
+        pshm->len = len;
+        memcpy(parg, arg, len);
+    }
+
+    pshm->flag = 1;
+    while (cnt++ < 3000) {  /* wait for max 3s */
+        if (pshm->flag == 2)
+            break;
+
+        usleep(1000);
+    }
+    pshm->flag = 0;
+
+    if (flag && (len > 0))
+        memcpy(arg, parg, len);
+
+    return 0;
+}
+
+}  /* extern "C" */
+
+#undef ioctl
+#define ioctl(f, c, a) ecat_ioctl_len(f, c, a, sizeof(*a), 1)
+#define ioctl_l(f, c, a) ecat_ioctl_len(f, c, (void*)(uint64_t)(a), sizeof(a), 0)
+
+#else
+#define ioctl_l ioctl
+#endif  /* EC_MASTER_IN_USERSPACE */
+
 /****************************************************************************/
 
 MasterDevice::MasterDevice(unsigned int index):
@@ -67,14 +183,26 @@ void MasterDevice::setIndex(unsigned int i)
 
 void MasterDevice::open(Permissions perm)
 {
+    ec_ioctl_module_t module_data;
     stringstream deviceName;
 
     if (fd == -1) { // not already open
-        ec_ioctl_module_t module_data;
-        deviceName << "/dev/EtherCAT" << index;
+#ifdef EC_MASTER_IN_USERSPACE
+        int shmid = 0;
+
+        if (index >= MAX_MASTER_NUM) {
+            stringstream err;
+            err << "invalid master index " << strerror(errno);
+            throw MasterDeviceException(err);
+        }
 
-        if ((fd = ::open(deviceName.str().c_str(),
-                        perm == ReadWrite ? O_RDWR : O_RDONLY)) == -1) {
+        fd = index;
+        smaster_shmem[fd] = alloc_share_memory(fd, &shmid);
+#else
+        deviceName << "/dev/EtherCAT" << index;
+        fd = ::open(deviceName.str().c_str(), perm == ReadWrite ? O_RDWR : O_RDONLY);
+#endif
+        if (fd == -1) {
             stringstream err;
             err << "Failed to open master device " << deviceName.str() << ": "
                 << strerror(errno);
@@ -97,10 +225,17 @@ void MasterDevice::open(Permissions perm)
 
 void MasterDevice::close()
 {
+#ifdef EC_MASTER_IN_USERSPACE
+    if (smaster_shmem[fd]) {
+        shmdt(smaster_shmem[fd]);
+        smaster_shmem[fd] = NULL;
+    }
+#else
     if (fd != -1) {
         ::close(fd);
         fd = -1;
     }
+#endif
 }
 
 /****************************************************************************/
@@ -464,7 +599,7 @@ void MasterDevice::writeFoe(
 
 void MasterDevice::setDebug(unsigned int debugLevel)
 {
-    if (ioctl(fd, EC_IOCTL_MASTER_DEBUG, debugLevel) < 0) {
+    if (ioctl_l(fd, EC_IOCTL_MASTER_DEBUG, debugLevel) < 0) {
         stringstream err;
         err << "Failed to set debug level: " << strerror(errno);
         throw MasterDeviceException(err);
@@ -475,7 +610,7 @@ void MasterDevice::setDebug(unsigned int debugLevel)
 
 void MasterDevice::rescan()
 {
-    if (ioctl(fd, EC_IOCTL_MASTER_RESCAN, 0) < 0) {
+    if (ioctl_l(fd, EC_IOCTL_MASTER_RESCAN, 0) < 0) {
         stringstream err;
         err << "Failed to command rescan: " << strerror(errno);
         throw MasterDeviceException(err);
diff --git a/tool/MasterDevice.h b/tool/MasterDevice.h
index 7398f978..a5d7f36a 100644
--- a/tool/MasterDevice.h
+++ b/tool/MasterDevice.h
@@ -38,6 +38,28 @@ using namespace std;
 #include "ioctl.h"
 
 /****************************************************************************/
+#ifdef EC_MASTER_IN_USERSPACE
+extern "C" {
+
+#define MAX_MASTER_NUM (32)
+
+uint8_t *ecat_get_ioctl_mem(int size);
+int ecat_ioctl_len(int fd, unsigned int cmd, void *arg, int len, int flag);
+
+struct ecat_shm_info {
+    uint32_t flag;
+    uint32_t index;
+    uint32_t cmd;
+    uint32_t len;
+} __attribute__((packed));
+
+#define ioctl_new_buf(t, s) (t*)ecat_get_ioctl_mem(s)
+#define ioctl_del_buf(p)
+}  /* extern "C" */
+#else
+#define ioctl_new_buf(t, s) new t[s]
+#define ioctl_del_buf(p) delete [] p
+#endif
 
 class MasterDeviceException:
     public runtime_error
-- 
2.34.1

