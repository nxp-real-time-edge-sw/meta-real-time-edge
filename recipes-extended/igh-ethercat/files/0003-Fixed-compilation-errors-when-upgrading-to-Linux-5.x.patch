From c612ae2e8aa01e3d643519067c4052ca9417ffd2 Mon Sep 17 00:00:00 2001
From: "hongbo.wang" <hongbo.wang@nxp.com>
Date: Mon, 13 Dec 2021 14:06:40 +0800
Subject: [PATCH 3/7] Fixed compilation errors when upgrading to Linux-5.x

Signed-off-by: hongbo.wang <hongbo.wang@nxp.com>
Signed-off-by: Wenbin Song <wenbin.song@nxp.com>
Signed-off-by: Tao Yang <Tao.Yang1@nxp.com>
Signed-off-by: qizhang <jony.zhang@nxp.com>
Upstream-Status: Pending
---
 configure.ac                   |  25 +++++++
 devices/Kbuild.in              |   4 ++
 devices/Makefile.am            |   6 +-
 devices/dpaa1/Kbuild.in        |  53 ++++++++++++++
 devices/dpaa1/Makefile.am      |  39 +++++++++++
 devices/dpaa1/dpaa1-ethercat.c | 123 +++++++++++++++++++++++++++++++++
 devices/dpaa1/dpaa1-ethercat.h |  33 +++++++++
 devices/enetc/enetc_ethtool.c  | 106 +++++++---------------------
 devices/enetc/enetc_pf.c       |  43 +++++++-----
 devices/enetc/enetc_pf.h       |  48 ++++++++++++-
 devices/enetc/enetc_qos.c      |   6 +-
 devices/fec/fec_main.c         |  66 +++++++++++++-----
 master/ethernet.c              |  12 +++-
 script/ethercat.conf           |   4 +-
 script/ethercatctl.in          |   2 +
 15 files changed, 440 insertions(+), 130 deletions(-)
 create mode 100644 devices/dpaa1/Kbuild.in
 create mode 100644 devices/dpaa1/Makefile.am
 create mode 100644 devices/dpaa1/dpaa1-ethercat.c
 create mode 100644 devices/dpaa1/dpaa1-ethercat.h

diff --git a/configure.ac b/configure.ac
index 2fcb150..8e924e8 100644
--- a/configure.ac
+++ b/configure.ac
@@ -257,6 +257,29 @@ AC_ARG_ENABLE([fec],
 AM_CONDITIONAL(ENABLE_FEC, test "x$enable_fec" = "x1")
 AC_SUBST(ENABLE_FEC,[$enable_fec])
 
+#------------------------------------------------------------------------------
+# NXP DPAA1 driver
+#------------------------------------------------------------------------------
+
+AC_ARG_ENABLE([dpaa1],
+    AS_HELP_STRING([--enable-dpaa1],
+                   [Enable nxp dpaa1 driver]),
+    [
+        case "${enableval}" in
+            yes) enable_dpaa1=1
+                ;;
+            no) enable_dpaa1=0
+                ;;
+            *) AC_MSG_ERROR([Invalid value for --enable-dpaa1])
+                ;;
+        esac
+    ],
+    [enable-dpaa1=0] # disabled by default
+)
+
+AM_CONDITIONAL(ENABLE_DPAA1, test "x$enable_dpaa1" = "x1")
+AC_SUBST(ENABLE_DPAA1,[$enable_dpaa1])
+
 #------------------------------------------------------------------------------
 # e100 driver
 #------------------------------------------------------------------------------
@@ -993,6 +1016,8 @@ AC_CONFIG_FILES([
         devices/fec/Kbuild
 	devices/enetc/Makefile
 	devices/enetc/Kbuild
+        devices/dpaa1/Kbuild
+        devices/dpaa1/Makefile
         ethercat.spec
         examples/Kbuild
         examples/Makefile
diff --git a/devices/Kbuild.in b/devices/Kbuild.in
index 821c618..d52b31d 100644
--- a/devices/Kbuild.in
+++ b/devices/Kbuild.in
@@ -44,6 +44,10 @@ ifeq (@ENABLE_GENERIC@,1)
 	CFLAGS_$(EC_GENERIC_OBJ) = -DREV=$(REV)
 endif
 
+ifeq (@ENABLE_DPAA1@,1)
+       obj-m += dpaa1/
+endif
+
 ifeq (@ENABLE_8139TOO@,1)
 	EC_8139TOO_OBJ := 8139too-@KERNEL_8139TOO@-ethercat.o
 	obj-m += ec_8139too.o
diff --git a/devices/Makefile.am b/devices/Makefile.am
index e8a867a..a7e9d09 100644
--- a/devices/Makefile.am
+++ b/devices/Makefile.am
@@ -30,12 +30,14 @@
 SUBDIRS = \
 	e1000 \
 	e1000e \
-	fec
+	fec \
+	dpaa1
 
 DIST_SUBDIRS = \
 	e1000 \
 	e1000e \
-	fec
+	fec \
+	dpaa1
 
 # using HEADERS to enable tags target
 noinst_HEADERS = \
diff --git a/devices/dpaa1/Kbuild.in b/devices/dpaa1/Kbuild.in
new file mode 100644
index 0000000..10cffc3
--- /dev/null
+++ b/devices/dpaa1/Kbuild.in
@@ -0,0 +1,53 @@
+#------------------------------------------------------------------------------
+#
+#  $Id$
+#
+#  Copyright (C) 2006-2008  Florian Pose, Ingenieurgemeinschaft IgH
+#
+#  This file is part of the IgH EtherCAT Master.
+#
+#  The IgH EtherCAT Master is free software; you can redistribute it and/or
+#  modify it under the terms of the GNU General Public License version 2, as
+#  published by the Free Software Foundation.
+#
+#  The IgH EtherCAT Master is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
+#  Public License for more details.
+#
+#  You should have received a copy of the GNU General Public License along
+#  with the IgH EtherCAT Master; if not, write to the Free Software
+#  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+#
+#  ---
+#
+#  The license mentioned above concerns the source code only. Using the
+#  EtherCAT technology and brand is only permitted in compliance with the
+#  industrial property and similar rights of Beckhoff Automation GmbH.
+#
+#  ---
+#
+#  vim: syntax=make
+#
+#------------------------------------------------------------------------------
+
+TOPDIR := $(src)/../..
+
+REV := $(shell if test -s $(TOPDIR)/revision; then \
+		cat $(TOPDIR)/revision; \
+	else \
+		hg id -i $(TOPDIR) 2>/dev/null || echo "unknown"; \
+	fi)
+
+ifeq (@ENABLE_DPAA1@,1)
+	EC_DPAA1_OBJ := dpaa1-ethercat.o
+	obj-m += ec_dpaa1.o
+	ec_dpaa1-objs := $(EC_DPAA1_OBJ)
+	CFLAGS_$(EC_DPAA1_OBJ) = -DREV=$(REV)
+endif
+
+KBUILD_EXTRA_SYMBOLS := \
+	@abs_top_builddir@/$(LINUX_SYMVERS) \
+	@abs_top_builddir@/master/$(LINUX_SYMVERS)
+
+#------------------------------------------------------------------------------
diff --git a/devices/dpaa1/Makefile.am b/devices/dpaa1/Makefile.am
new file mode 100644
index 0000000..55231ab
--- /dev/null
+++ b/devices/dpaa1/Makefile.am
@@ -0,0 +1,39 @@
+#  published by the Free Software Foundation.
+#
+#  The IgH EtherCAT Master is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
+#  Public License for more details.
+#
+#  You should have received a copy of the GNU General Public License along
+#  with the IgH EtherCAT Master; if not, write to the Free Software
+#  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+#
+#  ---
+#
+#  The license mentioned above concerns the source code only. Using the
+#  EtherCAT technology and brand is only permitted in compliance with the
+#  industrial property and similar rights of Beckhoff Automation GmbH.
+#
+#------------------------------------------------------------------------------
+
+EXTRA_DIST = \
+        Kbuild.in \
+        dpaa1-ethercat.h \
+        dpaa1-ethercat.c
+
+BUILT_SOURCES = \
+        Kbuild
+
+modules:
+	$(MAKE) -C "$(LINUX_SOURCE_DIR)" M="@abs_srcdir@" modules
+
+modules_install:
+	$(MAKE) -C "$(LINUX_SOURCE_DIR)" M="@abs_srcdir@" \
+                INSTALL_MOD_DIR="$(INSTALL_MOD_DIR)" modules_install
+
+clean-local:
+	$(MAKE) -C "$(LINUX_SOURCE_DIR)" M="@abs_srcdir@" clean
+
+#------------------------------------------------------------------------------
+
diff --git a/devices/dpaa1/dpaa1-ethercat.c b/devices/dpaa1/dpaa1-ethercat.c
new file mode 100644
index 0000000..6aff8af
--- /dev/null
+++ b/devices/dpaa1/dpaa1-ethercat.c
@@ -0,0 +1,123 @@
+// SPDX-License-Identifier: (GPL-2.0 OR MIT)
+/*
+ * Copyright 2021-2022 NXP
+ */
+
+#include "dpaa1-ethercat.h"
+
+static void *ec_dpaa_netdev_init(struct net_device *net_dev)
+{
+	ec_device_t *ecdev = NULL;
+	int ret = 0;
+
+	ecdev = ecdev_offer(net_dev, ec_dpaa_poll, THIS_MODULE);
+	if (ecdev) {
+		ret = ecdev_open(ecdev);
+		if (ret) {
+			ecdev_withdraw(ecdev);
+			pr_info("%s: ecdev_open failed! ret=%d\n", __func__, ret);
+			return NULL;
+		}
+		pr_info("%s: ecdev_offer netdev %s ok!\n", __func__, net_dev->name);
+	} else {
+		pr_info("%s: ecdev_offer netdev %s failed!\n", __func__, net_dev->name);
+	}
+
+	return ecdev;
+}
+
+static int ec_dpaa_receive(void *pecdev, const void *data, size_t size)
+{
+	ecdev_receive((ec_device_t *)pecdev, data, size);
+	return 0;
+}
+
+static int ec_dpaa_link(void *pecdev, uint8_t link)
+{
+	ec_device_t *ecdev = (ec_device_t *)pecdev;
+
+	if (link == PHY_RUNNING) {
+		if (ecdev && !ecdev_get_link(ecdev))
+			ecdev_set_link(ecdev, 1);
+	} else {
+		if (ecdev && ecdev_get_link(ecdev))
+			ecdev_set_link(ecdev, 0);
+	}
+
+	return 0;
+}
+
+static int ec_dpaa_close(void *pecdev)
+{
+	ec_device_t *ecdev = (ec_device_t *)pecdev;
+
+	ecdev_close(ecdev);
+	ecdev_withdraw(ecdev);
+
+	return 0;
+}
+
+static int ec_dpaa_init(void)
+{
+	struct net_device *net_dev = NULL;
+	void *ecdev = NULL;
+	int i = 0;
+
+	ec_dpaa_set_func_cb(ec_dpaa_receive, ec_dpaa_link, ec_dpaa_close);
+
+	for (i = 0; i < MAX_EC_DPAA_NETDEV_CNT; i++) {
+		net_dev = ec_dpaa_get_netdev(i);
+		if (!net_dev)
+			break;
+
+		ecdev = ec_dpaa_netdev_init(net_dev);
+		if (ecdev)
+			ec_dpaa_set_ecdev(i, ecdev);
+	}
+
+	return 0;
+}
+
+static int ec_dpaa_clean(void)
+{
+	struct net_device *net_dev = NULL;
+	void *ecdev = NULL;
+	int i = 0;
+
+	ec_dpaa_set_func_cb(NULL, NULL, NULL);
+
+	for (i = 0; i < MAX_EC_DPAA_NETDEV_CNT; i++) {
+		net_dev = ec_dpaa_get_netdev(i);
+		if (!net_dev)
+			break;
+
+		ecdev = ec_dpaa_get_ecdev(i);
+		if (ecdev)
+			ec_dpaa_close(ecdev);
+
+		ec_dpaa_set_ecdev(i, NULL);
+	}
+
+	return 0;
+}
+
+static int __init ec_dpaa_init_module(void)
+{
+	int ret;
+
+	pr_info("%s\n", __func__);
+
+	ret = ec_dpaa_init();
+
+	return ret;
+}
+
+module_init(ec_dpaa_init_module);
+
+static void __exit ec_dpaa_exit_module(void)
+{
+	ec_dpaa_clean();
+}
+
+module_exit(ec_dpaa_exit_module);
+MODULE_LICENSE("GPL");
diff --git a/devices/dpaa1/dpaa1-ethercat.h b/devices/dpaa1/dpaa1-ethercat.h
new file mode 100644
index 0000000..2995599
--- /dev/null
+++ b/devices/dpaa1/dpaa1-ethercat.h
@@ -0,0 +1,33 @@
+/* SPDX-License-Identifier: (GPL-2.0 OR MIT) */
+/*
+ * Copyright 2021-2022 NXP
+ */
+
+#ifndef __NXP_DPAA1_ETHERCAT__
+#define __NXP_DPAA1_ETHERCAT__
+
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/err.h>
+#include <linux/phy.h>
+
+#include "../../master/globals.h"
+#include "../../master/master.h"
+#include "../../master/device.h"
+
+#define MAX_EC_DPAA_NETDEV_CNT (16)
+
+typedef int (*ec_dpaa_receive_cb)(void *pecdev, const void *data, size_t size);
+typedef int (*ec_dpaa_link_cb)(void *pecdev, uint8_t link);
+typedef int (*ec_dpaa_close_cb)(void *pecdev);
+
+int ec_dpaa_set_func_cb(ec_dpaa_receive_cb recv, ec_dpaa_link_cb link, ec_dpaa_close_cb close);
+
+extern struct net_device *ec_dpaa_get_netdev(int idx);
+extern void ec_dpaa_poll(struct net_device *net_dev);
+extern int ec_dpaa_set_ecdev(int idx, void *ecdev);
+extern void *ec_dpaa_get_ecdev(int idx);
+extern struct module *ec_dpaa_get_module(void);
+extern int dpa_unregister_ethercat(struct net_device *net_dev);
+
+#endif
diff --git a/devices/enetc/enetc_ethtool.c b/devices/enetc/enetc_ethtool.c
index 902eeca..974256a 100644
--- a/devices/enetc/enetc_ethtool.c
+++ b/devices/enetc/enetc_ethtool.c
@@ -627,7 +627,9 @@ static void enetc_get_ringparam(struct net_device *ndev,
 }
 
 static int enetc_get_coalesce(struct net_device *ndev,
-			      struct ethtool_coalesce *ic)
+			      struct ethtool_coalesce *ic,
+			      struct kernel_ethtool_coalesce *kernel_coal,
+			      struct netlink_ext_ack *extack)
 {
 	struct enetc_ndev_priv *priv = netdev_priv(ndev);
 	struct enetc_int_vector *v = priv->int_vector[0];
@@ -644,7 +646,9 @@ static int enetc_get_coalesce(struct net_device *ndev,
 }
 
 static int enetc_set_coalesce(struct net_device *ndev,
-			      struct ethtool_coalesce *ic)
+			      struct ethtool_coalesce *ic,
+			      struct kernel_ethtool_coalesce *kernel_coal,
+			      struct netlink_ext_ack *extack)
 {
 	struct enetc_ndev_priv *priv = netdev_priv(ndev);
 	u32 rx_ictt, tx_ictt;
@@ -749,6 +753,22 @@ static int enetc_set_wol(struct net_device *dev,
 	return ret;
 }
 
+static void enetc_get_pauseparam(struct net_device *dev,
+				 struct ethtool_pauseparam *pause)
+{
+	struct enetc_ndev_priv *priv = netdev_priv(dev);
+
+	phylink_ethtool_get_pauseparam(priv->phylink, pause);
+}
+
+static int enetc_set_pauseparam(struct net_device *dev,
+				struct ethtool_pauseparam *pause)
+{
+	struct enetc_ndev_priv *priv = netdev_priv(dev);
+
+	return phylink_ethtool_set_pauseparam(priv->phylink, pause);
+}
+
 static int enetc_get_link_ksettings(struct net_device *dev,
 				    struct ethtool_link_ksettings *cmd)
 {
@@ -771,82 +791,6 @@ static int enetc_set_link_ksettings(struct net_device *dev,
 	return phylink_ethtool_ksettings_set(priv->phylink, cmd);
 }
 
-static int enetc_set_preempt(struct net_device *ndev,
-			     struct ethtool_fp *pt)
-{
-	struct enetc_ndev_priv *priv = netdev_priv(ndev);
-	u32 preempt, temp;
-	int rafs;
-	int i;
-
-	if (!pt)
-		return -EINVAL;
-
-	if (pt->min_frag_size < 60 || pt->min_frag_size > 252)
-		return -EINVAL;
-
-	rafs = DIV_ROUND_UP((pt->min_frag_size + 4), 64) - 1;
-
-	if (!pt->fp_enabled)
-		preempt = 0x0;
-	else
-		preempt = pt->preemptible_queues_mask;
-
-	temp = enetc_rd(&priv->si->hw, ENETC_QBV_PTGCR_OFFSET);
-	if (temp & ENETC_QBV_TGE)
-		enetc_wr(&priv->si->hw, ENETC_QBV_PTGCR_OFFSET,
-			 temp & (~ENETC_QBV_TGPE));
-
-	for (i = 0; i < 8; i++) {
-		/* 1 Enabled. Traffic is transmitted on the preemptive MAC. */
-		temp = enetc_port_rd(&priv->si->hw, ENETC_PTCFPR(i));
-
-		if ((preempt >> i) & 0x1)
-			enetc_port_wr(&priv->si->hw,
-				      ENETC_PTCFPR(i),
-				      temp | ENETC_FPE);
-		else
-			enetc_port_wr(&priv->si->hw,
-				      ENETC_PTCFPR(i),
-				      temp & ~ENETC_FPE);
-	}
-
-	temp = enetc_port_rd(&priv->si->hw, ENETC_MMCSR);
-	temp &= ~ENETC_MMCSR_RAFS_MASK;
-	temp |= ENETC_MMCSR_RAFS(rafs);
-	enetc_port_wr(&priv->si->hw, ENETC_MMCSR, temp);
-
-	return 0;
-}
-
-static int enetc_get_preempt(struct net_device *ndev,
-			     struct ethtool_fp *pt)
-{
-	struct enetc_ndev_priv *priv = netdev_priv(ndev);
-	u32 temp;
-	int i;
-
-	if (!pt)
-		return -EINVAL;
-
-	if (enetc_port_rd(&priv->si->hw, ENETC_PFPMR) & ENETC_PFPMR_PMACE)
-		pt->fp_enabled = true;
-	else
-		pt->fp_enabled = false;
-
-	pt->preemptible_queues_mask = 0;
-	for (i = 0; i < 8; i++)
-		if (enetc_port_rd(&priv->si->hw, ENETC_PTCFPR(i)) & 0x80000000)
-			pt->preemptible_queues_mask |= 1 << i;
-
-	pt->fp_supported = !!(priv->si->hw_features & ENETC_SI_F_QBU);
-	pt->supported_queues_mask = 0xff;
-	temp = enetc_port_rd(&priv->si->hw, ENETC_MMCSR);
-	pt->min_frag_size = (ENETC_MMCSR_GET_RAFS(temp) + 1) * 64;
-
-	return 0;
-}
-
 static const struct ethtool_ops enetc_pf_ethtool_ops = {
 	.supported_coalesce_params = ETHTOOL_COALESCE_USECS |
 				     ETHTOOL_COALESCE_MAX_FRAMES |
@@ -862,7 +806,6 @@ static const struct ethtool_ops enetc_pf_ethtool_ops = {
 	.get_rxfh_indir_size = enetc_get_rxfh_indir_size,
 	.get_rxfh = enetc_get_rxfh,
 	.set_rxfh = enetc_set_rxfh,
-	.get_ringparam = enetc_get_ringparam,
 	.get_coalesce = enetc_get_coalesce,
 	.set_coalesce = enetc_set_coalesce,
 	.get_link_ksettings = enetc_get_link_ksettings,
@@ -871,8 +814,8 @@ static const struct ethtool_ops enetc_pf_ethtool_ops = {
 	.get_ts_info = enetc_get_ts_info,
 	.get_wol = enetc_get_wol,
 	.set_wol = enetc_set_wol,
-	.set_preempt = enetc_set_preempt,
-	.get_preempt = enetc_get_preempt,
+	.get_pauseparam = enetc_get_pauseparam,
+	.set_pauseparam = enetc_set_pauseparam,
 };
 
 static const struct ethtool_ops enetc_vf_ethtool_ops = {
@@ -889,7 +832,6 @@ static const struct ethtool_ops enetc_vf_ethtool_ops = {
 	.get_rxfh_indir_size = enetc_get_rxfh_indir_size,
 	.get_rxfh = enetc_get_rxfh,
 	.set_rxfh = enetc_set_rxfh,
-	.get_ringparam = enetc_get_ringparam,
 	.get_coalesce = enetc_get_coalesce,
 	.set_coalesce = enetc_set_coalesce,
 	.get_link = ethtool_op_get_link,
diff --git a/devices/enetc/enetc_pf.c b/devices/enetc/enetc_pf.c
index 432f04f..d3469c4 100644
--- a/devices/enetc/enetc_pf.c
+++ b/devices/enetc/enetc_pf.c
@@ -6,6 +6,8 @@
 #include <linux/fsl/enetc_mdio.h>
 #include <linux/of_mdio.h>
 #include <linux/of_net.h>
+#include <linux/pcs-lynx.h>
+#include <linux/phy/phy.h>
 #include "enetc_pf.h"
 #include "../ecdev.h"
 
@@ -306,11 +308,18 @@ static int enetc_imdio_create(struct enetc_pf *pf)
 {
 	struct device *dev = &pf->si->pdev->dev;
 	struct enetc_mdio_priv *mdio_priv;
-	struct lynx_pcs *pcs_lynx;
-	struct mdio_device *pcs;
+	struct phylink_pcs *phylink_pcs;
 	struct mii_bus *bus;
+	struct phy *serdes;
+	size_t num_phys;
 	int err;
 
+	serdes = devm_of_phy_optional_get(dev, dev->of_node, NULL);
+	if (IS_ERR(serdes))
+		return PTR_ERR(serdes);
+
+	num_phys = serdes ? 1 : 0;
+
 	bus = mdiobus_alloc_size(sizeof(*mdio_priv));
 	if (!bus)
 		return -ENOMEM;
@@ -331,23 +340,15 @@ static int enetc_imdio_create(struct enetc_pf *pf)
 		goto free_mdio_bus;
 	}
 
-	pcs = mdio_device_create(bus, 0);
-	if (IS_ERR(pcs)) {
-		err = PTR_ERR(pcs);
-		dev_err(dev, "cannot create pcs (%d)\n", err);
-		goto unregister_mdiobus;
-	}
-
-	pcs_lynx = lynx_pcs_create(pcs);
-	if (!pcs_lynx) {
-		mdio_device_free(pcs);
-		err = -ENOMEM;
+	phylink_pcs = lynx_pcs_create_mdiodev(bus, 0, &serdes, num_phys);
+	if (IS_ERR(phylink_pcs)) {
+		err = PTR_ERR(phylink_pcs);
 		dev_err(dev, "cannot create lynx pcs (%d)\n", err);
 		goto unregister_mdiobus;
 	}
 
 	pf->imdio = bus;
-	pf->pcs = pcs_lynx;
+	pf->pcs = phylink_pcs;
 
 	return 0;
 
@@ -361,7 +362,6 @@ free_mdio_bus:
 static void enetc_imdio_remove(struct enetc_pf *pf)
 {
 	if (pf->pcs) {
-		mdio_device_free(pf->pcs->mdio);
 		lynx_pcs_destroy(pf->pcs);
 	}
 	if (pf->imdio) {
@@ -460,8 +460,17 @@ static void enetc_pl_mac_config(struct phylink_config *config,
 	enetc_mac_config(&pf->si->hw, state->interface);
 
 	priv = netdev_priv(pf->si->ndev);
-	if (pf->pcs)
-		phylink_set_pcs(priv->phylink, &pf->pcs->pcs);
+	if (pf->pcs) {
+		priv->phylink->pcs = pf->pcs;
+
+		if (!priv->phylink->phylink_disable_state &&
+			priv->phylink->cfg_link_an_mode == MLO_AN_INBAND) {
+			if (pf->pcs->poll)
+				mod_timer(&priv->phylink->link_poll, jiffies + HZ);
+			else
+				del_timer(&priv->phylink->link_poll);
+		}
+	}
 }
 
 static void enetc_pl_mac_link_up(struct phylink_config *config,
diff --git a/devices/enetc/enetc_pf.h b/devices/enetc/enetc_pf.h
index 263946c..693e500 100644
--- a/devices/enetc/enetc_pf.h
+++ b/devices/enetc/enetc_pf.h
@@ -2,7 +2,7 @@
 /* Copyright 2017-2019 NXP */
 
 #include "enetc.h"
-#include <linux/pcs-lynx.h>
+#include <linux/phylink.h>
 
 #define ENETC_PF_NUM_RINGS	8
 
@@ -18,6 +18,50 @@ struct enetc_mac_filter {
 	int mac_addr_cnt;
 };
 
+struct phylink {
+	/* private: */
+	struct net_device *netdev;
+	const struct phylink_mac_ops *mac_ops;
+	struct phylink_config *config;
+	struct phylink_pcs *pcs;
+	struct device *dev;
+	unsigned int old_link_state:1;
+
+	unsigned long phylink_disable_state; /* bitmask of disables */
+	struct phy_device *phydev;
+	phy_interface_t link_interface; /* PHY_INTERFACE_xxx */
+	u8 cfg_link_an_mode;        /* MLO_AN_xxx */
+	u8 cur_link_an_mode;
+	u8 link_port;           /* The current non-phy ethtool port */
+	__ETHTOOL_DECLARE_LINK_MODE_MASK(supported);
+
+	/* The link configuration settings */
+	struct phylink_link_state link_config;
+
+	/* The current settings */
+	phy_interface_t cur_interface;
+
+	struct gpio_desc *link_gpio;
+	unsigned int link_irq;
+	struct timer_list link_poll;
+	void (*get_fixed_state)(struct net_device *dev,
+			struct phylink_link_state *s);
+
+	struct mutex state_mutex;
+	struct phylink_link_state phy_state;
+	struct work_struct resolve;
+
+	bool mac_link_dropped;
+	bool using_mac_select_pcs;
+
+	struct sfp_bus *sfp_bus;
+	bool sfp_may_have_phy;
+	DECLARE_PHY_INTERFACE_MASK(sfp_interfaces);
+	__ETHTOOL_DECLARE_LINK_MODE_MASK(sfp_support);
+	u8 sfp_port;
+};
+
+
 #define ENETC_VLAN_HT_SIZE	64
 
 enum enetc_vf_flags {
@@ -46,7 +90,7 @@ struct enetc_pf {
 
 	struct mii_bus *mdio; /* saved for cleanup */
 	struct mii_bus *imdio;
-	struct lynx_pcs *pcs;
+	struct phylink_pcs *pcs;
 
 	phy_interface_t if_mode;
 	struct phylink_config phylink_config;
diff --git a/devices/enetc/enetc_qos.c b/devices/enetc/enetc_qos.c
index dbceb99..a47c661 100644
--- a/devices/enetc/enetc_qos.c
+++ b/devices/enetc/enetc_qos.c
@@ -1179,7 +1179,7 @@ static int enetc_psfp_parse_clsflower(struct enetc_ndev_priv *priv,
 	}
 
 	/* parsing gate action */
-	if (entryg->gate.index >= priv->psfp_cap.max_psfp_gate) {
+	if (entryg->hw_index >= priv->psfp_cap.max_psfp_gate) {
 		NL_SET_ERR_MSG_MOD(extack, "No Stream Gate resource!");
 		err = -ENOSPC;
 		goto free_filter;
@@ -1199,7 +1199,7 @@ static int enetc_psfp_parse_clsflower(struct enetc_ndev_priv *priv,
 	}
 
 	refcount_set(&sgi->refcount, 1);
-	sgi->index = entryg->gate.index;
+	sgi->index = entryg->hw_index;
 	sgi->init_ipv = entryg->gate.prio;
 	sgi->basetime = entryg->gate.basetime;
 	sgi->cycletime = entryg->gate.cycletime;
@@ -1236,7 +1236,7 @@ static int enetc_psfp_parse_clsflower(struct enetc_ndev_priv *priv,
 			refcount_set(&fmi->refcount, 1);
 			fmi->cir = entryp->police.rate_bytes_ps;
 			fmi->cbs = entryp->police.burst;
-			fmi->index = entryp->police.index;
+			fmi->index = entryp->hw_index;
 			filter->flags |= ENETC_PSFP_FLAGS_FMI;
 			filter->fmi_index = fmi->index;
 			sfi->meter_id = fmi->index;
diff --git a/devices/fec/fec_main.c b/devices/fec/fec_main.c
index 3f01435..56f1cb5 100644
--- a/devices/fec/fec_main.c
+++ b/devices/fec/fec_main.c
@@ -1372,8 +1372,8 @@ void ecdev_fec_poll(struct net_device *ndev)
 static int fec_get_mac(struct net_device *ndev)
 {
 	struct fec_enet_private *fep = netdev_priv(ndev);
-	struct fec_platform_data *pdata = dev_get_platdata(&fep->pdev->dev);
 	unsigned char *iap, tmpaddr[ETH_ALEN];
+	int ret;
 
 	/*
 	 * try to get mac address in following order:
@@ -1389,11 +1389,11 @@ static int fec_get_mac(struct net_device *ndev)
 	if (!is_valid_ether_addr(iap)) {
 		struct device_node *np = fep->pdev->dev.of_node;
 		if (np) {
-			const char *mac = of_get_mac_address(np);
-			if (!IS_ERR(mac))
-				iap = (unsigned char *) mac;
-			else if (PTR_ERR(mac) == -EPROBE_DEFER)
-				return -EPROBE_DEFER;
+			ret = of_get_mac_address(np, tmpaddr);
+			if (!ret)
+				iap = tmpaddr;
+			else if (ret == -EPROBE_DEFER)
+				return ret;
 		}
 	}
 
@@ -1405,6 +1405,8 @@ static int fec_get_mac(struct net_device *ndev)
 		if (FEC_FLASHMAC)
 			iap = (unsigned char *)FEC_FLASHMAC;
 #else
+		struct fec_platform_data *pdata = dev_get_platdata(&fep->pdev->dev);
+
 		if (pdata)
 			iap = (unsigned char *)&pdata->mac;
 #endif
@@ -1433,11 +1435,8 @@ static int fec_get_mac(struct net_device *ndev)
 		return 0;
 	}
 
-	memcpy(ndev->dev_addr, iap, ETH_ALEN);
-
 	/* Adjust MAC if using macaddr */
-	if (iap == macaddr)
-		 ndev->dev_addr[ETH_ALEN-1] = macaddr[ETH_ALEN-1] + fep->dev_id;
+	eth_hw_addr_gen(ndev, iap, iap == macaddr ? fep->dev_id : 0);
 
 	return 0;
 }
@@ -1684,6 +1683,34 @@ failed_clk_ptp:
 	return ret;
 }
 
+static int fec_enet_parse_rgmii_delay(struct fec_enet_private *fep,
+				      struct device_node *np)
+{
+	u32 rgmii_tx_delay, rgmii_rx_delay;
+
+	/* For rgmii tx internal delay, valid values are 0ps and 2000ps */
+	if (!of_property_read_u32(np, "tx-internal-delay-ps", &rgmii_tx_delay)) {
+		if (rgmii_tx_delay != 0 && rgmii_tx_delay != 2000) {
+			dev_err(&fep->pdev->dev, "The only allowed RGMII TX delay values are: 0ps, 2000ps");
+			return -EINVAL;
+		} else if (rgmii_tx_delay == 2000) {
+			fep->rgmii_txc_dly = true;
+		}
+	}
+
+	/* For rgmii rx internal delay, valid values are 0ps and 2000ps */
+	if (!of_property_read_u32(np, "rx-internal-delay-ps", &rgmii_rx_delay)) {
+		if (rgmii_rx_delay != 0 && rgmii_rx_delay != 2000) {
+			dev_err(&fep->pdev->dev, "The only allowed RGMII RX delay values are: 0ps, 2000ps");
+			return -EINVAL;
+		} else if (rgmii_rx_delay == 2000) {
+			fep->rgmii_rxc_dly = true;
+		}
+	}
+
+	return 0;
+}
+
 static int fec_enet_mii_probe(struct net_device *ndev)
 {
 	struct fec_enet_private *fep = netdev_priv(ndev);
@@ -3117,12 +3144,6 @@ fec_probe(struct platform_device *pdev)
 	if (ret)
 		goto failed_stop_mode;
 
-	if (of_get_property(np, "fsl,rgmii_txc_dly", NULL))
-		fep->rgmii_txc_dly = true;
-
-	if (of_get_property(np, "fsl,rgmii_rxc_dly", NULL))
-		fep->rgmii_rxc_dly = true;
-
 	phy_node = of_parse_phandle(np, "phy-handle", 0);
 	if (!phy_node && of_phy_is_fixed_link(np)) {
 		ret = of_phy_register_fixed_link(np);
@@ -3146,6 +3167,10 @@ fec_probe(struct platform_device *pdev)
 		fep->phy_interface = interface;
 	}
 
+	ret = fec_enet_parse_rgmii_delay(fep, np);
+	if (ret)
+		goto failed_rgmii_delay;
+
 	request_bus_freq(BUS_FREQ_HIGH);
 
 	fep->clk_ipg = devm_clk_get(&pdev->dev, "ipg");
@@ -3177,9 +3202,11 @@ fec_probe(struct platform_device *pdev)
 	fep->clk_ref_rate = clk_get_rate(fep->clk_ref);
 
 	/* clk_2x_txclk is optional, depends on board */
-	fep->clk_2x_txclk = devm_clk_get(&pdev->dev, "enet_2x_txclk");
-	if (IS_ERR(fep->clk_2x_txclk))
-		fep->clk_2x_txclk = NULL;
+	if (fep->rgmii_txc_dly || fep->rgmii_rxc_dly) {
+		fep->clk_2x_txclk = devm_clk_get(&pdev->dev, "enet_2x_txclk");
+		if (IS_ERR(fep->clk_2x_txclk))
+			fep->clk_2x_txclk = NULL;
+	}
 
 	fep->bufdesc_ex = fep->quirks & FEC_QUIRK_HAS_BUFDESC_EX;
 	fep->clk_ptp = devm_clk_get(&pdev->dev, "ptp");
@@ -3285,6 +3312,7 @@ failed_clk_ipg:
 	fec_enet_clk_enable(ndev, false);
 failed_clk:
 	release_bus_freq(BUS_FREQ_HIGH);
+failed_rgmii_delay:
 	if (of_phy_is_fixed_link(np))
 		of_phy_deregister_fixed_link(np);
 	of_node_put(phy_node);
diff --git a/master/ethernet.c b/master/ethernet.c
index 81a33e7..ebec2cb 100644
--- a/master/ethernet.c
+++ b/master/ethernet.c
@@ -109,7 +109,7 @@ int ec_eoe_init(
     ec_eoe_t **priv;
     int i, ret = 0;
     char name[EC_DATAGRAM_NAME_SIZE];
-
+    unsigned char addr[ETH_ALEN];
     eoe->slave = slave;
 
     ec_datagram_init(&eoe->datagram);
@@ -167,8 +167,10 @@ int ec_eoe_init(
     eoe->dev->get_stats = ec_eoedev_stats;
 #endif
 
+    memcpy(addr, eoe->dev->dev_addr, ETH_ALEN);
     for (i = 0; i < ETH_ALEN; i++)
-        eoe->dev->dev_addr[i] = i | (i << 4);
+        addr[i] = i | (i << 4);
+    dev_addr_mod(eoe->dev, 0, addr, ETH_ALEN);
 
     // initialize private data
     priv = netdev_priv(eoe->dev);
@@ -191,7 +193,11 @@ int ec_eoe_init(
     }
 
     // make the last address octet unique
-    eoe->dev->dev_addr[ETH_ALEN - 1] = (uint8_t) eoe->dev->ifindex;
+    //eoe->dev->dev_addr[ETH_ALEN - 1] = (uint8_t) eoe->dev->ifindex;
+    memcpy(addr, eoe->dev->dev_addr, ETH_ALEN);
+    addr[ETH_ALEN - 1] = (uint8_t) eoe->dev->ifindex;
+    dev_addr_mod(eoe->dev, 0, addr, ETH_ALEN);
+
     return 0;
 
  out_free:
diff --git a/script/ethercat.conf b/script/ethercat.conf
index 760aa46..e9cbd14 100644
--- a/script/ethercat.conf
+++ b/script/ethercat.conf
@@ -36,8 +36,8 @@ MASTER0_DEVICE=""
 # the EtherCAT-capable ones. If a certain (EtherCAT-capable) driver is not
 # found, a warning will appear.
 #
-# Possible values: 8139too, e100, e1000, e1000e, r8169, fec, enetc, generic. Separate
-# multiple drivers with spaces.
+# Possible values: 8139too, e100, e1000, e1000e, r8169, fec, enetc, dpaa1, generic.
+# Separate multiple drivers with spaces.
 #
 # Note: The e100, e1000, e1000e, fec and r8169 drivers are not built by default.
 # Enable them with the --enable-<driver> configure switches.
diff --git a/script/ethercatctl.in b/script/ethercatctl.in
index c57750c..826973a 100755
--- a/script/ethercatctl.in
+++ b/script/ethercatctl.in
@@ -192,6 +192,8 @@ stop)
             continue
         elif [ ${MODULE} == "generic" ]; then
             continue
+        elif [ ${MODULE} == "dpaa1" ]; then
+            continue
         fi
         ${MODPROBE} ${MODPROBE_FLAGS} ${MODULE}
     done
-- 
2.25.1

