From 029b0f476852cbc32150248235b508129f93c928 Mon Sep 17 00:00:00 2001
From: "wenbin.song" <wenbin.song@nxp.com>
Date: Sat, 15 Jun 2019 02:57:04 +0000
Subject: [PATCH 13/18] ec_enetc: Add ec_enetc native driver based on linux
 4.14

Signed-off-by: Wenbin Song <wenbin.song@nxp.com>
Upstream-Status: Pending
---
 configure.ac               |  25 +
 devices/Kbuild.in          |   4 +
 devices/enetc/Kbuild.in    |  55 +++
 devices/enetc/Makefile.am  |  51 ++
 devices/enetc/enetc.c      | 141 ++++--
 devices/enetc/enetc.h      |   4 +-
 devices/enetc/enetc_mdio.c | 199 --------
 devices/enetc/enetc_msg.c  | 164 -------
 devices/enetc/enetc_pf.c   | 956 -------------------------------------
 devices/enetc/enetc_pf.h   |  55 ---
 devices/enetc/enetc_vf.c   |  36 +-
 11 files changed, 270 insertions(+), 1420 deletions(-)
 create mode 100644 devices/enetc/Kbuild.in
 create mode 100644 devices/enetc/Makefile.am
 delete mode 100644 devices/enetc/enetc_mdio.c
 delete mode 100644 devices/enetc/enetc_msg.c
 delete mode 100644 devices/enetc/enetc_pf.c
 delete mode 100644 devices/enetc/enetc_pf.h

diff --git a/configure.ac b/configure.ac
index d5be0c1..58257b0 100644
--- a/configure.ac
+++ b/configure.ac
@@ -211,6 +211,29 @@ fi
 
 AC_SUBST(KERNEL_8139TOO,[$kernel8139too])
 
+#------------------------------------------------------------------------------
+# enetc vf driver
+#------------------------------------------------------------------------------
+
+AC_ARG_ENABLE([enetc],
+    AS_HELP_STRING([--enable-enetc],
+                   [Enable enetc vf driver]),
+    [
+        case "${enableval}" in
+            yes) enable_enetc=1
+                ;;
+            no) enable_enetc=0
+                ;;
+            *) AC_MSG_ERROR([Invalid value for --enable-enetc])
+                ;;
+        esac
+    ],
+    [enable_enetc=0] # disabled by default
+)
+
+AM_CONDITIONAL(ENABLE_ENETC, test "x$enable_enetc" = "x1")
+AC_SUBST(ENABLE_ENETC,[$enable_enetc])
+
 #------------------------------------------------------------------------------
 # IMX FEC driver
 #------------------------------------------------------------------------------
@@ -968,6 +991,8 @@ AC_CONFIG_FILES([
         devices/e1000e/Makefile
         devices/fec/Makefile
         devices/fec/Kbuild
+	devices/enetc/Makefile
+	devices/enetc/Kbuild
         ethercat.spec
         examples/Kbuild
         examples/Makefile
diff --git a/devices/Kbuild.in b/devices/Kbuild.in
index a3a7124..821c618 100644
--- a/devices/Kbuild.in
+++ b/devices/Kbuild.in
@@ -58,6 +58,10 @@ ifeq (@ENABLE_E100@,1)
 	CFLAGS_$(EC_E100_OBJ) = -DREV=$(REV)
 endif
 
+ifeq (@ENABLE_ENETC@,1)
+	obj-m += enetc/
+endif
+
 ifeq (@ENABLE_E1000@,1)
 	obj-m += e1000/
 endif
diff --git a/devices/enetc/Kbuild.in b/devices/enetc/Kbuild.in
new file mode 100644
index 0000000..f089179
--- /dev/null
+++ b/devices/enetc/Kbuild.in
@@ -0,0 +1,55 @@
+#------------------------------------------------------------------------------
+#
+#  $Id$
+#
+#  Copyright (C) 2006-2008  Florian Pose, Ingenieurgemeinschaft IgH
+#
+#  This file is part of the IgH EtherCAT Master.
+#
+#  The IgH EtherCAT Master is free software; you can redistribute it and/or
+#  modify it under the terms of the GNU General Public License version 2, as
+#  published by the Free Software Foundation.
+#
+#  The IgH EtherCAT Master is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
+#  Public License for more details.
+#
+#  You should have received a copy of the GNU General Public License along
+#  with the IgH EtherCAT Master; if not, write to the Free Software
+#  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+#
+#  ---
+#
+#  The license mentioned above concerns the source code only. Using the
+#  EtherCAT technology and brand is only permitted in compliance with the
+#  industrial property and similar rights of Beckhoff Automation GmbH.
+#
+#  ---
+#
+#  vim: syntax=make
+#
+#------------------------------------------------------------------------------
+TOPDIR := $(src)/../..
+
+REV := $(shell if test -s $(TOPDIR)/revision; then \
+		cat $(TOPDIR)/revision; \
+	else \
+		hg id -i $(TOPDIR) 2>/dev/null || echo "unknown"; \
+	fi)
+
+ifeq (@ENABLE_ENETC@,1)
+	EC_ENETC_OBJ := \
+		enetc.o \
+		enetc_vf.o \
+		enetc_cbdr.o \
+		enetc_ethtool.o
+	obj-m += ec_enetc.o
+	ec_enetc-objs := $(EC_ENETC_OBJ)
+	CFLAGS_$(EC_ENETC_OBJ) = -DREV=$(REV)
+endif
+
+KBUILD_EXTRA_SYMBOLS := \
+	@abs_top_builddir@/$(LINUX_SYMVERS) \
+	@abs_top_builddir@/master/$(LINUX_SYMVERS)
+
diff --git a/devices/enetc/Makefile.am b/devices/enetc/Makefile.am
new file mode 100644
index 0000000..2049a7f
--- /dev/null
+++ b/devices/enetc/Makefile.am
@@ -0,0 +1,51 @@
+#------------------------------------------------------------------------------
+#
+#  $Id: Makefile.am,v 5e9221a78855 2013/01/07 17:23:27 fp $
+#
+#  Copyright (C) 2006-2008  Florian Pose, Ingenieurgemeinschaft IgH
+#
+#  This file is part of the IgH EtherCAT Master.
+#
+#  The IgH EtherCAT Master is free software; you can redistribute it and/or
+#  modify it under the terms of the GNU General Public License version 2, as
+#  published by the Free Software Foundation.
+#
+#  The IgH EtherCAT Master is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
+#  Public License for more details.
+#
+#  You should have received a copy of the GNU General Public License along
+#  with the IgH EtherCAT Master; if not, write to the Free Software
+#  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+#
+#  ---
+#
+#  The license mentioned above concerns the source code only. Using the
+#  EtherCAT technology and brand is only permitted in compliance with the
+#  industrial property and similar rights of Beckhoff Automation GmbH.
+#
+#------------------------------------------------------------------------------
+
+EXTRA_DIST = \
+	enetc.c \
+	enetc_ethtool.c \
+	enetc_tsn.c \
+	enetc_cbdr.c \
+	enetc_ptp.c \
+	enetc_vf.c 
+
+BUILT_SOURCES = \
+	Kbuild
+
+modules:
+	$(MAKE) -C "$(LINUX_SOURCE_DIR)" M="@abs_srcdir@" modules
+
+modules_install:
+	$(MAKE) -C "$(LINUX_SOURCE_DIR)" M="@abs_srcdir@" \
+		INSTALL_MOD_DIR="$(INSTALL_MOD_DIR)" modules_install
+
+clean-local:
+	$(MAKE) -C "$(LINUX_SOURCE_DIR)" M="@abs_srcdir@" clean
+
+#------------------------------------------------------------------------------
diff --git a/devices/enetc/enetc.c b/devices/enetc/enetc.c
index c9680bc..e87fdab 100644
--- a/devices/enetc/enetc.c
+++ b/devices/enetc/enetc.c
@@ -5,6 +5,7 @@
 #include <linux/tcp.h>
 #include <linux/udp.h>
 #include <linux/of_mdio.h>
+#include "../ecdev.h"
 
 /* ENETC overhead: optional extension BD + 1 BD gap */
 #define ENETC_TXBDS_NEEDED(val)	((val) + 2)
@@ -29,7 +30,9 @@ netdev_tx_t enetc_xmit(struct sk_buff *skb, struct net_device *ndev)
 
 	count = skb_shinfo(skb)->nr_frags + 1; /* fragments + head */
 	if (enetc_bd_unused(tx_ring) < ENETC_TXBDS_NEEDED(count)) {
-		netif_stop_subqueue(ndev, tx_ring->index);
+		if (!priv->ecdev) {
+			netif_stop_subqueue(ndev, tx_ring->index);
+		}
 		return NETDEV_TX_BUSY;
 	}
 
@@ -38,12 +41,15 @@ netdev_tx_t enetc_xmit(struct sk_buff *skb, struct net_device *ndev)
 		goto drop_packet_err;
 
 	if (enetc_bd_unused(tx_ring) < ENETC_TXBDS_MAX_NEEDED)
-		netif_stop_subqueue(ndev, tx_ring->index);
-
+		if (!priv->ecdev) {
+			netif_stop_subqueue(ndev, tx_ring->index);
+		}
 	return NETDEV_TX_OK;
 
 drop_packet_err:
-	dev_kfree_skb_any(skb);
+	if (!priv->ecdev) {
+		dev_kfree_skb_any(skb);
+	}
 	return NETDEV_TX_OK;
 }
 
@@ -96,11 +102,14 @@ static void enetc_unmap_tx_buff(struct enetc_bdr *tx_ring,
 static void enetc_free_tx_skb(struct enetc_bdr *tx_ring,
 			      struct enetc_tx_swbd *tx_swbd)
 {
+	struct enetc_ndev_priv *priv = netdev_priv(tx_ring->ndev);
 	if (tx_swbd->dma)
 		enetc_unmap_tx_buff(tx_ring, tx_swbd);
 
 	if (tx_swbd->skb) {
-		dev_kfree_skb_any(tx_swbd->skb);
+		if (!priv->ecdev) {
+			dev_kfree_skb_any(tx_swbd->skb);
+		}
 		tx_swbd->skb = NULL;
 	}
 }
@@ -266,6 +275,22 @@ static bool enetc_clean_tx_ring(struct enetc_bdr *tx_ring, int napi_budget);
 static int enetc_clean_rx_ring(struct enetc_bdr *rx_ring,
 			       struct napi_struct *napi, int work_limit);
 
+void ec_poll(struct net_device *ndev)
+{
+
+	struct enetc_ndev_priv *priv = netdev_priv(ndev);
+	int i, j;
+	struct enetc_int_vector *v;
+	for (i = 0; i < priv->bdr_int_num; i++){
+		v = priv->int_vector[i];
+		for (j = 0; j < v->count_tx_rings; j++){
+			enetc_clean_tx_ring(&v->tx_ring[j], 16);
+		}
+		enetc_clean_rx_ring(&v->rx_ring, NULL, 16);
+	}
+
+}
+
 static int enetc_poll(struct napi_struct *napi, int budget)
 {
 	struct enetc_int_vector
@@ -331,6 +356,7 @@ static bool enetc_clean_tx_ring(struct enetc_bdr *tx_ring, int napi_budget)
 {
 	int tx_frm_cnt = 0, tx_byte_cnt = 0, tx_win_drop = 0;
 	struct net_device *ndev = tx_ring->ndev;
+	struct enetc_ndev_priv *priv = netdev_priv(ndev);
 	struct enetc_tx_swbd *tx_swbd;
 	int i, bds_to_clean;
 	bool do_tstamp;
@@ -371,7 +397,9 @@ no_wb:
 				enetc_tstamp_tx(tx_swbd->skb, tstamp);
 				do_tstamp = false;
 			}
-			napi_consume_skb(tx_swbd->skb, napi_budget);
+			if (!priv->ecdev) {
+				napi_consume_skb(tx_swbd->skb, napi_budget);
+			}
 			tx_swbd->skb = NULL;
 		}
 
@@ -402,10 +430,12 @@ no_wb:
 	tx_ring->stats.bytes += tx_byte_cnt;
 	tx_ring->stats.win_drop += tx_win_drop;
 
-	if (unlikely(tx_frm_cnt && netif_carrier_ok(ndev) &&
-		     __netif_subqueue_stopped(ndev, tx_ring->index) &&
-		     (enetc_bd_unused(tx_ring) >= ENETC_TXBDS_MAX_NEEDED))) {
-		netif_wake_subqueue(ndev, tx_ring->index);
+	if (!priv->ecdev) {
+		if (unlikely(tx_frm_cnt && netif_carrier_ok(ndev) &&
+			     __netif_subqueue_stopped(ndev, tx_ring->index) &&
+				(enetc_bd_unused(tx_ring) >= ENETC_TXBDS_MAX_NEEDED))) {
+			netif_wake_subqueue(ndev, tx_ring->index);
+		}
 	}
 
 	return tx_frm_cnt != ENETC_DEFAULT_TX_WORK;
@@ -585,6 +615,17 @@ static void enetc_put_rx_buff(struct enetc_bdr *rx_ring,
 	rx_swbd->page = NULL;
 }
 
+static void *enetc_map_rx_buff_to_buf(struct enetc_bdr *rx_ring,
+						int i, u16 size)
+{
+	struct enetc_rx_swbd *rx_swbd = enetc_get_rx_buff(rx_ring, i, size);
+	void *ba;
+
+	ba = page_address(rx_swbd->page) + rx_swbd->page_offset - ENETC_RXB_PAD;
+	enetc_put_rx_buff(rx_ring, rx_swbd);
+
+	return ba;
+}
 static struct sk_buff *enetc_map_rx_buff_to_skb(struct enetc_bdr *rx_ring,
 						int i, u16 size)
 {
@@ -620,16 +661,22 @@ static void enetc_add_rx_buff_to_skb(struct enetc_bdr *rx_ring, int i,
 
 #define ENETC_RXBD_BUNDLE 16 /* # of BDs to update at once */
 
+struct ec_data
+{
+	void *ptr;
+	u16 size;
+};
+
 static int enetc_clean_rx_ring(struct enetc_bdr *rx_ring,
 			       struct napi_struct *napi, int work_limit)
 {
 	int rx_frm_cnt = 0, rx_byte_cnt = 0;
 	int cleaned_cnt, i;
-
+	struct enetc_ndev_priv *priv = netdev_priv(rx_ring->ndev);
+	
 	cleaned_cnt = enetc_bd_unused(rx_ring);
 	/* next descriptor to process */
 	i = rx_ring->next_to_clean;
-
 	while (likely(rx_frm_cnt < work_limit)) {
 		union enetc_rx_bd *rxbd;
 		struct sk_buff *skb;
@@ -653,7 +700,6 @@ static int enetc_clean_rx_ring(struct enetc_bdr *rx_ring,
 		skb = enetc_map_rx_buff_to_skb(rx_ring, i, size);
 		if (!skb)
 			break;
-
 		enetc_get_offloads(rx_ring, rxbd, skb);
 
 		cleaned_cnt++;
@@ -693,9 +739,7 @@ static int enetc_clean_rx_ring(struct enetc_bdr *rx_ring,
 				dma_rmb();
 				size = le16_to_cpu(rxbd->r.buf_len);
 			}
-
 			enetc_add_rx_buff_to_skb(rx_ring, i, size, skb);
-
 			cleaned_cnt++;
 			rxbd++;
 			i++;
@@ -705,12 +749,16 @@ static int enetc_clean_rx_ring(struct enetc_bdr *rx_ring,
 			}
 		}
 
+		
 		rx_byte_cnt += skb->len;
-
-		enetc_process_skb(rx_ring, skb);
-
-		napi_gro_receive(napi, skb);
-
+		if (priv->ecdev) {
+			ecdev_receive(priv->ecdev, skb->data, size);
+			dev_kfree_skb(skb);
+		}
+		else {
+			enetc_process_skb(rx_ring, skb);
+			napi_gro_receive(napi, skb);
+		}
 		rx_frm_cnt++;
 	}
 
@@ -1239,12 +1287,14 @@ static int enetc_setup_irqs(struct enetc_ndev_priv *priv)
 
 		snprintf(v->name, sizeof(v->name), "%s-rxtx%d",
 			 priv->ndev->name, i);
-		err = request_irq(irq, enetc_msix, 0, v->name, v);
-		if (err) {
-			dev_err(priv->dev, "request_irq() failed!\n");
-			goto irq_err;
-		}
 
+		if (!priv->ecdev) {
+			err = request_irq(irq, enetc_msix, 0, v->name, v);
+			if (err) {
+				dev_err(priv->dev, "request_irq() failed!\n");
+				goto irq_err;
+			}
+		}
 		v->tbier_base = hw->reg + ENETC_BDR(TX, 0, ENETC_TBIER);
 		v->rbier = hw->reg + ENETC_BDR(RX, i, ENETC_RBIER);
 
@@ -1282,7 +1332,9 @@ static void enetc_free_irqs(struct enetc_ndev_priv *priv)
 		int irq = pci_irq_vector(pdev, ENETC_BDR_INT_BASE_IDX + i);
 
 		irq_set_affinity_hint(irq, NULL);
-		free_irq(irq, priv->int_vector[i]);
+		if (!priv->ecdev) {
+			free_irq(irq, priv->int_vector[i]);
+		}
 	}
 }
 
@@ -1371,17 +1423,22 @@ int enetc_open(struct net_device *ndev)
 	if (err)
 		goto err_set_queues;
 
-	for (i = 0; i < priv->bdr_int_num; i++)
-		napi_enable(&priv->int_vector[i]->napi);
-
-	enetc_enable_interrupts(priv);
+	if (!priv->ecdev) {
+		for (i = 0; i < priv->bdr_int_num; i++)
+			napi_enable(&priv->int_vector[i]->napi);
+		enetc_enable_interrupts(priv);
+	}
 
 	if (ndev->phydev)
 		phy_start(ndev->phydev);
 	else
-		netif_carrier_on(ndev);
+		if (!priv->ecdev) {
+			netif_carrier_off(ndev);
+		}
 
-	netif_tx_start_all_queues(ndev);
+	if (!priv->ecdev) {
+		netif_tx_start_all_queues(ndev);
+	}
 
 	return 0;
 
@@ -1403,21 +1460,27 @@ int enetc_close(struct net_device *ndev)
 	struct enetc_ndev_priv *priv = netdev_priv(ndev);
 	int i;
 
-	netif_tx_stop_all_queues(ndev);
+	if (!priv->ecdev) {
+		netif_tx_stop_all_queues(ndev);
+	}
 
 	if (ndev->phydev) {
 		phy_stop(ndev->phydev);
 		phy_disconnect(ndev->phydev);
 	} else {
-		netif_carrier_off(ndev);
+		if (!priv->ecdev) {
+			netif_carrier_off(ndev);
+		}
 	}
 
-	for (i = 0; i < priv->bdr_int_num; i++) {
-		napi_synchronize(&priv->int_vector[i]->napi);
-		napi_disable(&priv->int_vector[i]->napi);
-	}
+	if (!priv->ecdev) {
+		for (i = 0; i < priv->bdr_int_num; i++) {
+			napi_synchronize(&priv->int_vector[i]->napi);
+			napi_disable(&priv->int_vector[i]->napi);
+		}
 
-	enetc_disable_interrupts(priv);
+		enetc_disable_interrupts(priv);
+	}
 	enetc_clear_bdrs(priv);
 
 	enetc_free_rxtx_rings(priv);
diff --git a/devices/enetc/enetc.h b/devices/enetc/enetc.h
index 9899b61..1ade9e7 100644
--- a/devices/enetc/enetc.h
+++ b/devices/enetc/enetc.h
@@ -13,7 +13,7 @@
 #include <net/tsn.h>
 
 #include "enetc_hw.h"
-
+#include "../ecdev.h"
 #define ENETC_MAC_MAXFRM_SIZE	9600
 #define ENETC_MAX_MTU		(ENETC_MAC_MAXFRM_SIZE - \
 				(ETH_FCS_LEN + ETH_HLEN + VLAN_HLEN))
@@ -223,6 +223,7 @@ struct enetc_ndev_priv {
 	struct enetc_bdr *rx_ring[16];
 
 	struct enetc_cls_rule *cls_rules;
+	ec_device_t *ecdev;
 
 	struct device_node *phy_node;
 	phy_interface_t if_mode;
@@ -257,6 +258,7 @@ struct net_device_stats *enetc_get_stats(struct net_device *ndev);
 int enetc_ioctl(struct net_device *dev, struct ifreq *rq, int cmd);
 int enetc_set_features(struct net_device *ndev,
 		       netdev_features_t features);
+void ec_poll(struct net_device *ndev);
 /* ethtool */
 void enetc_set_ethtool_ops(struct net_device *ndev);
 
diff --git a/devices/enetc/enetc_mdio.c b/devices/enetc/enetc_mdio.c
deleted file mode 100644
index f715487..0000000
--- a/devices/enetc/enetc_mdio.c
+++ /dev/null
@@ -1,199 +0,0 @@
-// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
-/* Copyright 2019 NXP */
-
-#include <linux/mdio.h>
-#include <linux/of_mdio.h>
-#include <linux/iopoll.h>
-#include <linux/of.h>
-
-#include "enetc_pf.h"
-
-struct enetc_mdio_regs {
-	u32	mdio_cfg;	/* MDIO configuration and status */
-	u32	mdio_ctl;	/* MDIO control */
-	u32	mdio_data;	/* MDIO data */
-	u32	mdio_addr;	/* MDIO address */
-};
-
-#define bus_to_enetc_regs(bus)	(struct enetc_mdio_regs __iomem *)((bus)->priv)
-
-#define ENETC_MDIO_REG_OFFSET	0x1c00
-#define ENETC_MDC_DIV		258
-
-#define MDIO_CFG_CLKDIV(x)	((((x) >> 1) & 0xff) << 8)
-#define MDIO_CFG_BSY		BIT(0)
-#define MDIO_CFG_RD_ER		BIT(1)
-#define MDIO_CFG_ENC45		BIT(6)
- /* external MDIO only - driven on neg MDC edge */
-#define MDIO_CFG_NEG		BIT(23)
-
-#define MDIO_CTL_DEV_ADDR(x)	((x) & 0x1f)
-#define MDIO_CTL_PORT_ADDR(x)	(((x) & 0x1f) << 5)
-#define MDIO_CTL_READ		BIT(15)
-#define MDIO_DATA(x)		((x) & 0xffff)
-
-#define TIMEOUT	1000
-static int enetc_mdio_wait_complete(struct enetc_mdio_regs __iomem *regs)
-{
-	u32 val;
-
-	return readx_poll_timeout(enetc_rd_reg, &regs->mdio_cfg, val,
-				  !(val & MDIO_CFG_BSY), 10, 10 * TIMEOUT);
-}
-
-static int enetc_mdio_write(struct mii_bus *bus, int phy_id, int regnum,
-			    u16 value)
-{
-	struct enetc_mdio_regs __iomem *regs = bus_to_enetc_regs(bus);
-	u32 mdio_ctl, mdio_cfg;
-	u16 dev_addr;
-	int ret;
-
-	mdio_cfg = MDIO_CFG_CLKDIV(ENETC_MDC_DIV) | MDIO_CFG_NEG;
-	if (regnum & MII_ADDR_C45) {
-		dev_addr = (regnum >> 16) & 0x1f;
-		mdio_cfg |= MDIO_CFG_ENC45;
-	} else {
-		/* clause 22 (ie 1G) */
-		dev_addr = regnum & 0x1f;
-		mdio_cfg &= ~MDIO_CFG_ENC45;
-	}
-
-	enetc_wr_reg(&regs->mdio_cfg, mdio_cfg);
-
-	ret = enetc_mdio_wait_complete(regs);
-	if (ret)
-		return ret;
-
-	/* set port and dev addr */
-	mdio_ctl = MDIO_CTL_PORT_ADDR(phy_id) | MDIO_CTL_DEV_ADDR(dev_addr);
-	enetc_wr_reg(&regs->mdio_ctl, mdio_ctl);
-
-	/* set the register address */
-	if (regnum & MII_ADDR_C45) {
-		enetc_wr_reg(&regs->mdio_addr, regnum & 0xffff);
-
-		ret = enetc_mdio_wait_complete(regs);
-		if (ret)
-			return ret;
-	}
-
-	/* write the value */
-	enetc_wr_reg(&regs->mdio_data, MDIO_DATA(value));
-
-	ret = enetc_mdio_wait_complete(regs);
-	if (ret)
-		return ret;
-
-	return 0;
-}
-
-static int enetc_mdio_read(struct mii_bus *bus, int phy_id, int regnum)
-{
-	struct enetc_mdio_regs __iomem *regs = bus_to_enetc_regs(bus);
-	u32 mdio_ctl, mdio_cfg;
-	u16 dev_addr, value;
-	int ret;
-
-	mdio_cfg = MDIO_CFG_CLKDIV(ENETC_MDC_DIV) | MDIO_CFG_NEG;
-	if (regnum & MII_ADDR_C45) {
-		dev_addr = (regnum >> 16) & 0x1f;
-		mdio_cfg |= MDIO_CFG_ENC45;
-	} else {
-		dev_addr = regnum & 0x1f;
-		mdio_cfg &= ~MDIO_CFG_ENC45;
-	}
-
-	enetc_wr_reg(&regs->mdio_cfg, mdio_cfg);
-
-	ret = enetc_mdio_wait_complete(regs);
-	if (ret)
-		return ret;
-
-	/* set port and device addr */
-	mdio_ctl = MDIO_CTL_PORT_ADDR(phy_id) | MDIO_CTL_DEV_ADDR(dev_addr);
-	enetc_wr_reg(&regs->mdio_ctl, mdio_ctl);
-
-	/* set the register address */
-	if (regnum & MII_ADDR_C45) {
-		enetc_wr_reg(&regs->mdio_addr, regnum & 0xffff);
-
-		ret = enetc_mdio_wait_complete(regs);
-		if (ret)
-			return ret;
-	}
-
-	/* initiate the read */
-	enetc_wr_reg(&regs->mdio_ctl, mdio_ctl | MDIO_CTL_READ);
-
-	ret = enetc_mdio_wait_complete(regs);
-	if (ret)
-		return ret;
-
-	/* return all Fs if nothing was there */
-	if (enetc_rd_reg(&regs->mdio_cfg) & MDIO_CFG_RD_ER) {
-		dev_err(&bus->dev,
-			"Error while reading PHY%d reg at %d.%hhu\n",
-			phy_id, dev_addr, regnum);
-		return 0xffff;
-	}
-
-	value = enetc_rd_reg(&regs->mdio_data) & 0xffff;
-
-	return value;
-}
-
-int enetc_mdio_probe(struct enetc_pf *pf)
-{
-	struct device *dev = &pf->si->pdev->dev;
-	struct enetc_mdio_regs __iomem *regs;
-	struct device_node *np;
-	struct mii_bus *bus;
-	int ret;
-
-	bus = mdiobus_alloc_size(sizeof(regs));
-	if (!bus)
-		return -ENOMEM;
-
-	bus->name = "Freescale ENETC MDIO Bus";
-	bus->read = enetc_mdio_read;
-	bus->write = enetc_mdio_write;
-	bus->parent = dev;
-	snprintf(bus->id, MII_BUS_ID_SIZE, "%s", dev_name(dev));
-
-	/* store the enetc mdio base address for this bus */
-	regs = pf->si->hw.port + ENETC_MDIO_REG_OFFSET;
-	bus->priv = regs;
-
-	np = of_get_child_by_name(dev->of_node, "mdio");
-	if (!np) {
-		dev_err(dev, "MDIO node missing\n");
-		ret = -EINVAL;
-		goto err_registration;
-	}
-
-	ret = of_mdiobus_register(bus, np);
-	if (ret) {
-		of_node_put(np);
-		dev_err(dev, "cannot register MDIO bus\n");
-		goto err_registration;
-	}
-
-	of_node_put(np);
-	pf->mdio = bus;
-
-	return 0;
-
-err_registration:
-	mdiobus_free(bus);
-
-	return ret;
-}
-
-void enetc_mdio_remove(struct enetc_pf *pf)
-{
-	if (pf->mdio) {
-		mdiobus_unregister(pf->mdio);
-		mdiobus_free(pf->mdio);
-	}
-}
diff --git a/devices/enetc/enetc_msg.c b/devices/enetc/enetc_msg.c
deleted file mode 100644
index 6c01081..0000000
--- a/devices/enetc/enetc_msg.c
+++ /dev/null
@@ -1,164 +0,0 @@
-// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
-/* Copyright 2017-2019 NXP */
-
-#include "enetc_pf.h"
-
-static void enetc_msg_disable_mr_int(struct enetc_hw *hw)
-{
-	u32 psiier = enetc_rd(hw, ENETC_PSIIER);
-	/* disable MR int source(s) */
-	enetc_wr(hw, ENETC_PSIIER, psiier & ~ENETC_PSIIER_MR_MASK);
-}
-
-static void enetc_msg_enable_mr_int(struct enetc_hw *hw)
-{
-	u32 psiier = enetc_rd(hw, ENETC_PSIIER);
-
-	enetc_wr(hw, ENETC_PSIIER, psiier | ENETC_PSIIER_MR_MASK);
-}
-
-static irqreturn_t enetc_msg_psi_msix(int irq, void *data)
-{
-	struct enetc_si *si = (struct enetc_si *)data;
-	struct enetc_pf *pf = enetc_si_priv(si);
-
-	enetc_msg_disable_mr_int(&si->hw);
-	schedule_work(&pf->msg_task);
-
-	return IRQ_HANDLED;
-}
-
-static void enetc_msg_task(struct work_struct *work)
-{
-	struct enetc_pf *pf = container_of(work, struct enetc_pf, msg_task);
-	struct enetc_hw *hw = &pf->si->hw;
-	unsigned long mr_mask;
-	int i;
-
-	for (;;) {
-		mr_mask = enetc_rd(hw, ENETC_PSIMSGRR) & ENETC_PSIMSGRR_MR_MASK;
-		if (!mr_mask) {
-			/* re-arm MR interrupts, w1c the IDR reg */
-			enetc_wr(hw, ENETC_PSIIDR, ENETC_PSIIER_MR_MASK);
-			enetc_msg_enable_mr_int(hw);
-			return;
-		}
-
-		for (i = 0; i < pf->num_vfs; i++) {
-			u32 psimsgrr;
-			u16 msg_code;
-
-			if (!(ENETC_PSIMSGRR_MR(i) & mr_mask))
-				continue;
-
-			enetc_msg_handle_rxmsg(pf, i, &msg_code);
-
-			psimsgrr = ENETC_SIMSGSR_SET_MC(msg_code);
-			psimsgrr |= ENETC_PSIMSGRR_MR(i); /* w1c */
-			enetc_wr(hw, ENETC_PSIMSGRR, psimsgrr);
-		}
-	}
-}
-
-/* Init */
-static int enetc_msg_alloc_mbx(struct enetc_si *si, int idx)
-{
-	struct enetc_pf *pf = enetc_si_priv(si);
-	struct device *dev = &si->pdev->dev;
-	struct enetc_hw *hw = &si->hw;
-	struct enetc_msg_swbd *msg;
-	u32 val;
-
-	msg = &pf->rxmsg[idx];
-	/* allocate and set receive buffer */
-	msg->size = ENETC_DEFAULT_MSG_SIZE;
-
-	msg->vaddr = dma_zalloc_coherent(dev, msg->size, &msg->dma,
-					 GFP_KERNEL);
-	if (!msg->vaddr) {
-		dev_err(dev, "msg: fail to alloc dma buffer of size: %d\n",
-			msg->size);
-		return -ENOMEM;
-	}
-
-	/* set multiple of 32 bytes */
-	val = lower_32_bits(msg->dma);
-	enetc_wr(hw, ENETC_PSIVMSGRCVAR0(idx), val);
-	val = upper_32_bits(msg->dma);
-	enetc_wr(hw, ENETC_PSIVMSGRCVAR1(idx), val);
-
-	return 0;
-}
-
-static void enetc_msg_free_mbx(struct enetc_si *si, int idx)
-{
-	struct enetc_pf *pf = enetc_si_priv(si);
-	struct enetc_hw *hw = &si->hw;
-	struct enetc_msg_swbd *msg;
-
-	msg = &pf->rxmsg[idx];
-	dma_free_coherent(&si->pdev->dev, msg->size, msg->vaddr, msg->dma);
-	memset(msg, 0, sizeof(*msg));
-
-	enetc_wr(hw, ENETC_PSIVMSGRCVAR0(idx), 0);
-	enetc_wr(hw, ENETC_PSIVMSGRCVAR1(idx), 0);
-}
-
-int enetc_msg_psi_init(struct enetc_pf *pf)
-{
-	struct enetc_si *si = pf->si;
-	int vector, i, err;
-
-	/* register message passing interrupt handler */
-	snprintf(pf->msg_int_name, sizeof(pf->msg_int_name), "%s-vfmsg",
-		 si->ndev->name);
-	vector = pci_irq_vector(si->pdev, ENETC_SI_INT_IDX);
-	err = request_irq(vector, enetc_msg_psi_msix, 0, pf->msg_int_name, si);
-	if (err) {
-		dev_err(&si->pdev->dev,
-			"PSI messaging: request_irq() failed!\n");
-		return err;
-	}
-
-	/* set one IRQ entry for PSI message receive notification (SI int) */
-	enetc_wr(&si->hw, ENETC_SIMSIVR, ENETC_SI_INT_IDX);
-
-	/* initialize PSI mailbox */
-	INIT_WORK(&pf->msg_task, enetc_msg_task);
-
-	for (i = 0; i < pf->num_vfs; i++) {
-		err = enetc_msg_alloc_mbx(si, i);
-		if (err)
-			goto err_init_mbx;
-	}
-
-	/* enable MR interrupts */
-	enetc_msg_enable_mr_int(&si->hw);
-
-	return 0;
-
-err_init_mbx:
-	for (i--; i >= 0; i--)
-		enetc_msg_free_mbx(si, i);
-
-	free_irq(vector, si);
-
-	return err;
-}
-
-void enetc_msg_psi_free(struct enetc_pf *pf)
-{
-	struct enetc_si *si = pf->si;
-	int i;
-
-	cancel_work_sync(&pf->msg_task);
-
-	/* disable MR interrupts */
-	enetc_msg_disable_mr_int(&si->hw);
-
-	for (i = 0; i < pf->num_vfs; i++)
-		enetc_msg_free_mbx(si, i);
-
-	/* de-register message passing interrupt handler */
-	free_irq(pci_irq_vector(si->pdev, ENETC_SI_INT_IDX), si);
-}
diff --git a/devices/enetc/enetc_pf.c b/devices/enetc/enetc_pf.c
deleted file mode 100644
index 8e2995d..0000000
--- a/devices/enetc/enetc_pf.c
+++ /dev/null
@@ -1,956 +0,0 @@
-// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
-/* Copyright 2017-2019 NXP */
-
-#include <linux/module.h>
-#include <linux/of_mdio.h>
-#include <linux/of_net.h>
-#include "enetc_pf.h"
-
-#define ENETC_DRV_VER_MAJ 0
-#define ENETC_DRV_VER_MIN 9
-
-#define ENETC_DRV_VER_STR __stringify(ENETC_DRV_VER_MAJ) "." \
-			  __stringify(ENETC_DRV_VER_MIN)
-static const char enetc_drv_ver[] = ENETC_DRV_VER_STR;
-#define ENETC_DRV_NAME_STR "ENETC PF driver"
-static const char enetc_drv_name[] = ENETC_DRV_NAME_STR;
-
-static void enetc_pf_get_primary_mac_addr(struct enetc_hw *hw, int si, u8 *addr)
-{
-	u32 upper = __raw_readl(hw->port + ENETC_PSIPMAR0(si));
-	u16 lower = __raw_readw(hw->port + ENETC_PSIPMAR1(si));
-
-	*(u32 *)addr = upper;
-	*(u16 *)(addr + 4) = lower;
-}
-
-static void enetc_pf_set_primary_mac_addr(struct enetc_hw *hw, int si,
-					  const u8 *addr)
-{
-	u32 upper = *(const u32 *)addr;
-	u16 lower = *(const u16 *)(addr + 4);
-
-	__raw_writel(upper, hw->port + ENETC_PSIPMAR0(si));
-	__raw_writew(lower, hw->port + ENETC_PSIPMAR1(si));
-}
-
-static int enetc_pf_set_mac_addr(struct net_device *ndev, void *addr)
-{
-	struct enetc_ndev_priv *priv = netdev_priv(ndev);
-	struct sockaddr *saddr = addr;
-
-	if (!is_valid_ether_addr(saddr->sa_data))
-		return -EADDRNOTAVAIL;
-
-	memcpy(ndev->dev_addr, saddr->sa_data, ndev->addr_len);
-	enetc_pf_set_primary_mac_addr(&priv->si->hw, 0, saddr->sa_data);
-
-	return 0;
-}
-
-static void enetc_set_vlan_promisc(struct enetc_hw *hw, char si_map)
-{
-	u32 val = enetc_port_rd(hw, ENETC_PSIPVMR);
-
-	val &= ~ENETC_PSIPVMR_SET_VP(ENETC_VLAN_PROMISC_MAP_ALL);
-	enetc_port_wr(hw, ENETC_PSIPVMR, ENETC_PSIPVMR_SET_VP(si_map) | val);
-}
-
-static bool enetc_si_vlan_promisc_is_on(struct enetc_pf *pf, int si_idx)
-{
-	return pf->vlan_promisc_simap & BIT(si_idx);
-}
-
-static bool enetc_vlan_filter_is_on(struct enetc_pf *pf)
-{
-	int i;
-
-	for_each_set_bit(i, pf->active_vlans, VLAN_N_VID)
-		return true;
-
-	return false;
-}
-
-static void enetc_enable_si_vlan_promisc(struct enetc_pf *pf, int si_idx)
-{
-	pf->vlan_promisc_simap |= BIT(si_idx);
-	enetc_set_vlan_promisc(&pf->si->hw, pf->vlan_promisc_simap);
-}
-
-static void enetc_disable_si_vlan_promisc(struct enetc_pf *pf, int si_idx)
-{
-	pf->vlan_promisc_simap &= ~BIT(si_idx);
-	enetc_set_vlan_promisc(&pf->si->hw, pf->vlan_promisc_simap);
-}
-
-static void enetc_set_isol_vlan(struct enetc_hw *hw, int si, u16 vlan, u8 qos)
-{
-	u32 val = 0;
-
-	if (vlan)
-		val = ENETC_PSIVLAN_EN | ENETC_PSIVLAN_SET_QOS(qos) | vlan;
-
-	enetc_port_wr(hw, ENETC_PSIVLANR(si), val);
-}
-
-static int enetc_mac_addr_hash_idx(const u8 *addr)
-{
-	u64 fold = __swab64(ether_addr_to_u64(addr)) >> 16;
-	u64 mask = 0;
-	int res = 0;
-	int i;
-
-	for (i = 0; i < 8; i++)
-		mask |= BIT_ULL(i * 6);
-
-	for (i = 0; i < 6; i++)
-		res |= (hweight64(fold & (mask << i)) & 0x1) << i;
-
-	return res;
-}
-
-static void enetc_reset_mac_addr_filter(struct enetc_mac_filter *filter)
-{
-	filter->mac_addr_cnt = 0;
-
-	bitmap_zero(filter->mac_hash_table,
-		    ENETC_MADDR_HASH_TBL_SZ);
-}
-
-static void enetc_add_mac_addr_em_filter(struct enetc_mac_filter *filter,
-					 const unsigned char *addr)
-{
-	/* add exact match addr */
-	ether_addr_copy(filter->mac_addr, addr);
-	filter->mac_addr_cnt++;
-}
-
-static void enetc_add_mac_addr_ht_filter(struct enetc_mac_filter *filter,
-					 const unsigned char *addr)
-{
-	int idx = enetc_mac_addr_hash_idx(addr);
-
-	/* add hash table entry */
-	__set_bit(idx, filter->mac_hash_table);
-	filter->mac_addr_cnt++;
-}
-
-static void enetc_clear_mac_ht_flt(struct enetc_si *si, int si_idx, int type)
-{
-	bool err = si->errata & ENETC_ERR_UCMCSWP;
-
-	if (type == UC) {
-		enetc_port_wr(&si->hw, ENETC_PSIUMHFR0(si_idx, err), 0);
-		enetc_port_wr(&si->hw, ENETC_PSIUMHFR1(si_idx), 0);
-	} else { /* MC */
-		enetc_port_wr(&si->hw, ENETC_PSIMMHFR0(si_idx, err), 0);
-		enetc_port_wr(&si->hw, ENETC_PSIMMHFR1(si_idx), 0);
-	}
-}
-
-static void enetc_set_mac_ht_flt(struct enetc_si *si, int si_idx, int type,
-				 u32 *hash)
-{
-	bool err = si->errata & ENETC_ERR_UCMCSWP;
-
-	if (type == UC) {
-		enetc_port_wr(&si->hw, ENETC_PSIUMHFR0(si_idx, err), *hash);
-		enetc_port_wr(&si->hw, ENETC_PSIUMHFR1(si_idx), *(hash + 1));
-	} else { /* MC */
-		enetc_port_wr(&si->hw, ENETC_PSIMMHFR0(si_idx, err), *hash);
-		enetc_port_wr(&si->hw, ENETC_PSIMMHFR1(si_idx), *(hash + 1));
-	}
-}
-
-static void enetc_sync_mac_filters(struct enetc_pf *pf)
-{
-	struct enetc_mac_filter *f = pf->mac_filter;
-	struct enetc_si *si = pf->si;
-	int i, pos;
-
-	pos = EMETC_MAC_ADDR_FILT_RES;
-
-	for (i = 0; i < MADDR_TYPE; i++, f++) {
-		bool em = (f->mac_addr_cnt == 1) && (i == UC);
-		bool clear = !f->mac_addr_cnt;
-
-		if (clear) {
-			if (i == UC)
-				enetc_clear_mac_flt_entry(si, pos);
-
-			enetc_clear_mac_ht_flt(si, 0, i);
-			continue;
-		}
-
-		/* exact match filter */
-		if (em) {
-			int err;
-
-			enetc_clear_mac_ht_flt(si, 0, UC);
-
-			err = enetc_set_mac_flt_entry(si, pos, f->mac_addr,
-						      BIT(0));
-			if (!err)
-				continue;
-
-			/* fallback to HT filtering */
-			dev_warn(&si->pdev->dev, "fallback to HT filt (%d)\n",
-				 err);
-		}
-
-		/* hash table filter, clear EM filter for UC entries */
-		if (i == UC)
-			enetc_clear_mac_flt_entry(si, pos);
-
-		enetc_set_mac_ht_flt(si, 0, i, (u32 *)f->mac_hash_table);
-	}
-}
-
-static void enetc_pf_set_rx_mode(struct net_device *ndev)
-{
-	struct enetc_ndev_priv *priv = netdev_priv(ndev);
-	struct enetc_pf *pf = enetc_si_priv(priv->si);
-	struct enetc_hw *hw = &priv->si->hw;
-	bool uprom = false, mprom = false;
-	struct enetc_mac_filter *filter;
-	struct netdev_hw_addr *ha;
-	u32 psipmr = 0;
-	bool em;
-
-	if (ndev->flags & IFF_PROMISC) {
-		/* enable promisc mode for SI0 (PF) */
-		psipmr = ENETC_PSIPMR_SET_UP(0) | ENETC_PSIPMR_SET_MP(0);
-		uprom = true;
-		mprom = true;
-		/* enable VLAN promisc mode for SI0 */
-		if (!enetc_si_vlan_promisc_is_on(pf, 0))
-			enetc_enable_si_vlan_promisc(pf, 0);
-
-	} else if (ndev->flags & IFF_ALLMULTI) {
-		/* enable multi cast promisc mode for SI0 (PF) */
-		psipmr = ENETC_PSIPMR_SET_MP(0);
-		mprom = true;
-	}
-
-	/* first 2 filter entries belong to PF */
-	if (!uprom) {
-		/* Update unicast filters */
-		filter = &pf->mac_filter[UC];
-		enetc_reset_mac_addr_filter(filter);
-
-		em = (netdev_uc_count(ndev) == 1);
-		netdev_for_each_uc_addr(ha, ndev) {
-			if (em) {
-				enetc_add_mac_addr_em_filter(filter, ha->addr);
-				break;
-			}
-
-			enetc_add_mac_addr_ht_filter(filter, ha->addr);
-		}
-	}
-
-	if (!mprom) {
-		/* Update multicast filters */
-		filter = &pf->mac_filter[MC];
-		enetc_reset_mac_addr_filter(filter);
-
-		netdev_for_each_mc_addr(ha, ndev) {
-			if (!is_multicast_ether_addr(ha->addr))
-				continue;
-
-			enetc_add_mac_addr_ht_filter(filter, ha->addr);
-		}
-	}
-
-	if (!uprom || !mprom)
-		/* update PF entries */
-		enetc_sync_mac_filters(pf);
-
-	psipmr |= enetc_port_rd(hw, ENETC_PSIPMR) &
-		  ~(ENETC_PSIPMR_SET_UP(0) | ENETC_PSIPMR_SET_MP(0));
-	enetc_port_wr(hw, ENETC_PSIPMR, psipmr);
-}
-
-static void enetc_set_vlan_ht_filter(struct enetc_hw *hw, int si_idx,
-				     u32 *hash)
-{
-	enetc_port_wr(hw, ENETC_PSIVHFR0(si_idx), *hash);
-	enetc_port_wr(hw, ENETC_PSIVHFR1(si_idx), *(hash + 1));
-}
-
-static int enetc_vid_hash_idx(unsigned int vid)
-{
-	int res = 0;
-	int i;
-
-	for (i = 0; i < 6; i++)
-		res |= (hweight8(vid & (BIT(i) | BIT(i + 6))) & 0x1) << i;
-
-	return res;
-}
-
-static void enetc_sync_vlan_ht_filter(struct enetc_pf *pf, bool rehash)
-{
-	int i;
-
-	if (rehash) {
-		bitmap_zero(pf->vlan_ht_filter, ENETC_VLAN_HT_SIZE);
-
-		for_each_set_bit(i, pf->active_vlans, VLAN_N_VID) {
-			int hidx = enetc_vid_hash_idx(i);
-
-			__set_bit(hidx, pf->vlan_ht_filter);
-		}
-	}
-
-	enetc_set_vlan_ht_filter(&pf->si->hw, 0, (u32 *)pf->vlan_ht_filter);
-}
-
-static int enetc_vlan_rx_add_vid(struct net_device *ndev, __be16 prot, u16 vid)
-{
-	struct enetc_ndev_priv *priv = netdev_priv(ndev);
-	struct enetc_pf *pf = enetc_si_priv(priv->si);
-	int idx;
-
-	if (enetc_si_vlan_promisc_is_on(pf, 0))
-		enetc_disable_si_vlan_promisc(pf, 0);
-
-	__set_bit(vid, pf->active_vlans);
-
-	idx = enetc_vid_hash_idx(vid);
-	if (!__test_and_set_bit(idx, pf->vlan_ht_filter))
-		enetc_sync_vlan_ht_filter(pf, false);
-
-	return 0;
-}
-
-static int enetc_vlan_rx_del_vid(struct net_device *ndev, __be16 prot, u16 vid)
-{
-	struct enetc_ndev_priv *priv = netdev_priv(ndev);
-	struct enetc_pf *pf = enetc_si_priv(priv->si);
-
-	__clear_bit(vid, pf->active_vlans);
-	enetc_sync_vlan_ht_filter(pf, true);
-
-	if (!enetc_vlan_filter_is_on(pf))
-		enetc_enable_si_vlan_promisc(pf, 0);
-
-	return 0;
-}
-
-static void enetc_set_loopback(struct net_device *ndev, bool en)
-{
-	struct enetc_ndev_priv *priv = netdev_priv(ndev);
-	struct enetc_hw *hw = &priv->si->hw;
-	u32 reg;
-
-	reg = enetc_port_rd(hw, ENETC_PM0_IF_MODE);
-	if (reg & ENETC_PMO_IFM_RG) {
-		/* RGMII mode */
-		reg = (reg & ~ENETC_PM0_IFM_RLP) |
-		      (en ? ENETC_PM0_IFM_RLP : 0);
-		enetc_port_wr(hw, ENETC_PM0_IF_MODE, reg);
-	} else {
-		/* assume SGMII mode */
-		reg = enetc_port_rd(hw, ENETC_PM0_CMD_CFG);
-		reg = (reg & ~ENETC_PM0_CMD_XGLP) |
-		      (en ? ENETC_PM0_CMD_XGLP : 0);
-		reg = (reg & ~ENETC_PM0_CMD_PHY_TX_EN) |
-		      (en ? ENETC_PM0_CMD_PHY_TX_EN : 0);
-		enetc_port_wr(hw, ENETC_PM0_CMD_CFG, reg);
-		enetc_port_wr(hw, ENETC_PM1_CMD_CFG, reg);
-	}
-}
-
-static int enetc_pf_set_vf_mac(struct net_device *ndev, int vf, u8 *mac)
-{
-	struct enetc_ndev_priv *priv = netdev_priv(ndev);
-	struct enetc_pf *pf = enetc_si_priv(priv->si);
-	struct enetc_vf_state *vf_state;
-
-	if (vf >= pf->total_vfs)
-		return -EINVAL;
-
-	if (!is_valid_ether_addr(mac))
-		return -EADDRNOTAVAIL;
-
-	vf_state = &pf->vf_state[vf];
-	vf_state->flags |= ENETC_VF_FLAG_PF_SET_MAC;
-	enetc_pf_set_primary_mac_addr(&priv->si->hw, vf + 1, mac);
-	return 0;
-}
-
-static int enetc_pf_set_vf_vlan(struct net_device *ndev, int vf, u16 vlan,
-				u8 qos, __be16 proto)
-{
-	struct enetc_ndev_priv *priv = netdev_priv(ndev);
-	struct enetc_pf *pf = enetc_si_priv(priv->si);
-
-	if (priv->si->errata & ENETC_ERR_VLAN_ISOL)
-		return -EOPNOTSUPP;
-
-	if (vf >= pf->total_vfs)
-		return -EINVAL;
-
-	if (proto != htons(ETH_P_8021Q))
-		/* only C-tags supported for now */
-		return -EPROTONOSUPPORT;
-
-	enetc_set_isol_vlan(&priv->si->hw, vf + 1, vlan, qos);
-	return 0;
-}
-
-static int enetc_pf_set_vf_spoofchk(struct net_device *ndev, int vf, bool en)
-{
-	struct enetc_ndev_priv *priv = netdev_priv(ndev);
-	struct enetc_pf *pf = enetc_si_priv(priv->si);
-	u32 cfgr;
-
-	if (vf >= pf->total_vfs)
-		return -EINVAL;
-
-	cfgr = enetc_port_rd(&priv->si->hw, ENETC_PSICFGR0(vf + 1));
-	cfgr = (cfgr & ~ENETC_PSICFGR0_ASE) | (en ? ENETC_PSICFGR0_ASE : 0);
-	enetc_port_wr(&priv->si->hw, ENETC_PSICFGR0(vf + 1), cfgr);
-
-	return 0;
-}
-
-static void enetc_port_setup_primary_mac_address(struct enetc_si *si)
-{
-	unsigned char mac_addr[MAX_ADDR_LEN];
-	struct enetc_pf *pf = enetc_si_priv(si);
-	struct enetc_hw *hw = &si->hw;
-	int i;
-
-	/* check MAC addresses for PF and all VFs, if any is 0 set it ro rand */
-	for (i = 0; i < pf->total_vfs + 1; i++) {
-		enetc_pf_get_primary_mac_addr(hw, i, mac_addr);
-		if (!is_zero_ether_addr(mac_addr))
-			continue;
-		eth_random_addr(mac_addr);
-		dev_info(&si->pdev->dev, "no MAC address specified for SI%d, using %pM\n",
-			 i, mac_addr);
-		enetc_pf_set_primary_mac_addr(hw, i, mac_addr);
-	}
-}
-
-static void enetc_port_assign_rfs_entries(struct enetc_si *si)
-{
-	struct enetc_pf *pf = enetc_si_priv(si);
-	struct enetc_hw *hw = &si->hw;
-	int num_entries, vf_entries, i;
-	u32 val;
-
-	/* split RFS entries between functions */
-	val = enetc_port_rd(hw, ENETC_PRFSCAPR);
-	num_entries = ENETC_PRFSCAPR_GET_NUM_RFS(val);
-	vf_entries = num_entries / (pf->total_vfs + 1);
-
-	for (i = 0; i < pf->total_vfs; i++)
-		enetc_port_wr(hw, ENETC_PSIRFSCFGR(i + 1), vf_entries);
-	enetc_port_wr(hw, ENETC_PSIRFSCFGR(0),
-		      num_entries - vf_entries * pf->total_vfs);
-
-	/* enable RFS on port */
-	enetc_port_wr(hw, ENETC_PRFSMR, ENETC_PRFSMR_RFSE);
-}
-
-static void enetc_port_si_configure(struct enetc_si *si)
-{
-	struct enetc_pf *pf = enetc_si_priv(si);
-	struct enetc_hw *hw = &si->hw;
-	int num_rings, i;
-	u32 val;
-
-	val = enetc_port_rd(hw, ENETC_PCAPR0);
-	num_rings = min(ENETC_PCAPR0_RXBDR(val), ENETC_PCAPR0_TXBDR(val));
-
-	val = ENETC_PSICFGR0_SET_TXBDR(ENETC_PF_NUM_RINGS);
-	val |= ENETC_PSICFGR0_SET_RXBDR(ENETC_PF_NUM_RINGS);
-
-	if (unlikely(num_rings < ENETC_PF_NUM_RINGS)) {
-		val = ENETC_PSICFGR0_SET_TXBDR(num_rings);
-		val |= ENETC_PSICFGR0_SET_RXBDR(num_rings);
-
-		dev_warn(&si->pdev->dev, "Found %d rings, expected %d!\n",
-			 num_rings, ENETC_PF_NUM_RINGS);
-
-		num_rings = 0;
-	}
-
-	/* Add default one-time settings for SI0 (PF) */
-	val |= ENETC_PSICFGR0_SIVC(ENETC_VLAN_TYPE_C | ENETC_VLAN_TYPE_S);
-
-	enetc_port_wr(hw, ENETC_PSICFGR0(0), val);
-
-	if (num_rings)
-		num_rings -= ENETC_PF_NUM_RINGS;
-
-	/* Configure the SIs for each available VF */
-	val = ENETC_PSICFGR0_SIVC(ENETC_VLAN_TYPE_C | ENETC_VLAN_TYPE_S);
-	val |= ENETC_PSICFGR0_VTE | ENETC_PSICFGR0_SIVIE;
-
-	if (num_rings) {
-		num_rings /= pf->total_vfs;
-		val |= ENETC_PSICFGR0_SET_TXBDR(num_rings);
-		val |= ENETC_PSICFGR0_SET_RXBDR(num_rings);
-	}
-
-	for (i = 0; i < pf->total_vfs; i++)
-		enetc_port_wr(hw, ENETC_PSICFGR0(i + 1), val);
-
-	/* Port level VLAN settings */
-	val = ENETC_PVCLCTR_OVTPIDL(ENETC_VLAN_TYPE_C | ENETC_VLAN_TYPE_S);
-	enetc_port_wr(hw, ENETC_PVCLCTR, val);
-	/* use outer tag for VLAN filtering */
-	enetc_port_wr(hw, ENETC_PSIVLANFMR, ENETC_PSIVLANFMR_VS);
-}
-
-static void enetc_configure_port_mac(struct enetc_hw *hw)
-{
-	enetc_port_wr(hw, ENETC_PM0_MAXFRM,
-		      ENETC_SET_MAXFRM(ENETC_RX_MAXFRM_SIZE));
-
-	enetc_port_wr(hw, ENETC_PTCMSDUR(0), ENETC_MAC_MAXFRM_SIZE);
-	enetc_port_wr(hw, ENETC_PTXMBAR, 2 * ENETC_MAC_MAXFRM_SIZE);
-
-	enetc_port_wr(hw, ENETC_PM0_CMD_CFG, ENETC_PM0_CMD_PHY_TX_EN |
-		      ENETC_PM0_CMD_TXP	| ENETC_PM0_PROMISC |
-		      ENETC_PM0_TX_EN | ENETC_PM0_RX_EN);
-
-	enetc_port_wr(hw, ENETC_PM1_CMD_CFG, ENETC_PM0_CMD_PHY_TX_EN |
-		      ENETC_PM0_CMD_TXP	| ENETC_PM0_PROMISC |
-		      ENETC_PM0_TX_EN | ENETC_PM0_RX_EN);
-	/* set auto-speed for RGMII */
-	if (enetc_port_rd(hw, ENETC_PM0_IF_MODE) & ENETC_PMO_IFM_RG) {
-		enetc_port_wr(hw, ENETC_PM0_IF_MODE, ENETC_PM0_IFM_RGAUTO);
-		enetc_port_wr(hw, ENETC_PM1_IF_MODE, ENETC_PM0_IFM_RGAUTO);
-	}
-	if (enetc_global_rd(hw, ENETC_G_EPFBLPR(1)) == ENETC_G_EPFBLPR1_XGMII) {
-		enetc_port_wr(hw, ENETC_PM0_IF_MODE, ENETC_PM0_IFM_XGMII);
-		enetc_port_wr(hw, ENETC_PM1_IF_MODE, ENETC_PM0_IFM_XGMII);
-	}
-}
-
-static void enetc_configure_port_pmac(struct enetc_hw *hw)
-{
-	u32 temp;
-
-	/* Set pMAC step lock */
-	temp = enetc_port_rd(hw, ENETC_PFPMR);
-	enetc_port_wr(hw, ENETC_PFPMR,
-		      temp | ENETC_PFPMR_PMACE | ENETC_PFPMR_MWLM);
-
-	temp = enetc_port_rd(hw, ENETC_MMCSR);
-	enetc_port_wr(hw, ENETC_MMCSR, temp | ENETC_MMCSR_ME);
-}
-
-static void enetc_configure_port(struct enetc_pf *pf)
-{
-	u8 hash_key[ENETC_RSSHASH_KEY_SIZE];
-	struct enetc_hw *hw = &pf->si->hw;
-
-	enetc_configure_port_pmac(hw);
-
-	enetc_configure_port_mac(hw);
-
-	enetc_port_si_configure(pf->si);
-
-	/* set up hash key */
-	get_random_bytes(hash_key, ENETC_RSSHASH_KEY_SIZE);
-	enetc_set_rss_key(hw, hash_key);
-
-	/* split up RFS entries */
-	enetc_port_assign_rfs_entries(pf->si);
-
-	/* fix-up primary MAC addresses, if not set already */
-	enetc_port_setup_primary_mac_address(pf->si);
-
-	/* enforce VLAN promisc mode for all SIs */
-	pf->vlan_promisc_simap = ENETC_VLAN_PROMISC_MAP_ALL;
-	enetc_set_vlan_promisc(hw, pf->vlan_promisc_simap);
-
-	enetc_port_wr(hw, ENETC_PSIPMR, 0);
-
-	/* enable port */
-	enetc_port_wr(hw, ENETC_PMR, ENETC_PMR_EN);
-}
-
-/* Messaging */
-static u16 enetc_msg_pf_set_vf_primary_mac_addr(struct enetc_pf *pf,
-						int vf_id)
-{
-	struct enetc_vf_state *vf_state = &pf->vf_state[vf_id];
-	struct enetc_msg_swbd *msg = &pf->rxmsg[vf_id];
-	struct enetc_msg_cmd_set_primary_mac *cmd;
-	struct device *dev = &pf->si->pdev->dev;
-	u16 cmd_id;
-	char *addr;
-
-	cmd = (struct enetc_msg_cmd_set_primary_mac *)msg->vaddr;
-	cmd_id = cmd->header.id;
-	if (cmd_id != ENETC_MSG_CMD_MNG_ADD)
-		return ENETC_MSG_CMD_STATUS_FAIL;
-
-	addr = cmd->mac.sa_data;
-	if (vf_state->flags & ENETC_VF_FLAG_PF_SET_MAC)
-		dev_warn(dev, "Attempt to override PF set mac addr for VF%d\n",
-			 vf_id);
-	else
-		enetc_pf_set_primary_mac_addr(&pf->si->hw, vf_id + 1, addr);
-
-	return ENETC_MSG_CMD_STATUS_OK;
-}
-
-void enetc_msg_handle_rxmsg(struct enetc_pf *pf, int vf_id, u16 *status)
-{
-	struct enetc_msg_swbd *msg = &pf->rxmsg[vf_id];
-	struct device *dev = &pf->si->pdev->dev;
-	struct enetc_msg_cmd_header *cmd_hdr;
-	u16 cmd_type;
-
-	*status = ENETC_MSG_CMD_STATUS_OK;
-	cmd_hdr = (struct enetc_msg_cmd_header *)msg->vaddr;
-	cmd_type = cmd_hdr->type;
-
-	switch (cmd_type) {
-	case ENETC_MSG_CMD_MNG_MAC:
-		*status = enetc_msg_pf_set_vf_primary_mac_addr(pf, vf_id);
-		break;
-	default:
-		dev_err(dev, "command not supported (cmd_type: 0x%x)\n",
-			cmd_type);
-	}
-}
-
-#ifdef CONFIG_PCI_IOV
-static int enetc_sriov_configure(struct pci_dev *pdev, int num_vfs)
-{
-	struct enetc_si *si = pci_get_drvdata(pdev);
-	struct enetc_pf *pf = enetc_si_priv(si);
-	int err;
-
-	if (!num_vfs) {
-		enetc_msg_psi_free(pf);
-		kfree(pf->vf_state);
-		pf->num_vfs = 0;
-		pci_disable_sriov(pdev);
-	} else {
-		pf->num_vfs = num_vfs;
-
-		pf->vf_state = kcalloc(num_vfs, sizeof(struct enetc_vf_state),
-				       GFP_KERNEL);
-		if (!pf->vf_state) {
-			pf->num_vfs = 0;
-			return -ENOMEM;
-		}
-
-		err = enetc_msg_psi_init(pf);
-		if (err) {
-			dev_err(&pdev->dev, "enetc_msg_psi_init (%d)\n", err);
-			goto err_msg_psi;
-		}
-
-		err = pci_enable_sriov(pdev, num_vfs);
-		if (err) {
-			dev_err(&pdev->dev, "pci_enable_sriov err %d\n", err);
-			goto err_en_sriov;
-		}
-	}
-
-	return num_vfs;
-
-err_en_sriov:
-	enetc_msg_psi_free(pf);
-err_msg_psi:
-	kfree(pf->vf_state);
-	pf->num_vfs = 0;
-
-	return err;
-}
-#else
-#define enetc_sriov_configure(pdev, num_vfs)	(void)0
-#endif
-
-static int enetc_pf_set_features(struct net_device *ndev,
-				 netdev_features_t features)
-{
-	netdev_features_t changed = ndev->features ^ features;
-	struct enetc_ndev_priv *priv = netdev_priv(ndev);
-
-	if (changed & NETIF_F_HW_VLAN_CTAG_RX)
-		enetc_enable_rxvlan(&priv->si->hw, 0,
-				    !!(features & NETIF_F_HW_VLAN_CTAG_RX));
-
-	if (changed & NETIF_F_HW_VLAN_CTAG_TX)
-		enetc_enable_txvlan(&priv->si->hw, 0,
-				    !!(features & NETIF_F_HW_VLAN_CTAG_TX));
-
-	if (changed & NETIF_F_LOOPBACK)
-		enetc_set_loopback(ndev, !!(features & NETIF_F_LOOPBACK));
-
-	return enetc_set_features(ndev, features);
-}
-
-static const struct net_device_ops enetc_ndev_ops = {
-	.ndo_open		= enetc_open,
-	.ndo_stop		= enetc_close,
-	.ndo_setup_tc		= enetc_setup_tc,
-	.ndo_start_xmit		= enetc_xmit,
-	.ndo_get_stats		= enetc_get_stats,
-	.ndo_set_mac_address	= enetc_pf_set_mac_addr,
-	.ndo_set_rx_mode	= enetc_pf_set_rx_mode,
-	.ndo_vlan_rx_add_vid	= enetc_vlan_rx_add_vid,
-	.ndo_vlan_rx_kill_vid	= enetc_vlan_rx_del_vid,
-	.ndo_set_vf_mac		= enetc_pf_set_vf_mac,
-	.ndo_set_vf_vlan	= enetc_pf_set_vf_vlan,
-	.ndo_set_vf_spoofchk	= enetc_pf_set_vf_spoofchk,
-	.ndo_set_features	= enetc_pf_set_features,
-	.ndo_do_ioctl		= enetc_ioctl,
-};
-
-static void enetc_pf_netdev_setup(struct enetc_si *si, struct net_device *ndev,
-				  const struct net_device_ops *ndev_ops)
-{
-	struct enetc_ndev_priv *priv = netdev_priv(ndev);
-
-	SET_NETDEV_DEV(ndev, &si->pdev->dev);
-	priv->ndev = ndev;
-	priv->si = si;
-	priv->dev = &si->pdev->dev;
-	si->ndev = ndev;
-
-	priv->msg_enable = (NETIF_MSG_WOL << 1) - 1;
-	ndev->netdev_ops = ndev_ops;
-	enetc_set_ethtool_ops(ndev);
-	ndev->watchdog_timeo = 5 * HZ;
-	ndev->max_mtu = ENETC_MAX_MTU;
-
-	ndev->hw_features = NETIF_F_SG | NETIF_F_RXCSUM | NETIF_F_HW_CSUM |
-			    NETIF_F_HW_VLAN_CTAG_TX | NETIF_F_HW_VLAN_CTAG_RX |
-			    NETIF_F_LOOPBACK;
-	ndev->features = NETIF_F_HIGHDMA | NETIF_F_SG |
-			 NETIF_F_RXCSUM | NETIF_F_HW_CSUM |
-			 NETIF_F_HW_VLAN_CTAG_TX |
-			 NETIF_F_HW_VLAN_CTAG_RX |
-			 NETIF_F_HW_VLAN_CTAG_FILTER;
-
-	if (si->num_rss)
-		ndev->hw_features |= NETIF_F_RXHASH;
-
-	if (si->errata & ENETC_ERR_TXCSUM) {
-		ndev->hw_features &= ~NETIF_F_HW_CSUM;
-		ndev->features &= ~NETIF_F_HW_CSUM;
-	}
-
-	ndev->priv_flags |= IFF_UNICAST_FLT;
-
-	if (enetc_tsn_is_enabled() && (si->hw_features & ENETC_SI_F_QBV))
-		priv->hw_features |= ENETC_F_QBV;
-
-	/* pick up primary MAC address from SI */
-	enetc_get_primary_mac_addr(&si->hw, ndev->dev_addr);
-}
-
-static int enetc_of_get_phy(struct enetc_ndev_priv *priv)
-{
-	struct enetc_pf *pf = enetc_si_priv(priv->si);
-	struct device_node *np = priv->dev->of_node;
-	int err;
-
-	if (!np) {
-		dev_err(priv->dev, "missing ENETC port node\n");
-		return -ENODEV;
-	}
-
-	priv->phy_node = of_parse_phandle(np, "phy-handle", 0);
-	if (!priv->phy_node) {
-		if (!of_phy_is_fixed_link(np)) {
-			dev_err(priv->dev, "PHY not specified\n");
-			return -ENODEV;
-		}
-
-		err = of_phy_register_fixed_link(np);
-		if (err < 0) {
-			dev_err(priv->dev, "fixed link registration failed\n");
-			return err;
-		}
-
-		priv->phy_node = of_node_get(np);
-	}
-
-	if (!of_phy_is_fixed_link(np)) {
-		err = enetc_mdio_probe(pf);
-		if (err) {
-			of_node_put(priv->phy_node);
-			return err;
-		}
-	}
-
-	priv->if_mode = of_get_phy_mode(np);
-	if (priv->if_mode < 0) {
-		dev_err(priv->dev, "missing phy type\n");
-		of_node_put(priv->phy_node);
-		if (of_phy_is_fixed_link(np))
-			of_phy_deregister_fixed_link(np);
-		else
-			enetc_mdio_remove(pf);
-
-		return -EINVAL;
-	}
-
-	return 0;
-}
-
-static void enetc_of_put_phy(struct enetc_ndev_priv *priv)
-{
-	struct device_node *np = priv->dev->of_node;
-
-	if (np && of_phy_is_fixed_link(np))
-		of_phy_deregister_fixed_link(np);
-	if (priv->phy_node)
-		of_node_put(priv->phy_node);
-}
-
-static int enetc_pf_probe(struct pci_dev *pdev,
-			  const struct pci_device_id *ent)
-{
-	struct enetc_ndev_priv *priv;
-	struct net_device *ndev;
-	struct enetc_si *si;
-	struct enetc_pf *pf;
-	int err;
-
-	if (pdev->dev.of_node && !of_device_is_available(pdev->dev.of_node)) {
-		dev_info(&pdev->dev, "device is disabled, skipping\n");
-		return -ENODEV;
-	}
-
-	err = enetc_pci_probe(pdev, KBUILD_MODNAME, sizeof(*pf));
-	if (err) {
-		dev_err(&pdev->dev, "PCI probing failed\n");
-		return err;
-	}
-
-	si = pci_get_drvdata(pdev);
-	if (!si->hw.port || !si->hw.global) {
-		err = -ENODEV;
-		dev_err(&pdev->dev, "could not map PF space, probing a VF?\n");
-		goto err_map_pf_space;
-	}
-
-	pf = enetc_si_priv(si);
-	pf->si = si;
-	pf->total_vfs = pci_sriov_get_totalvfs(pdev);
-
-	enetc_configure_port(pf);
-
-	enetc_get_si_caps(si);
-
-	ndev = alloc_etherdev_mq(sizeof(*priv), ENETC_MAX_NUM_TXQS);
-	if (!ndev) {
-		err = -ENOMEM;
-		dev_err(&pdev->dev, "netdev creation failed\n");
-		goto err_alloc_netdev;
-	}
-
-	enetc_pf_netdev_setup(si, ndev, &enetc_ndev_ops);
-
-	priv = netdev_priv(ndev);
-
-	enetc_init_si_rings_params(priv);
-
-	err = enetc_alloc_si_resources(priv);
-	if (err) {
-		dev_err(&pdev->dev, "SI resource alloc failed\n");
-		goto err_alloc_si_res;
-	}
-
-	err = enetc_alloc_msix(priv);
-	if (err) {
-		dev_err(&pdev->dev, "MSIX alloc failed\n");
-		goto err_alloc_msix;
-	}
-
-	err = enetc_of_get_phy(priv);
-	if (err)
-		dev_warn(&pdev->dev, "Fallback to PHY-less operation\n");
-
-	err = register_netdev(ndev);
-	if (err)
-		goto err_reg_netdev;
-
-	netif_carrier_off(ndev);
-
-	netif_info(priv, probe, ndev, "%s v%s\n",
-		   enetc_drv_name, enetc_drv_ver);
-
-	enetc_tsn_pf_init(ndev, pdev);
-
-	return 0;
-
-err_reg_netdev:
-	enetc_of_put_phy(priv);
-	enetc_free_msix(priv);
-err_alloc_msix:
-	enetc_free_si_resources(priv);
-err_alloc_si_res:
-	si->ndev = NULL;
-	free_netdev(ndev);
-err_alloc_netdev:
-err_map_pf_space:
-	enetc_pci_remove(pdev);
-
-	return err;
-}
-
-static void enetc_pf_remove(struct pci_dev *pdev)
-{
-	struct enetc_si *si = pci_get_drvdata(pdev);
-	struct enetc_pf *pf = enetc_si_priv(si);
-	struct enetc_ndev_priv *priv;
-
-	if (pf->num_vfs)
-		enetc_sriov_configure(pdev, 0);
-
-	priv = netdev_priv(si->ndev);
-	netif_info(priv, drv, si->ndev, "%s v%s remove\n",
-		   enetc_drv_name, enetc_drv_ver);
-
-	enetc_tsn_pf_deinit(si->ndev);
-
-	unregister_netdev(si->ndev);
-
-	enetc_mdio_remove(pf);
-	enetc_of_put_phy(priv);
-
-	enetc_free_msix(priv);
-
-	enetc_free_si_resources(priv);
-
-	free_netdev(si->ndev);
-
-	enetc_pci_remove(pdev);
-}
-
-static const struct pci_device_id enetc_pf_id_table[] = {
-	{ PCI_DEVICE(PCI_VENDOR_ID_FREESCALE, ENETC_DEV_ID_PF) },
-	{ 0, } /* End of table. */
-};
-MODULE_DEVICE_TABLE(pci, enetc_pf_id_table);
-
-static struct pci_driver enetc_pf_driver = {
-	.name = KBUILD_MODNAME,
-	.id_table = enetc_pf_id_table,
-	.probe = enetc_pf_probe,
-	.remove = enetc_pf_remove,
-#ifdef CONFIG_PCI_IOV
-	.sriov_configure = enetc_sriov_configure,
-#endif
-};
-module_pci_driver(enetc_pf_driver);
-
-MODULE_DESCRIPTION(ENETC_DRV_NAME_STR);
-MODULE_LICENSE("Dual BSD/GPL");
-MODULE_VERSION(ENETC_DRV_VER_STR);
diff --git a/devices/enetc/enetc_pf.h b/devices/enetc/enetc_pf.h
deleted file mode 100644
index 10dd1b5..0000000
--- a/devices/enetc/enetc_pf.h
+++ /dev/null
@@ -1,55 +0,0 @@
-/* SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause) */
-/* Copyright 2017-2019 NXP */
-
-#include "enetc.h"
-
-#define ENETC_PF_NUM_RINGS	8
-
-enum enetc_mac_addr_type {UC, MC, MADDR_TYPE};
-#define ENETC_MAX_NUM_MAC_FLT	((ENETC_MAX_NUM_VFS + 1) * MADDR_TYPE)
-
-#define ENETC_MADDR_HASH_TBL_SZ	64
-struct enetc_mac_filter {
-	union {
-		char mac_addr[ETH_ALEN];
-		DECLARE_BITMAP(mac_hash_table, ENETC_MADDR_HASH_TBL_SZ);
-	};
-	int mac_addr_cnt;
-};
-
-#define ENETC_VLAN_HT_SIZE	64
-
-enum enetc_vf_flags {
-	ENETC_VF_FLAG_PF_SET_MAC	= BIT(0),
-};
-
-struct enetc_vf_state {
-	enum enetc_vf_flags flags;
-};
-
-struct enetc_pf {
-	struct enetc_si *si;
-	int num_vfs; /* number of active VFs, after sriov_init */
-	int total_vfs; /* max number of VFs, set for PF at probe */
-	struct enetc_vf_state *vf_state;
-
-	struct enetc_mac_filter mac_filter[ENETC_MAX_NUM_MAC_FLT];
-
-	struct enetc_msg_swbd rxmsg[ENETC_MAX_NUM_VFS];
-	struct work_struct msg_task;
-	char msg_int_name[ENETC_INT_NAME_MAX];
-
-	char vlan_promisc_simap; /* bitmap of SIs in VLAN promisc mode */
-	DECLARE_BITMAP(vlan_ht_filter, ENETC_VLAN_HT_SIZE);
-	DECLARE_BITMAP(active_vlans, VLAN_N_VID);
-
-	struct mii_bus *mdio; /* saved for cleanup */
-};
-
-int enetc_msg_psi_init(struct enetc_pf *pf);
-void enetc_msg_psi_free(struct enetc_pf *pf);
-void enetc_msg_handle_rxmsg(struct enetc_pf *pf, int mbox_id, u16 *status);
-
-/* MDIO */
-int enetc_mdio_probe(struct enetc_pf *pf);
-void enetc_mdio_remove(struct enetc_pf *pf);
diff --git a/devices/enetc/enetc_vf.c b/devices/enetc/enetc_vf.c
index f63501c..0402e18 100644
--- a/devices/enetc/enetc_vf.c
+++ b/devices/enetc/enetc_vf.c
@@ -3,6 +3,7 @@
 
 #include <linux/module.h>
 #include "enetc.h"
+#include "../ecdev.h"
 
 #define ENETC_DRV_VER_MAJ 0
 #define ENETC_DRV_VER_MIN 9
@@ -149,6 +150,13 @@ static void enetc_vf_netdev_setup(struct enetc_si *si, struct net_device *ndev,
 
 	/* pick up primary MAC address from SI */
 	enetc_get_primary_mac_addr(&si->hw, ndev->dev_addr);
+	printk("Mac address: %x:%x:%x:%x:%x:%x",
+		((unsigned char *)ndev->dev_addr)[0],
+		((unsigned char *)ndev->dev_addr)[1],
+		((unsigned char *)ndev->dev_addr)[2],
+		((unsigned char *)ndev->dev_addr)[3],
+		((unsigned char *)ndev->dev_addr)[4],
+		((unsigned char *)ndev->dev_addr)[5]);
 }
 
 static int enetc_vf_probe(struct pci_dev *pdev,
@@ -194,11 +202,21 @@ static int enetc_vf_probe(struct pci_dev *pdev,
 		goto err_alloc_msix;
 	}
 
-	err = register_netdev(ndev);
-	if (err)
-		goto err_reg_netdev;
+	priv->ecdev = ecdev_offer(ndev, ec_poll, THIS_MODULE);
+	if (!priv->ecdev) {
+		err = register_netdev(ndev);
+		if (err)
+			goto err_reg_netdev;
+	}
 
-	netif_carrier_off(ndev);
+	if (priv->ecdev) {
+		if (ecdev_open(priv->ecdev)) {
+			ecdev_withdraw(priv->ecdev);
+			goto err_reg_netdev;
+		}
+	} else {
+		netif_carrier_off(ndev);
+	}
 
 	netif_info(priv, probe, ndev, "%s v%s\n",
 		   enetc_drv_name, enetc_drv_ver);
@@ -226,8 +244,14 @@ static void enetc_vf_remove(struct pci_dev *pdev)
 	priv = netdev_priv(si->ndev);
 	netif_info(priv, drv, si->ndev, "%s v%s remove\n",
 		   enetc_drv_name, enetc_drv_ver);
-	unregister_netdev(si->ndev);
-
+	
+	if (priv->ecdev){
+		ecdev_close(priv->ecdev);
+		ecdev_withdraw(priv->ecdev);
+	}
+	else{
+		unregister_netdev(si->ndev);
+	}
 	enetc_free_msix(priv);
 
 	enetc_free_si_resources(priv);
-- 
2.25.1

