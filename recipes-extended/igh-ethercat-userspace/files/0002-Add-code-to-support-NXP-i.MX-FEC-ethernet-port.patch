From 7bade153986772a34e6a83ce0f3dfb491d695839 Mon Sep 17 00:00:00 2001
From: Hongbo Wang <hongbo.wang@nxp.com>
Date: Wed, 19 Mar 2025 18:52:52 +0800
Subject: [PATCH 2/2] Add code to support NXP i.MX FEC ethernet port

the verified platform: i.MX8MP, i.MX8MM and i.MX93

Readme_For_User_Space_IGH_EtherCAT.txt is document for this feature

compilation steps:
./bootstrap

local compile:
./configure --prefix=$PWD/ecat_build/ --enable-kernel=no --enable-usecat=yes --enable-8139too=no --enable-tool=yes --enable-eoe=no --build=arm

cross compile:
./configure --prefix=$PWD/ecat_build/ --enable-kernel=no --enable-usecat=yes --enable-8139too=no --enable-tool=yes --enable-eoe=no --host=aarch64-none-linux-gnu

make
make install

Signed-off-by: Lyrix Liu <lyrix.liu@nxp.com>
Signed-off-by: Hongbo Wang <hongbo.wang@nxp.com>
Upstream-Status: Pending
---
 .gitignore                             |   1 +
 Readme_For_User_Space_IGH_EtherCAT.txt | 264 +++++++++++
 compile.sh                             |  31 ++
 configure.ac                           |   3 +-
 devices/nxp_userspace/usm_main.c       | 309 +++++++++++++
 devices/nxp_userspace/usm_main.h       |  41 ++
 emulation/linux/jiffies.h              |  15 +-
 emulation/linux/kthread.h              |  39 +-
 emulation/linux/netdevice.h            |   5 +
 emulation/linux/skbuff.h               |   5 +-
 emulation/linux/wait.h                 |   2 +-
 examples/Makefile.am                   |   5 +
 examples/motor_control/Makefile.am     |  42 ++
 examples/motor_control/main.c          | 614 +++++++++++++++++++++++++
 globals.h                              |   5 +-
 include/ecrt.h                         |  15 +-
 libecat.mri                            |   5 +
 master/Makefile.am                     |   7 +-
 master/cdev.c                          | 128 ++++--
 master/cdev.h                          |  10 +-
 master/datagram.h                      |   5 +-
 master/device.c                        |  46 +-
 master/device.h                        |  11 +-
 master/ethercat_master.c               |  38 +-
 master/globals.h                       |   4 +
 master/ioctl.c                         |  42 +-
 master/ioctl.h                         |   3 +-
 master/master.c                        | 149 +++++-
 master/master.h                        |  24 +-
 master/module.c                        |  54 ++-
 master/slave.h                         |  10 +
 master/slave_config.c                  |  26 ++
 tool/CommandAlias.cpp                  |   8 +-
 tool/CommandData.cpp                   |   6 +-
 tool/CommandDomains.cpp                |   8 +-
 tool/CommandDownload.cpp               |  18 +-
 tool/CommandFoeRead.cpp                |   6 +-
 tool/CommandFoeWrite.cpp               |  10 +-
 tool/CommandRegRead.cpp                |   8 +-
 tool/CommandRegWrite.cpp               |  18 +-
 tool/CommandSiiRead.cpp                |   6 +-
 tool/CommandSiiWrite.cpp               |  12 +-
 tool/CommandSoeRead.cpp                |  10 +-
 tool/CommandSoeWrite.cpp               |  12 +-
 tool/CommandUpload.cpp                 |  10 +-
 tool/Makefile.am                       |   9 +-
 tool/MasterDevice.cpp                  | 147 +++++-
 tool/MasterDevice.h                    |  22 +
 48 files changed, 2133 insertions(+), 135 deletions(-)
 create mode 100644 Readme_For_User_Space_IGH_EtherCAT.txt
 create mode 100755 compile.sh
 create mode 100644 devices/nxp_userspace/usm_main.c
 create mode 100644 devices/nxp_userspace/usm_main.h
 create mode 100644 examples/motor_control/Makefile.am
 create mode 100644 examples/motor_control/main.c
 create mode 100644 libecat.mri

diff --git a/.gitignore b/.gitignore
index ce70a823..460f1deb 100644
--- a/.gitignore
+++ b/.gitignore
@@ -48,3 +48,4 @@ tool/ethercat
 device_drivers.md
 generated_table.md
 doxygen-output/
+devices/nxp_userspace/libus_drv.a binary
diff --git a/Readme_For_User_Space_IGH_EtherCAT.txt b/Readme_For_User_Space_IGH_EtherCAT.txt
new file mode 100644
index 00000000..bbfb0c25
--- /dev/null
+++ b/Readme_For_User_Space_IGH_EtherCAT.txt
@@ -0,0 +1,264 @@
+
+		Readme for user space IGH EtherCAT stack
+
+
+1. Why need user space IGH EtherCAT stack?
+
+  As we know, IGH EtherCAT stack has both code in kernel space and user space.
+In kernel space, it has integrated lots of drivers for different networking
+devices, in user space, it supplies one library(libetherat.so/.a) for user's
+application, user can set/get device's running parameters using API of this library,
+the API will write/read data via ioctl mechanism of Linux kernel.
+
+  Ioctl will invoke the routine implemented in master module(ec_master.ko),
+then master module will call the RX/TX function in different drivers. Ioctl is
+system call supplied by Linux, so the updates for running parameters will
+trigger system call of kernel, it will bring in more jitter of system.
+
+  On the other hand, there are mainly two importmant threads for using IGH EtherCAT
+stack, one is master operation thread running in kernel space, it's responsible
+for parsing the frames received from EtherCAT devices. another thread is RT
+thread implemented by user, it will trigger RX/TX functionality cyclically
+according to cycle time. Due to these two threads are running in different
+spaces, so it needs context switch between user space and kernel space, this will
+also increase system jitter and time latency.
+
+  In IGH EtherCAT stack, there are different drivers for devices, so it depends
+on the version of Linux kernel. When you want to compile IGH EtherCAT stack, you
+have to point out clearly the path of kernel, otherwise it will report error.
+
+2. How to resolve the above issues in user space IGH EtherCAT stack?
+
+    For user space IGH EtherCAT stack, it's wholely running in user space, so
+it doesn't need ioctl, user can invoke the functions of master module directly,
+this can avoid system call, it can decrease jitter of system obviously.
+
+    From the perspective of threads, in user space stack, master operation
+thread is also running in user space, so we can refactor OP thread to one
+callback function, this callback function will be called in user's cyclic RT
+thread, so there is only one main thread in whole system, it will avoid context
+switch. This can also improve the performance, such as jitter and latency etc..
+
+    Regarding dependence on Linux kernel, user space IGH EtherCAT stack have no
+code that ran in kernel space, so it's wholely independent of any kernel version.
+
+3. New API of user space IGH EtherCAT stack
+
+3.1 ecus_init
+
+/*
+ * initialize the context for user space EtherCAT stack
+ *
+ * master_count:	the number of ethernet ports as EtherCAT master device
+ * master_macs:		the MAC list of ethernet ports as EtherCAT master device
+ * backup_count:	the number of ethernet ports as EtherCAT backup device
+ * backup_macs:		the MAC list of ethernet ports as EtherCAT backup device
+ * debug_level:		the level of debug, 0 in default
+ * cycle_ns:		the cycle time of user's RT thread, unit: nanoseconds
+ * core_mask:		the mask of CPU affinity, 0x01:core0, 0x02:core1, 0x0F:core0-3
+ *
+ * NOTE: user space stack only supports NXP FEC ethernet port currently
+ *	 The verified platform have i.MX8MP, i.MX8MM and i.MX93.
+ *
+ *	 the MAC address is fixed to "04:13:07:02:00:13"
+ *	 For core_mask, we can isolate this core from Linux, like "isolcpus=1" for Uboot
+ **/
+int ecus_init(uint32_t master_count, const char *const *master_macs,
+              uint32_t backup_count, const char *const *backup_macs,
+              uint32_t debug_level, uint32_t cycle_ns, uint32_t core_mask);
+
+3.2 ecus_done
+
+/*
+ * clean up the context for user space EtherCAT stack
+ **/
+int ecus_done(void);
+
+3.3 ecus_slave_is_ready
+
+/*
+ * Check whether the slave is in ready status (PREOP)
+ *
+ * master_index:	the index of the master that slave is attached
+ * alias:		the alias of the related slave
+ * position:		the position of the related slave
+ **/
+int ecus_slave_is_ready(uint32_t master_index, uint16_t alias, uint16_t position);
+
+3.4 ecus_master_operation_loop
+
+/*
+ * master operation callback function that should be invoked in user's RT thread
+ *
+ * master:	the pointer of the corresponding master
+ * cycle:	denote whether this calling will calculate jiffies for master FSM
+ *
+ * Note: this function should be called twice in one loop of RT thread,
+ *	 the first one is called after RX, the second one is called after TX.
+ *	 only the first one should set cycle = 1
+ **/
+int ecus_master_operation_loop(ec_master_t *master, int cycle);
+
+3.5 ecus_bind_cpu_core
+
+/*
+ * Set the CPU affinity for user's RT thread
+ *
+ * core_mask:		the mask of CPU affinity, 0x01:core0, 0x02:core1, 0x0F:core0-3
+ **/
+int ecus_bind_cpu_core(uint32_t core_mask);
+
+4. How to use user space EtherCAT stack?
+
+User space IGH EtherCAT stack will be compiled out a library named "libethercat_master.a/.so",
+user's application should link this new library by "-lethercat_master",
+
+I will take the below code as example (cycle time: 1ms)
+
+static char *smaster_macs[1] = {
+	"04:13:07:02:00:13",
+};
+
+static void *user_cycle_thread(void *p)
+{
+	ec_master_t *ec_master;
+
+	/* ec_master = ... ; */
+
+	/* bind RT thread to CPU core 1 */
+	ecus_bind_cpu_core(0x02);
+
+	while (1) {
+		ecrt_master_receive(ec_master);
+
+		/* call operation function after RX */
+		ecus_master_operation_loop(ec_master, 1);
+
+		...
+
+		ecrt_master_send(ec_master);
+
+		/* call operation function after TX */
+		ecus_master_operation_loop(ec_master, 0);
+
+		usleep(1000);
+	}
+}
+
+int main()
+{
+	const char **masters = (const char **)smaster_macs;
+
+	/*
+	  initialize user space stack: one master, zero backup, cycle time:1ms,
+	  user's RT thread will run on core1
+	   */
+	ecus_init(1, masters, 0, NULL, 0, 1000000, 0x02);
+
+	/*  waiting for slave to be ready status */
+	for (...) {
+		ready = ecus_slave_is_ready(0, slave_alias, slave_position);
+		if (ready)
+			break;
+		sleep(1);
+	}
+
+	start user_cycle_thread as RT thread ...
+
+	waiting for user_cycle_thread to finish
+
+	/* exit user space EtherCAT */
+	ecus_done();
+
+	return 0;
+}
+
+NOTE:
+For user space IGH EtherCAT, should use *-dpdk.dtb for Linux kernel, for example:
+- imx8mm-evk-dpdk.dtb
+- imx8mp-evk-dpdk.dtb
+- imx93-11x11-evk-dpdk.dtb
+
+5. How to run user's EtherCAT application
+
+Before running application, we should set hugepage related configuration:
+
+# mkdir -p /dev/hugepages
+# mount -t hugetlbfs hugetlbfs /dev/hugepages
+# echo 448 > /sys/kernel/mm/hugepages/hugepages-2048kB/nr_hugepages
+
+Then we can start user's application:
+# ./user_app
+
+6. How to use EtherCAT tool to show EtherCAT device's information?
+
+Because EtherCAT tool(named ethercat_userspace) will invoke ioctl to scan and
+show EtherCAT devices, for conveniency of using EtherCAT tool, we have
+implemented one virtual ioctl interface to support this tool. one backend
+program(named ethercat_master) will supply the service for the tool.
+
+Firstly we should run the backend program:
+# mkdir -p /dev/hugepages
+# mount -t hugetlbfs hugetlbfs /dev/hugepages
+# echo 448 > /sys/kernel/mm/hugepages/hugepages-2048kB/nr_hugepages
+# ./ethercat_master &
+
+Then we can run EtherCAT tool:
+# ./ethercat_userspace slaves -v
+
+or
+
+# ./ethercat_userspace cstruct
+
+Note:
+1. If want to run user's application, should exit and close ethercat_master program.
+2. For i.MX platforms, should limit DDR memory in 4G bytes via 'mem' variable in U-Boot bootargs.
+	Example: 'mem=4096M'
+
+7. How to use user space EtherCAT stack on i.MX95 and i.MX943 platform?
+7.1 i.MX95
+* eth0:
+    insmod ./kpage_ncache.ko
+    echo -n 0002:00:00.0 > /sys/bus/pci/drivers/fsl_enetc4/unbind
+    echo -n enetc_pci_uio > /sys/bus/pci/devices/0002:00:00.0/driver_override
+    echo -n 0002:00:00.0 > /sys/bus/pci/drivers/enetc_pci_uio/bind
+    export ECAT_MAIN_DEV="enetc4@0002:00:00.0"
+
+* eth1:
+    insmod ./kpage_ncache.ko
+    echo -n 0002:00:10.0 > /sys/bus/pci/drivers/fsl_enetc4/unbind
+    echo -n enetc_pci_uio > /sys/bus/pci/devices/0002:00:10.0/driver_override
+    echo -n 0002:00:10.0 > /sys/bus/pci/drivers/enetc_pci_uio/bind
+    export ECAT_MAIN_DEV="enetc4@0002:00:10.0"
+
+7.2 i.MX943
+* eth1:
+    insmod ./kpage_ncache.ko
+    echo -n 0001:01:08.0 > /sys/bus/pci/drivers/fsl_enetc4/unbind
+    echo -n enetc_pci_uio > /sys/bus/pci/devices/0001:01:08.0/driver_override
+    echo -n 0001:01:08.0 > /sys/bus/pci/drivers/enetc_pci_uio/bind
+    export ECAT_MAIN_DEV="enetc4@0001:01:08.0"
+
+* eth2:
+    insmod ./kpage_ncache.ko
+    echo -n 0001:01:10.0 > /sys/bus/pci/drivers/fsl_enetc4/unbind
+    echo -n enetc_pci_uio > /sys/bus/pci/devices/0001:01:10.0/driver_override
+    echo -n 0001:01:10.0 > /sys/bus/pci/drivers/enetc_pci_uio/bind
+    export ECAT_MAIN_DEV="enetc4@0001:01:10.0"
+
+7.3 Compile kpage_ncache.ko:
+$ git clone https://github.com/nxp-qoriq/dpdk-extras
+
+Refer to README in linux/kpage_ncache directory.
+
+8. motor control example
+The example code for motor control is in "examples/motor_control/",
+after compilation, the name of executable file is ec_motor_example.
+
+you can use the following command to control motor rotation:
+# ./ec_motor_example 131072 1
+
+Note:
+  1. 131072 is encoding rate of motors, 1 is motor number. The number can be 1, 2 ... 64.
+  2. For working at the same rotate speed, all motors should have same encoding rate.
+  3. Before starting ec_motor_example, should exit ethercat_master program.
diff --git a/compile.sh b/compile.sh
new file mode 100755
index 00000000..22d0e1ac
--- /dev/null
+++ b/compile.sh
@@ -0,0 +1,31 @@
+#!/bin/bash
+
+#export CROSS_COMPILE=/usr/bin/aarch64-linux-gnu-
+
+if [ "$1" == "rebuild" ]; then
+rm -fr $PWD/ecat_build
+mkdir $PWD/ecat_build
+rm ./configure
+rm ./config.status
+
+rm -fr autoconf/ autom4te.cache/ master/.libs/
+find . -name ".deps" | xargs rm -fr
+find . -name "*.lo" | xargs rm -fr
+find . -name "*.o" | xargs rm -fr
+
+./bootstrap
+
+if [ -n "$CROSS_COMPILE" ]; then
+CCHOSTB=$(basename "$CROSS_COMPILE")
+CCHOST=${CCHOSTB:0:-1}
+./configure --prefix=$PWD/ecat_build/ --enable-kernel=no --enable-usecat=yes --enable-tool=yes --enable-eoe=no --host=${CCHOST}
+else
+./configure --prefix=$PWD/ecat_build/ --enable-kernel=no --enable-usecat=yes --enable-tool=yes --enable-eoe=no --build=arm
+fi
+
+fi
+
+make
+make install
+
+${CROSS_COMPILE}ar -M < ./libecat.mri
diff --git a/configure.ac b/configure.ac
index 37a8bf6d..6c197944 100644
--- a/configure.ac
+++ b/configure.ac
@@ -76,7 +76,7 @@ AC_ARG_ENABLE([usecat],
 )
 
 if test "x${enable_usecat}" = "x1"; then
-    AC_DEFINE([EC_USERSPACE_MASTER], [1], [Userspace EtherCAT library enabled])
+    AC_DEFINE([EC_USERSPACE_MASTER_NEW], [1], [Userspace EtherCAT library enabled])
     AC_MSG_RESULT([yes])
 else
     AC_MSG_RESULT([no])
@@ -1439,6 +1439,7 @@ AC_CONFIG_FILES([
         examples/tty/Kbuild
         examples/tty/Makefile
         examples/user/Makefile
+        examples/motor_control/Makefile
         examples/xenomai/Makefile
         examples/xenomai_posix/Makefile
         fake_lib/Makefile
diff --git a/devices/nxp_userspace/usm_main.c b/devices/nxp_userspace/usm_main.c
new file mode 100644
index 00000000..563eee70
--- /dev/null
+++ b/devices/nxp_userspace/usm_main.c
@@ -0,0 +1,309 @@
+/* SPDX-License-Identifier: BSD-3-Clause
+ * Copyright 2023 NXP
+ */
+
+#define _GNU_SOURCE
+#include <pthread.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/err.h>
+#include <linux/version.h>
+#include <linux/netdevice.h>
+#include <linux/if_arp.h> /* ARPHRD_ETHER */
+#include <linux/etherdevice.h>
+#include <sys/sysinfo.h>
+
+#include "../globals.h"
+#include "../ecdev.h"
+#include "device.h"
+#include "usm_main.h"
+
+#define PFX "nxp_us_drv: "
+
+MODULE_DESCRIPTION("NXP user space driver module");
+MODULE_LICENSE("GPL");
+MODULE_VERSION(EC_MASTER_VERSION);
+
+
+int __init ec_usm_init_module(void);
+void __exit ec_usm_cleanup_module(void);
+
+typedef struct {
+    struct net_device *netdev;
+    ec_device_t *ecdev;
+    uint8_t *rx_buf[MAX_RX_BD_RING_SIZE];
+    uint8_t *tx_buf[MAX_TX_BD_RING_SIZE];
+    uint32_t rx_idxs[MAX_RX_BD_RING_SIZE];
+    uint16_t rx_lens[MAX_RX_BD_RING_SIZE];
+    int rx_cnt;
+} ec_usm_device_t;
+
+static ec_usm_device_t sec_usm_dev;
+static uint32_t score_mask = 0x02;
+
+extern int ec_master_set_noop_mode(uint32_t cycle_ns);
+static int ec_usm_device_xmit(ec_usm_device_t *, struct sk_buff *);
+static void ec_usm_device_poll(ec_usm_device_t *);
+
+static int ecus_set_core_mask(uint32_t core_mask)
+{
+    if (core_mask == 0)
+        return -1;
+
+    score_mask = core_mask;
+    return 0;
+}
+
+uint32_t ecus_get_core_mask(void)
+{
+    return score_mask;
+}
+
+int ecus_bind_cpu_core(uint32_t core_mask)
+{
+    pthread_t thread;
+    cpu_set_t cpuset;
+    int core_num = 0;
+    int ret = 0;
+    int i = 0;
+
+    thread = pthread_self();
+    core_num = get_nprocs();
+
+    CPU_ZERO(&cpuset);
+
+    if (core_num == 1) {
+        CPU_SET(0, &cpuset);
+        goto set_tag;
+    }
+
+    for (i = 0; i < 32; i++) {
+        if (core_mask & (0x01 << i))
+            CPU_SET(i, &cpuset);
+    }
+
+set_tag:
+    ret = pthread_setaffinity_np(thread, sizeof(cpu_set_t), &cpuset);
+    if (ret != 0)
+        printk(KERN_ERR PFX "pthread_setaffinity_np failed!\n");
+
+    return ret;
+}
+
+static int ec_usm_netdev_open(struct net_device *dev)
+{
+    return 0;
+}
+
+static int ec_usm_netdev_stop(struct net_device *dev)
+{
+    return 0;
+}
+
+static int ec_usm_netdev_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+    ec_usm_device_t *usm_dev = &sec_usm_dev;
+
+    return ec_usm_device_xmit(usm_dev, skb);
+}
+
+static void ec_usm_poll(struct net_device *dev)
+{
+    ec_usm_device_t *usm_dev = &sec_usm_dev;
+
+    return ec_usm_device_poll(usm_dev);
+}
+
+static const struct net_device_ops ec_usm_netdev_ops = {
+    .ndo_open       = ec_usm_netdev_open,
+    .ndo_stop       = ec_usm_netdev_stop,
+    .ndo_start_xmit = ec_usm_netdev_xmit,
+};
+
+static inline void ec_usm_ether_setup(struct net_device *netdev)
+{
+    uint8_t smac[6] = {0x04, 0x13, 0x07, 0x02, 0x00, 0x13};
+
+    memcpy(netdev->dev_addr, smac, 6);
+    netdev->type = ARPHRD_ETHER;
+    netdev->ifindex = 0;
+}
+
+/** Init userspace-master device.
+ */
+static int ec_usm_device_init(ec_usm_device_t *dev)
+{
+    ec_usm_device_t **priv;
+    int i = 0;
+
+    dev->ecdev = NULL;
+    dev->netdev = alloc_netdev(sizeof(ec_usm_device_t *), "ecat0", NET_NAME_UNKNOWN, ec_usm_ether_setup);
+    if (!dev->netdev)
+        return -ENOMEM;
+
+    dev->netdev->netdev_ops = &ec_usm_netdev_ops;
+
+    for (i = 0; i < MAX_RX_BD_RING_SIZE; i++)
+        dev->rx_buf[i] = us_drv_get_rx_buf(i);
+
+    for (i = 0; i < MAX_TX_BD_RING_SIZE; i++)
+        dev->tx_buf[i] = us_drv_get_tx_buf(i);
+
+    priv = netdev_priv(dev->netdev);
+    *priv = dev;
+
+    return 0;
+}
+
+/** Clear userspace-master device.
+ */
+static void ec_usm_device_clear(ec_usm_device_t *dev)
+{
+    if (dev->ecdev) {
+        ecdev_close(dev->ecdev);
+        ecdev_withdraw(dev->ecdev);
+    }
+
+    free_netdev(dev->netdev);
+}
+
+/** Offer userspace-master device to master.
+ */
+static int ec_usm_device_offer(ec_usm_device_t *dev)
+{
+    int ret = 0;
+
+    dev->ecdev = ecdev_offer(dev->netdev, ec_usm_poll, THIS_MODULE);
+    if (!dev->ecdev) {
+        printk("%s(): ecdev_offer failed!\n", __func__);
+        return -1;
+    }
+
+    ret = ecdev_open(dev->ecdev);
+    if (ret) {
+        ecdev_withdraw(dev->ecdev);
+        dev->ecdev = NULL;
+        return -2;
+    }
+
+    ecdev_set_link(dev->ecdev, netif_carrier_ok(dev->netdev));
+
+    return ret;
+}
+
+static int ec_usm_device_xmit(ec_usm_device_t *dev, struct sk_buff *skb)
+{
+    size_t len = skb->len;
+    int ret = 0;
+
+    ret = us_drv_send(skb->data, skb->len, 0);
+    return (ret == len) ? NETDEV_TX_OK : NETDEV_TX_BUSY;
+}
+
+/** Polls the device.
+ */
+static void ec_usm_device_poll(ec_usm_device_t *dev)
+{
+    uint8_t *rx_buf = NULL;
+    uint32_t rx_idx = 0;
+    uint16_t rx_len = 0;
+    int i = 0;
+
+    dev->rx_cnt = us_drv_recv(NULL, dev->rx_lens, dev->rx_idxs);
+    if (dev->rx_cnt <= 0)
+        return;
+
+    for (i = 0; i < dev->rx_cnt; i++) {
+        rx_idx = dev->rx_idxs[i];
+        rx_buf = dev->rx_buf[rx_idx];
+        rx_len = dev->rx_lens[i];
+
+        ecdev_receive(dev->ecdev, rx_buf, rx_len);
+    }
+
+    return;
+}
+
+/** Offer device.
+ */
+static int ec_usm_offer_device(ec_usm_device_t *usm_dev)
+{
+    int ret = 0;
+
+    ret = ec_usm_device_init(usm_dev);
+    if (ret)
+        return ret;
+
+    ret = ec_usm_device_offer(usm_dev);
+    if (ret)
+        return ret;
+
+    return ret;
+}
+
+/** Clear devices.
+ */
+static void ec_usm_clear_devices(void)
+{
+    ec_usm_device_t *usm_dev = &sec_usm_dev;
+
+    ec_usm_device_clear(usm_dev);
+}
+
+/** Initialize userspace-master net devices.
+ * it should be called before ecus_init
+ */
+int ec_usm_net_init(uint32_t cycle_ns, uint32_t core_mask)
+{
+    int ret = 0;
+
+    ec_master_set_noop_mode(cycle_ns);
+
+    ecus_set_core_mask(core_mask);
+
+    ret = us_drv_lib_init(LINK_100M);
+    if (ret)
+        goto err_tag;
+
+    printf("%s(): cycle_ns:%d core_mask:0x%02X\n", __func__, cycle_ns, ecus_get_core_mask());
+    printf("RX ring size:%d, TX ring size:%d\n", MAX_RX_BD_RING_SIZE, MAX_TX_BD_RING_SIZE);
+
+err_tag:
+    if (ret)
+        printf("%s(): run failed! ret:%d\n", __func__, ret);
+
+    return ret;
+}
+
+/** Module initialization.
+ *
+ * Initializes \a master_count masters.
+ * \return 0 on success, else < 0
+ */
+int __init ec_usm_init_module(void)
+{
+    int ret = 0;
+
+    printk(KERN_INFO PFX "EtherCAT master driver, ver:%s\n", EC_MASTER_VERSION);
+
+    ret = ec_usm_offer_device(&sec_usm_dev);
+    if (ret) {
+        printk("%s(): offer userspace-master device failed!\n", __func__);
+        ret = -1;
+    }
+
+    return ret;
+}
+
+/** Module cleanup.
+ *
+ * Clears all master instances.
+ */
+void __exit ec_usm_cleanup_module(void)
+{
+    ec_usm_clear_devices();
+    us_drv_lib_exit(0);
+}
+
+module_init(ec_usm_init_module);
+module_exit(ec_usm_cleanup_module);
diff --git a/devices/nxp_userspace/usm_main.h b/devices/nxp_userspace/usm_main.h
new file mode 100644
index 00000000..022daf64
--- /dev/null
+++ b/devices/nxp_userspace/usm_main.h
@@ -0,0 +1,41 @@
+/* SPDX-License-Identifier: BSD-3-Clause
+ * Copyright 2024 NXP
+ */
+
+#ifndef __US_DRV_LIB__
+#define __US_DRV_LIB__
+
+#include <sys/mman.h>
+#include <sys/stat.h>
+#include <sys/sysinfo.h>
+#include <fcntl.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdint.h>
+#include <unistd.h>
+
+
+#ifndef MAX_TX_BD_RING_SIZE
+#define MAX_TX_BD_RING_SIZE	(16)
+#endif
+
+#ifndef MAX_RX_BD_RING_SIZE
+#define MAX_RX_BD_RING_SIZE	(16)
+#endif
+
+#define SIZE_OF(x) (sizeof(x)/sizeof(x[0]))
+
+#define LINK_100M	(100)
+#define LINK_1000M	(1000)
+
+int us_drv_lib_init(int link);
+int us_drv_lib_exit(int stat);
+
+uint8_t* us_drv_get_rx_buf(int idx);
+uint8_t* us_drv_get_tx_buf(int idx);
+
+int us_drv_recv(void *buf, uint16_t *plen, uint32_t *pindex);
+int us_drv_send(void *buf, uint16_t len, uint64_t addr);
+
+#endif
diff --git a/emulation/linux/jiffies.h b/emulation/linux/jiffies.h
index eb736b7a..c977b6dc 100644
--- a/emulation/linux/jiffies.h
+++ b/emulation/linux/jiffies.h
@@ -37,16 +37,29 @@ typedef u64 cycles_t;
 
 static const unsigned int cpu_khz = 1000;  // unit of get_cycles()
 
+#ifdef EC_USERSPACE_MASTER_NEW
+int ec_master_in_noop_mode(void);
+uint64_t ec_master_cycle_us(void);
+#define HZ (250)
+#else
+#define HZ (1000)
+#endif
+
 static inline cycles_t get_cycles(void)
 {
     struct timeval TVal;
+
+#ifdef EC_USERSPACE_MASTER_NEW
+    if (ec_master_in_noop_mode())
+        return ec_master_cycle_us();
+#endif
+
     // thanks to VDSO, gettimeofday() does not require a system call
     if (gettimeofday (&TVal, NULL) < 0)
         return -1;
     return (cycles_t) TVal.tv_sec * 1000000 + TVal.tv_usec;
 }
 
-#define HZ 1000
 #define jiffies ((unsigned long) (get_cycles () / (cpu_khz * 1000 / HZ)))
 
 #endif
diff --git a/emulation/linux/kthread.h b/emulation/linux/kthread.h
index 4b046c35..b34b2c01 100644
--- a/emulation/linux/kthread.h
+++ b/emulation/linux/kthread.h
@@ -1,6 +1,7 @@
 #ifndef _LINUX_KTHREAD_H
 #define _LINUX_KTHREAD_H
 
+#include <limits.h>
 #include <pthread.h>
 #include <signal.h>
 #include <string.h>
@@ -25,15 +26,26 @@ static inline void dummy_signal_handler(int sig)
     (void) sig;
 }
 
+#ifdef EC_USERSPACE_MASTER_NEW
+int ecus_bind_cpu_core(uint32_t core_mask);
+uint32_t ecus_get_core_mask(void);
+#endif
+
 static inline void *task_run(void *arg)
 {
     current_task = (struct task_struct *) arg;
     prctl(PR_SET_NAME, current_task->name);
+
+#ifdef EC_USERSPACE_MASTER_NEW
+    ecus_bind_cpu_core(ecus_get_core_mask());
+#else
     struct sigaction a;
     memset(&a, 0, sizeof (a));
     a.sa_handler = dummy_signal_handler;
     sigemptyset(&a.sa_mask);
     sigaction(SIGUSR1, &a, NULL);
+#endif
+
     current_task->thread_func(current_task->data);
     return NULL;
 }
@@ -41,6 +53,29 @@ static inline void *task_run(void *arg)
 static inline struct task_struct *kthread_run(int (*thread_func)(void *), void *data, const char *namefmt, ...)
 {
     struct task_struct *task = malloc(sizeof(struct task_struct));
+    pthread_attr_t *pthattr = NULL;
+    int ret = 0;
+
+#ifdef EC_USERSPACE_MASTER_NEW
+    struct sched_param param;
+    pthread_attr_t thattr;
+
+    pthread_attr_init(&thattr);
+    pthread_attr_setstacksize(&thattr, PTHREAD_STACK_MIN);
+    ret = pthread_attr_setschedpolicy(&thattr, SCHED_FIFO);
+    if (ret) {
+        fprintf(stderr, "%s\n", strerror(ret));
+    }
+
+    param.sched_priority = sched_get_priority_max(SCHED_FIFO) - 5;
+    ret = pthread_attr_setschedparam(&thattr, &param);
+    if (ret) {
+        printf(" OP pthread setschedparam failed. ");
+        fprintf(stderr, "%s\n", strerror(ret));
+    }
+    pthattr = &thattr;
+#endif
+
     if (!task)
         return ERR_PTR(-ENOMEM);
     task->thread_func = thread_func;
@@ -50,7 +85,7 @@ static inline struct task_struct *kthread_run(int (*thread_func)(void *), void *
     vsnprintf(task->name, sizeof(task->name), namefmt, args);
     va_end(args);
     task->should_stop = 0;
-    int ret = pthread_create(&task->thread, NULL, task_run, task);
+    ret = pthread_create(&task->thread, pthattr, task_run, task);
     if (ret == 0)
         return task;
     free(task);
@@ -60,7 +95,9 @@ static inline struct task_struct *kthread_run(int (*thread_func)(void *), void *
 
 static inline void kthread_stop(struct task_struct *task)
 {
+#ifndef EC_USERSPACE_MASTER_NEW
     pthread_kill(task->thread, SIGUSR1);  // interrupt blocking system calls
+#endif
     task->should_stop = 1;
     pthread_join(task->thread, NULL);
     free(task);
diff --git a/emulation/linux/netdevice.h b/emulation/linux/netdevice.h
index 721de0e1..19e17bb1 100644
--- a/emulation/linux/netdevice.h
+++ b/emulation/linux/netdevice.h
@@ -78,6 +78,11 @@ static inline void ether_setup(struct net_device *netdev)
 {
 }
 
+static inline void eth_hw_addr_set(struct net_device *dev, const u8 *addr)
+{
+    memcpy(dev->dev_addr, addr, ETH_ALEN);
+}
+
 static inline struct net_device *make_netdev(struct ifaddrs *a)
 {
     if (!a->ifa_addr || a->ifa_addr->sa_family != PF_PACKET)
diff --git a/emulation/linux/skbuff.h b/emulation/linux/skbuff.h
index 569d5768..4b433a41 100644
--- a/emulation/linux/skbuff.h
+++ b/emulation/linux/skbuff.h
@@ -12,6 +12,7 @@ struct sk_buff
     struct net_device   *dev;
     int                 ip_summed;
     uint16_t            protocol;
+    uint16_t            free_buf;
 };
 
 #define eth_type_trans(SKB, DEV) 0
@@ -22,6 +23,7 @@ static inline struct sk_buff *dev_alloc_skb(unsigned int length)
     if(!buf)
         return buf;
     buf->len = 0;
+    buf->free_buf = 1;
     buf->data = buf->head = buf->tail = malloc(length);
     if (!buf->head) {
         free(buf);
@@ -32,7 +34,8 @@ static inline struct sk_buff *dev_alloc_skb(unsigned int length)
 
 static inline void dev_kfree_skb(struct sk_buff *skb)
 {
-    free(skb->head);
+    if (skb->free_buf)
+        free(skb->head);
     free(skb);
 }
 
diff --git a/emulation/linux/wait.h b/emulation/linux/wait.h
index 66df6f22..61e75973 100644
--- a/emulation/linux/wait.h
+++ b/emulation/linux/wait.h
@@ -1,6 +1,6 @@
 #ifndef _LINUX_WAIT_H
 #define _LINUX_WAIT_H
-
+#define __USE_GNU
 #include <pthread.h>
 
 struct __wait_queue_head
diff --git a/examples/Makefile.am b/examples/Makefile.am
index d73d0977..7a2da9be 100644
--- a/examples/Makefile.am
+++ b/examples/Makefile.am
@@ -53,6 +53,10 @@ SUBDIRS += \
 endif
 endif
 
+if ENABLE_USERSPACE_MASTER
+SUBDIRS += motor_control
+endif
+
 # Here DIST_SUBDIRS needs to be explicitely defined because
 # dc_rtai, mini and rtai are never added to `SUBDIRS`
 DIST_SUBDIRS = \
@@ -64,6 +68,7 @@ DIST_SUBDIRS = \
 	rtai_rtdm_dc \
 	tty \
 	user \
+	motor_control \
 	xenomai \
 	xenomai_posix
 
diff --git a/examples/motor_control/Makefile.am b/examples/motor_control/Makefile.am
new file mode 100644
index 00000000..12b3f230
--- /dev/null
+++ b/examples/motor_control/Makefile.am
@@ -0,0 +1,42 @@
+#------------------------------------------------------------------------------
+#
+#  $Id$
+#
+#  Copyright 2024 NXP
+#
+#  This file is part of the IgH EtherCAT Master.
+#
+#  The IgH EtherCAT Master is free software; you can redistribute it and/or
+#  modify it under the terms of the GNU General Public License version 2, as
+#  published by the Free Software Foundation.
+#
+#  The IgH EtherCAT Master is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
+#  Public License for more details.
+#
+#  You should have received a copy of the GNU General Public License along with
+#  the IgH EtherCAT Master; if not, write to the Free Software Foundation,
+#  Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+#
+#  ---
+#
+#  The license mentioned above concerns the source code only. Using the
+#  EtherCAT technology and brand is only permitted in compliance with the
+#  industrial property and similar rights of Beckhoff Automation GmbH.
+#
+#------------------------------------------------------------------------------
+
+noinst_PROGRAMS = ec_motor_example
+
+ec_motor_example_SOURCES = main.c
+ec_motor_example_CFLAGS = -I$(top_srcdir)/include -Wall
+
+if ENABLE_USERSPACE_MASTER
+ec_motor_example_CFLAGS += -DEC_MASTER_IN_USERSPACE
+ec_motor_example_LDFLAGS = -L$(top_builddir)/master/.libs -L$(top_builddir)/devices/nxp_userspace -lethercat_master -lpthread
+else
+ec_motor_example_LDFLAGS = -L$(top_builddir)/lib/.libs
+endif
+
+#------------------------------------------------------------------------------
diff --git a/examples/motor_control/main.c b/examples/motor_control/main.c
new file mode 100644
index 00000000..bffda62d
--- /dev/null
+++ b/examples/motor_control/main.c
@@ -0,0 +1,614 @@
+/*****************************************************************************
+ *
+ *  $Id$
+ *
+ *  Copyright 2024 NXP
+ *
+ *  This file is part of the IgH EtherCAT Master.
+ *
+ *  The IgH EtherCAT Master is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License version 2, as
+ *  published by the Free Software Foundation.
+ *
+ *  The IgH EtherCAT Master is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
+ *  Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with the IgH EtherCAT Master; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *  ---
+ *
+ *  The license mentioned above concerns the source code only. Using the
+ *  EtherCAT technology and brand is only permitted in compliance with the
+ *  industrial property and similar rights of Beckhoff Automation GmbH.
+ *
+ ****************************************************************************/
+
+#include <errno.h>
+#include <signal.h>
+#include <stdio.h>
+#include <string.h>
+#include <sys/resource.h>
+#include <sys/time.h>
+#include <time.h>
+#include <sys/types.h>
+#include <unistd.h>
+#include <sched.h>
+
+#include "ecrt.h"
+
+#define ECAT_RT1180
+#define RT1180_VID (0x0CC2)
+#define RT1180_PID (0x0002)
+#define CLOCK_TYPE CLOCK_MONOTONIC  /* CLOCK_REALTIME */
+
+static int srt1180_flag = 0;
+
+typedef struct _ec_reg_pdo_cfg_t {
+	uint16_t index;
+	uint8_t subindex;
+	int32_t *poffset;
+} ec_reg_pdo_cfg_t;
+
+typedef enum {
+	no_ready_to_switch_on = 0,
+	switch_on_disable,
+	ready_to_switch_on,
+	switched_on,
+	operation_enable,
+	quick_stop_active,
+	fault_reaction_active,
+	fault,
+	none
+} servo_axle_state;
+
+typedef enum {
+	op_mode_no = 0,
+	op_mode_pp = 1,
+	op_mode_vl = 2,
+	op_mode_pv = 3,
+	op_mode_hm = 6,
+	op_mode_ip = 7,
+	op_mode_csp = 8,
+	op_mode_csv = 9,
+	op_mode_cst = 10
+} mode_of_operation;
+
+typedef struct _motor_axle_info_t {
+	uint32_t product_code;
+	uint32_t vendor_id;
+	int32_t base_pos;
+	int32_t cur_pos;
+	float fratio;
+	int init_flag;
+	int ctrl_flag;
+	int pos_idx;
+	int sec_cnt;
+} motor_axle_info_t;
+
+#define contrlword_shutdown(c)			(((c) | 0x6) & ~0x81)
+#define contrlword_switch_on(c) 		(((c) | 0x7) & ~0x88)
+#define contrlword_enable_operation(c)		(((c) | 0xF) & ~0x80)
+#define contrlword_fault_reset(c)		((c) | 0x80)
+
+#define EC_BIND_CORE_MASK (0x02)  /* working on core1 in default */
+
+#define NUM_OF(x) (sizeof(x) / sizeof(x[0]))
+#define NSEC_PER_SEC (1000000000L)
+#define CYCLE_TIME_NS (1000000)  /* cycle time: 1ms */
+#define TIMESPEC2NS(T) ((uint64_t) (T).tv_sec * NSEC_PER_SEC + (T).tv_nsec)
+
+#define FREE(p) do {if (p) free(p);} while(0)
+#define RET_ERR(r, s) do {printf("Error:%d, %s", (r), (s)); ret = (r); goto ret_tag;} while(0)
+
+static ec_master_t *sec_master = NULL;
+static ec_domain_t *sec_domain = NULL;
+
+static uint32_t sec_rate = 2 << 16;
+static uint32_t sec_axle_num = 1;
+
+static motor_axle_info_t *sp_axle_info = NULL;
+static uint8_t *sec_domain_pd = NULL;
+static uint8_t *sp_axle_data = NULL;
+static int sall_op_flag = 0;
+static int sloop_flag = 0;
+static int sexit_flag = 0;
+
+static inline struct timespec timespec_add(struct timespec t1, struct timespec t2)
+{
+	struct timespec result;
+
+	if ((t1.tv_nsec + t2.tv_nsec) >= NSEC_PER_SEC) {
+		result.tv_sec = t1.tv_sec + t2.tv_sec + 1;
+		result.tv_nsec = t1.tv_nsec + t2.tv_nsec - NSEC_PER_SEC;
+	} else {
+		result.tv_sec = t1.tv_sec + t2.tv_sec;
+		result.tv_nsec = t1.tv_nsec + t2.tv_nsec;
+	}
+
+	return result;
+}
+
+static ec_reg_pdo_cfg_t sec_reg_pdo_cfg[] = {
+	{0x6040, 0x0},  /* controlword */
+	{0x6041, 0x0},  /* statusword */
+	{0x6064, 0x0},  /* actual_position */
+	{0x6060, 0x0},  /* op_mode */
+	{0x6061, 0x0},
+	{0x607A, 0x0},  /* target_position */
+	{0x60FF, 0x0},
+};
+#define sec_ctrl_word(x)	(*(sec_reg_pdo_cfg[0].poffset + (x)))
+#define sec_stat_word(x)	(*(sec_reg_pdo_cfg[1].poffset + (x)))
+#define sec_actual_pos(x)	(*(sec_reg_pdo_cfg[2].poffset + (x)))
+#define sec_op_mode(x)		(*(sec_reg_pdo_cfg[3].poffset + (x)))
+#define sec_target_pos(x)	(*(sec_reg_pdo_cfg[5].poffset + (x)))
+
+static ec_pdo_entry_info_t sec_rx_pdo_entry[] = {
+	{0x6040, 0, 16},  /* controlword */
+	{0x607A, 0, 32},  /* target_position */
+	{0x60FF, 0, 32},  /* target_velocity */
+	{0x6060, 0, 8},   /* op_mode */
+#ifdef ECAT_RT1180
+	{0x0000, 0, 8},   /* gap */
+#endif
+};
+
+static ec_pdo_entry_info_t sec_tx_pdo_entry[] = {
+	{0x6041, 0, 16},  /* statusword */
+	{0x6064, 0, 32},  /* actual_position */
+	{0x606c, 0, 32},  /* actual_velocity */
+	{0x6061, 0, 8},   /* op_mode_display */
+#ifdef ECAT_RT1180
+	{0x0000, 0, 8},   /* gap */
+#endif
+};
+
+static ec_pdo_info_t sec_rx_pdo[] = {
+	{0x1600, NUM_OF(sec_rx_pdo_entry), sec_rx_pdo_entry},
+#ifdef ECAT_RT1180
+	{0x1610, NUM_OF(sec_rx_pdo_entry), sec_rx_pdo_entry},
+#endif
+};
+
+static ec_pdo_info_t sec_tx_pdo[] = {
+	{0x1a00, NUM_OF(sec_tx_pdo_entry), sec_tx_pdo_entry},
+#ifdef ECAT_RT1180
+	{0x1a10, NUM_OF(sec_tx_pdo_entry), sec_tx_pdo_entry},
+#endif
+};
+
+static ec_sync_info_t sec_sync_mgr[] = {
+	{2, EC_DIR_OUTPUT, NUM_OF(sec_rx_pdo), sec_rx_pdo},
+	{3, EC_DIR_INPUT, NUM_OF(sec_tx_pdo), sec_tx_pdo},
+};
+
+#ifdef ECAT_RT1180
+static int get_pdo_entry_offset(void)
+{
+	ec_pdo_entry_info_t *pe = sec_rx_pdo_entry;
+	int bl = 0;
+	int i = 0;
+
+	for (i = 0; i < NUM_OF(sec_rx_pdo_entry); i++)
+		bl += pe[i].bit_length;
+
+	return (bl / 8);
+}
+#endif
+
+static int update_axle_config(int axle_num)
+{
+	ec_reg_pdo_cfg_t *pe = sec_reg_pdo_cfg;
+	int num = NUM_OF(sec_reg_pdo_cfg);
+	uint8_t *p = NULL;
+	int len = 0;
+	int i = 0;
+
+	len = sizeof(int32_t) * axle_num;
+	p = (uint8_t*)calloc(num, len);
+	if (!p)
+		return -1;
+
+	sp_axle_data = p;
+	for (i = 0; i < num; i++) {
+		pe[i].poffset = (int32_t*)p;
+		p += len;
+	}
+
+#ifdef ECAT_RT1180
+	if (!srt1180_flag) {
+		ec_sync_info_t *psync = NULL;
+		ec_pdo_info_t *pdo = NULL;
+		int j = 0;
+
+		for (i = 0; i < NUM_OF(sec_sync_mgr); i++) {
+			psync = sec_sync_mgr + i;
+			psync->n_pdos--;
+
+			for (j = 0; j < psync->n_pdos; j++) {
+				pdo = (ec_pdo_info_t *)(psync->pdos + j);
+				pdo->n_entries--;
+			}
+		}
+	}
+#endif
+
+	return 0;
+}
+
+static servo_axle_state get_axle_state(uint16_t status_word)
+{
+	if ((status_word & 0x4F) == 0x40)
+		return switch_on_disable;
+	if ((status_word & 0x6F) == 0x21)
+		return ready_to_switch_on;
+	if ((status_word & 0x6F) == 0x23)
+		return switched_on;
+	if ((status_word & 0x6F) == 0x27)
+		return operation_enable;
+	if ((status_word & 0x6F) == 0x07)
+		return quick_stop_active;
+	if ((status_word & 0x4F) == 0xF)
+		return fault_reaction_active;
+	if ((status_word & 0x4F) == 0x08)
+		return fault;
+	else
+		return no_ready_to_switch_on;
+}
+
+static int servo_axle_switch_mode(int axle)
+{
+	uint16_t status_word = 0;
+	servo_axle_state s = 0;
+	int ret = -1;
+
+	status_word = EC_READ_U16(sec_domain_pd + sec_stat_word(axle));
+	s = get_axle_state(status_word);
+
+	switch (s) {
+	case (no_ready_to_switch_on):
+	case (switch_on_disable):
+		EC_WRITE_U16(sec_domain_pd + sec_ctrl_word(axle), contrlword_shutdown(0));
+		break;
+	case (ready_to_switch_on):
+		EC_WRITE_U16(sec_domain_pd + sec_ctrl_word(axle), contrlword_switch_on(0));
+		break;
+	case (switched_on):
+		EC_WRITE_U8(sec_domain_pd + sec_op_mode(axle), op_mode_csp);
+		EC_WRITE_U16(sec_domain_pd + sec_ctrl_word(axle), contrlword_enable_operation(0));
+		break;
+	case (operation_enable):
+		ret = 0;
+		break;
+	case (quick_stop_active):
+	case (fault_reaction_active):
+		ret = -3;
+		break;
+	case (fault):
+		EC_WRITE_U16(sec_domain_pd + sec_ctrl_word(axle), contrlword_fault_reset(0));
+		ret = -4;
+		break;
+	default:
+		ret = -2;
+	}
+
+	return ret;
+}
+
+static int update_motor_position(int axle)
+{
+	motor_axle_info_t *paxle = sp_axle_info + axle;
+	int ret = 0;
+
+	ret = servo_axle_switch_mode(axle);
+	if (ret)
+		return ret;
+
+	if (!paxle->init_flag) {
+		paxle->base_pos = EC_READ_U16(sec_domain_pd + sec_actual_pos(axle));
+		paxle->fratio = sec_rate / 1000.0;
+		paxle->init_flag = 1;
+	}
+
+	if (sexit_flag && (paxle->pos_idx == 0)) {
+		paxle->sec_cnt++;
+		if (paxle->sec_cnt > 3000)
+			sloop_flag = 0;
+		return 0;
+	}
+
+	if (paxle->ctrl_flag) {
+		paxle->pos_idx++;
+		if (sexit_flag && (paxle->pos_idx > 0))
+			paxle->ctrl_flag = 0;
+		else if (paxle->pos_idx >= 10000)  /* rotate forward for 10s */
+			paxle->ctrl_flag = 0;
+	} else {
+		paxle->pos_idx--;
+		if (sexit_flag && (paxle->pos_idx < 0))
+			paxle->ctrl_flag = 1;
+		else if (paxle->pos_idx <= -10000)  /* rotate backward for 10s */
+			paxle->ctrl_flag = 1;
+	}
+
+	paxle->cur_pos = paxle->base_pos + paxle->fratio * paxle->pos_idx;
+	EC_WRITE_U32(sec_domain_pd + sec_target_pos(axle), paxle->cur_pos);
+
+	return 0;
+}
+
+int set_rt_task_priority(void)
+{
+	struct sched_param param;
+	int ret = 0;
+
+	param.sched_priority = sched_get_priority_max(SCHED_FIFO);
+	printf("%s(): current sched_priority:%d\n", __func__, param.sched_priority);
+
+	ret = sched_setscheduler(getpid(), SCHED_FIFO, &param);
+	if (ret == -1)
+		printf("%s(): sched_setscheduler failed! ret:%d\n", __func__, ret);
+
+	return ret;
+}
+
+void run_main_cycle_task(void)
+{
+	struct timespec cycletime = {0, CYCLE_TIME_NS};
+	ec_master_state_t master_state;
+	struct timespec wakeupTime;
+	struct timespec start_time;
+	int axle = 0;
+
+	set_rt_task_priority();
+
+#ifdef EC_MASTER_IN_USERSPACE
+	ecus_bind_cpu_core(EC_BIND_CORE_MASK);
+#endif
+
+	sloop_flag = 1;
+	clock_gettime(CLOCK_TYPE, &wakeupTime);
+	while (sloop_flag) {
+		wakeupTime = timespec_add(wakeupTime, cycletime);
+		clock_nanosleep(CLOCK_TYPE, TIMER_ABSTIME, &wakeupTime, NULL);
+		clock_gettime(CLOCK_TYPE, &start_time);
+
+		/* receive process data */
+		ecrt_master_receive(sec_master);
+		ecrt_domain_process(sec_domain);
+
+		/* time sync and reference clock */
+		ecrt_master_application_time(sec_master, TIMESPEC2NS(start_time));
+		ecrt_master_sync_reference_clock(sec_master);
+		ecrt_master_sync_slave_clocks(sec_master);
+
+#ifdef EC_MASTER_IN_USERSPACE
+		ecus_master_operation_loop(sec_master, 1);
+#endif
+
+		if (sall_op_flag) {
+			for (axle = 0; axle < sec_axle_num; axle++)
+			      update_motor_position(axle);
+		} else {
+			ecrt_master_state(sec_master, &master_state);
+			if (master_state.al_states == 0x08) {
+				sall_op_flag = 1;
+				printf("EtherCAT master is ALL_OP\n");
+			}
+		}
+
+		/* send process data */
+		ecrt_domain_queue(sec_domain);
+		ecrt_master_send(sec_master);
+
+#ifdef EC_MASTER_IN_USERSPACE
+		ecus_master_operation_loop(sec_master, 0);
+#endif
+	}
+}
+
+void signal_handler(int signum)
+{
+	if (sall_op_flag) {
+		sexit_flag = 1;
+		printf("\nSystem will exit after several seconds...\n");
+	} else {
+#ifdef EC_MASTER_IN_USERSPACE
+		if (!sloop_flag)
+			ecus_done();
+#endif
+		printf("\nSystem will exit...\n");
+		sloop_flag = 0;
+		exit(0);
+	}
+}
+
+#ifdef EC_MASTER_IN_USERSPACE
+#define MAX_MASTER_NUM (32)
+static int smaster_count = 1;
+static char *smaster_macs[MAX_MASTER_NUM] = {
+	"04:13:07:02:00:13",
+};
+
+static int sbackup_count = 0;
+static char *sbackup_macs[MAX_MASTER_NUM];
+
+int is_all_slaves_ready(void)
+{
+	int ready = 0;
+	int i = 0;
+
+	for (i = 0; i < sec_axle_num; i++) {
+		ready = ecus_slave_is_ready(0, 0, i);
+		if (!ready)
+			return 0;
+	}
+
+	return 1;
+}
+#endif
+
+int main(int argc, char **argv)
+{
+#ifdef EC_MASTER_IN_USERSPACE
+	const char **masters = (const char **)smaster_macs;
+	const char **backups = (const char **)sbackup_macs;
+#endif
+	ec_slave_config_t *pslave_config = NULL;
+	motor_axle_info_t *paxle = NULL;
+	char *pmotor_type = "EtherCAT";
+	ec_reg_pdo_cfg_t *prp  = NULL;
+	ec_slave_info_t slave_info;
+	int axle_offset = 0;
+	int32_t pdo_oft = 0;
+	int ecat_flag = 0;
+	int axle = 0;
+	int sec = 0;
+	int ret = 0;
+	int i = 0;
+
+	signal(SIGTERM, signal_handler);
+	signal(SIGINT, signal_handler);
+
+	if (argc > 1) {
+		if (!strcmp(argv[1], "-h") || !strcmp(argv[1], "--help")) {
+			printf("Usage:\n  %s [encode_rate] [axle_num]\n\n", argv[0]);
+			return 0;
+		}
+		sec_rate = strtoul(argv[1], NULL, 0);
+
+		if (argc > 2)
+			sec_axle_num = strtoul(argv[2], NULL, 0);
+	}
+	printf("%s ec_rate:%d axle_num:%d\n", argv[0], sec_rate, sec_axle_num);
+
+#ifdef EC_MASTER_IN_USERSPACE
+	ret = ecus_init(smaster_count, masters, sbackup_count, backups, 0, CYCLE_TIME_NS, EC_BIND_CORE_MASK);
+	if (ret)
+		RET_ERR(-1, "Failed to init userspace EtherCAT!\n");
+
+	ecat_flag = 1;
+	printf("waiting for slaves ");
+	for (sec = 0; sec < 60; sec++) {
+		if (sexit_flag)
+			break;
+
+		if (is_all_slaves_ready()) {
+			printf("\nAll slaves are ready, sec:%d\n", sec);
+			break;
+		}
+		printf(".");
+		sleep(1);
+	}
+	if (sec == 60)
+		RET_ERR(-2, "Timeout to wait for slave to be ready!\n");
+#endif
+	/* Requests an EtherCAT master for realtime operation */
+	sec_master = ecrt_request_master(0);
+	if (!sec_master)
+		RET_ERR(-3, "Failed to request master!\n");
+
+#ifdef ECAT_RT1180
+	/* Check vendor_id and product_code of the firt motor */
+	ret = ecrt_master_get_slave(sec_master, 0, &slave_info);
+	if (ret == 0) {
+		if ((slave_info.vendor_id == RT1180_VID) && (slave_info.product_code == RT1180_PID)) {
+			srt1180_flag = 1;
+			sec_axle_num = 2;  /* For 2-axles slave */
+			pmotor_type = "i.MXRT1180";
+			axle_offset = get_pdo_entry_offset();
+		}
+	}
+#endif
+	sp_axle_info = (motor_axle_info_t*)calloc(sec_axle_num, sizeof(motor_axle_info_t));
+	if (!sp_axle_info)
+		RET_ERR(-3, "Failed to calloc memory for sp_axle_info!\n");
+
+	for (i = 0; i < sec_axle_num; i++) {
+		paxle = sp_axle_info + i;
+
+		ret = ecrt_master_get_slave(sec_master, i, &slave_info);
+		if (ret == 0) {
+			paxle->vendor_id = slave_info.vendor_id;
+			paxle->product_code = slave_info.product_code;
+		} else {
+			RET_ERR(-4, "Failed to get slave information!\n");
+		}
+
+		if (srt1180_flag)
+			break;
+	}
+
+	ret = update_axle_config(sec_axle_num);
+	if (ret)
+		RET_ERR(ret, "Failed to update axle config!\n");
+
+	printf("\n ec_motor_example for %s motor control\n\n", pmotor_type);
+
+	/* Creates a new process data domain */
+	sec_domain = ecrt_master_create_domain(sec_master);
+	if (!sec_domain)
+		RET_ERR(-5, "Failed to create domain for master!\n");
+
+axle_cfg:
+	paxle = sp_axle_info + axle;
+	printf("Configuring for axle-%d vendor_id:0x%X product_code:0x%X\n", axle, paxle->vendor_id, paxle->product_code);
+	/* Obtains slave configuration */
+	pslave_config = ecrt_master_slave_config(sec_master, 0, axle, paxle->vendor_id, paxle->product_code);
+	if (!pslave_config)
+		RET_ERR(-6, "Failed to get slave configuration!\n");
+
+	if (!srt1180_flag) {
+		ecrt_slave_config_sdo32(pslave_config, 0x6083, 0, 0x1000);  /* Profile_acceleration */
+		ecrt_slave_config_sdo32(pslave_config, 0x6084, 0, 0x1000);  /* Profile_deceleration */
+		ecrt_slave_config_sdo32(pslave_config, 0x6085, 0, 0x1000);  /* Quick_stop_deceleration */
+	}
+	ecrt_slave_config_watchdog(pslave_config, 0, 4000);
+	ecrt_slave_config_dc(pslave_config, 0x0300, CYCLE_TIME_NS, 0, 0, 0);
+
+	if (ecrt_slave_config_pdos(pslave_config, NUM_OF(sec_sync_mgr), sec_sync_mgr))
+		RET_ERR(-7, "Failed to configure PDOs!\n");
+
+axle_cfg_1180:
+	for (i = 0; i < NUM_OF(sec_reg_pdo_cfg); i++) {
+		prp = sec_reg_pdo_cfg + i;
+
+		pdo_oft = ecrt_slave_config_reg_pdo_entry(pslave_config, prp->index, prp->subindex, sec_domain, NULL);
+		if (pdo_oft < 0)
+			RET_ERR(-8, "Failed to register PDO entry!\n");
+
+		if (prp->poffset)
+			*(prp->poffset + axle) = (pdo_oft + axle * axle_offset);
+	}
+	if (++axle < sec_axle_num) {
+		if (srt1180_flag)
+			goto axle_cfg_1180;
+		else
+			goto axle_cfg;
+	}
+
+	printf("Activating master...\n");
+	if (ecrt_master_activate(sec_master))
+		RET_ERR(-9, "Failed to activate master!\n");
+
+	sec_domain_pd = ecrt_domain_data(sec_domain);
+	if (!sec_domain_pd)
+		RET_ERR(-10, "Failed to get domain data!\n");
+
+	run_main_cycle_task();
+
+ret_tag:
+	FREE(sp_axle_info);
+	FREE(sp_axle_data);
+
+#ifdef EC_MASTER_IN_USERSPACE
+	if (ecat_flag)
+	      ecus_done();
+#endif
+
+	return 0;
+}
diff --git a/globals.h b/globals.h
index c484cda3..0a40fefa 100644
--- a/globals.h
+++ b/globals.h
@@ -48,10 +48,11 @@
 
 /** Master version string
  */
-#define EC_MASTER_VERSION VERSION " " EC_STR(REV)
 
 /*****************************************************************************/
 #ifdef EC_MASTER_IN_USERSPACE
+#define EC_MASTER_VERSION VERSION " (user-space)"
+
 // Always 0-terminate dest; avoid newer GCC's warnings about strncpy when possibly truncating.
 static inline void ec_strncpy(char *dest, const char *src, unsigned long int n)
 {
@@ -61,6 +62,8 @@ static inline void ec_strncpy(char *dest, const char *src, unsigned long int n)
   while (dest < end)
     *dest++ = 0;
 }
+#else
+#define EC_MASTER_VERSION VERSION " " EC_STR(REV)
 #endif  /* EC_MASTER_IN_USERSPACE */
 
 #endif
diff --git a/include/ecrt.h b/include/ecrt.h
index 3eef9022..ad21be9b 100644
--- a/include/ecrt.h
+++ b/include/ecrt.h
@@ -632,10 +632,17 @@ extern "C" {
 #endif
 
 #ifdef EC_MASTER_IN_USERSPACE
-int ecrt_init(unsigned int master_count_, const char *const *master_macs,
-              unsigned int backup_count_, const char *const *backup_macs,
-              unsigned int debug_level_);
-void ecrt_done(void);
+int ecus_init(uint32_t master_count, const char *const *master_macs,
+              uint32_t backup_count, const char *const *backup_macs,
+              uint32_t debug_level, uint32_t cycle_ns, uint32_t core_mask);
+int ecus_done(void);
+
+int ecus_slave_is_ready(uint32_t master_index, uint16_t alias, uint16_t position);
+int ecus_master_operation_loop(ec_master_t *master, int cycle);
+int ecus_enable_ioctl_poll(void);
+
+int ecus_bind_cpu_core(uint32_t core_mask);
+uint32_t ecus_get_core_mask(void);
 #endif
 
 /** Returns the version magic of the realtime interface.
diff --git a/libecat.mri b/libecat.mri
new file mode 100644
index 00000000..7f2129e6
--- /dev/null
+++ b/libecat.mri
@@ -0,0 +1,5 @@
+create libethercat_master.a
+addlib ./ecat_build/lib/libethercat_master.a
+addlib ./devices/nxp_userspace/libus_drv.a
+save
+end
diff --git a/master/Makefile.am b/master/Makefile.am
index 709f496b..8ade0c1c 100644
--- a/master/Makefile.am
+++ b/master/Makefile.am
@@ -83,12 +83,14 @@ lib_LTLIBRARIES = libethercat_master.la
 pkgconfig_DATA = libethercat_master.pc
 EXTRA_DIST = libethercat_master.pc.in
 
-libethercat_master_la_LDFLAGS = -version-info 1:0:0
+libethercat_master_la_LDFLAGS = -version-info 1:0:0 \
+	-L../devices/nxp_userspace/ \
+	-lus_drv
 
 libethercat_master_la_CFLAGS = -I$(srcdir)/.. \
 	-I../emulation \
+	-I../devices/nxp_userspace/ \
 	-D__KERNEL__ \
-	-DEC_HAVE_CYCLES \
 	-DEC_USE_HRTIMER \
 	-DEC_MASTER_IN_USERSPACE \
 	-Wall -Werror \
@@ -135,6 +137,7 @@ libethercat_master_la_SOURCES = \
 	sync.c \
 	sync_config.c \
 	voe_handler.c \
+	../devices/nxp_userspace/usm_main.c \
 	../devices/generic.c
 if ENABLE_EOE
 libethercat_master_la_SOURCES += ethernet.c
diff --git a/master/cdev.c b/master/cdev.c
index 404e0fcf..9d50ad5b 100644
--- a/master/cdev.c
+++ b/master/cdev.c
@@ -30,6 +30,11 @@
 #include <linux/vmalloc.h>
 #include <linux/mm.h>
 
+#ifdef EC_MASTER_IN_USERSPACE
+#include <sys/ipc.h>
+#include <sys/shm.h>
+#endif
+
 #include "cdev.h"
 #include "master.h"
 #include "slave_config.h"
@@ -48,26 +53,62 @@
 typedef struct {
     ec_cdev_t *cdev; /**< Character device. */
     ec_ioctl_context_t ctx; /**< Context. */
+#ifdef EC_MASTER_IN_USERSPACE
+    void *pmem;
+    int shmid;
+#endif
 } ec_cdev_priv_t;
 
 /*****************************************************************************/
 
 #ifdef EC_MASTER_IN_USERSPACE
 
-static ec_master_t *sec_masters[MAX_MASTER_NUM];
-static ec_cdev_priv_t sec_privs[MAX_MASTER_NUM];
+static int ec_cdev_alloc_share_memory(ec_master_t *master)
+{
+    ec_cdev_priv_t *priv = NULL;
+    uint8_t *pmem = NULL;
+    int shmid = 0;
+    key_t key = 0;
+
+    key = ftok("/tmp/", 0x88A4 + master->index);
+    if (key == -1) {
+        EC_MASTER_ERR(master, "%s(): ftok failed! key:%d\n", __func__, key);
+        return -1;
+    }
+
+    shmid = shmget(key, 4096, IPC_CREAT | 0666);
+    if (shmid < 0) {
+        EC_MASTER_ERR(master, "%s(): shmget failed! shmid:%d\n", __func__, shmid);
+        return -2;
+    }
+
+    pmem = shmat(shmid, NULL, 0);
+    if (!pmem) {
+        EC_MASTER_ERR(master, "%s(): shmat failed! shmid:%d\n", __func__, shmid);
+        return -3;
+    }
+
+    priv = (ec_cdev_priv_t *)master->priv;
+
+    priv->pmem = pmem;
+    priv->shmid = shmid;
+    master->ioctl_mem = pmem + 1024;
+
+    return 0;
+}
 
 int ec_cdev_usecat_start(ec_master_t *master)
 {
     ec_cdev_priv_t *priv = NULL;
 
-    if (master->index >= MAX_MASTER_NUM) {
-        printf("%s: invalid master index:%d!\n", __func__, master->index);
+    priv = malloc(sizeof(*priv));
+    if (!priv) {
+        EC_MASTER_ERR(master, "%s(): malloc for private data failed!\n", __func__);
         return -1;
     }
 
-    priv = sec_privs + master->index;
-    sec_masters[master->index] = master;
+    master->priv = priv;
+    memset(priv, 0, sizeof(*priv));
 
     priv->cdev = &master->cdev;
     priv->ctx.writable = 1;
@@ -75,14 +116,66 @@ int ec_cdev_usecat_start(ec_master_t *master)
     priv->ctx.process_data = NULL;
     priv->ctx.process_data_size = 0;
 
-    return 0;
+    return ec_cdev_alloc_share_memory(master);
 }
 
 int ec_cdev_usecat_stop(ec_master_t *master)
 {
+    ec_cdev_priv_t *priv = (ec_cdev_priv_t *)master->priv;
+
+    if (!priv)
+        return -1;
+
+    if (priv->pmem) {
+        shmdt(priv->pmem);
+        shmctl(priv->shmid, IPC_RMID, NULL);
+    }
+
+    free(priv);
+
     return 0;
 }
 
+static int eccdev_usecat_ioctl(ec_master_t *master, unsigned int cmd, void *arg)
+{
+    ec_cdev_priv_t *priv = (ec_cdev_priv_t *)master->priv;
+
+    return ec_ioctl(master, &priv->ctx, cmd, (void __user *)arg);
+}
+
+int ec_master_ioctl_poll(void *priv_data)
+{
+    ec_master_t *master = (ec_master_t *)priv_data;
+    volatile struct ecat_shm_info *pshm = NULL;
+    ec_cdev_priv_t *priv = NULL;
+    uint8_t *parg = NULL;
+    uint32_t index = 0;
+    int ret = 0;
+
+    priv = (ec_cdev_priv_t *)master->priv;
+
+    pshm = (volatile struct ecat_shm_info *)priv->pmem;
+    parg = (uint8_t*)(priv->pmem + sizeof(*pshm));
+
+    if (pshm->flag != 1)
+        return 0;
+
+    index = pshm->index;
+    if (index != master->index) {
+        EC_MASTER_ERR(master, "%s: index is invalid! %d != %d\n", __func__, index, master->index);
+        return -1;
+    }
+
+    if (pshm->len > 0)
+        ret = eccdev_usecat_ioctl(master, pshm->cmd, parg);
+    else
+        ret = eccdev_usecat_ioctl(master, pshm->cmd, (void*)(*(uint64_t *)parg));
+
+    pshm->flag = 2;
+
+    return ret;
+}
+
 #else /* EC_MASTER_IN_USERSPACE */
 
 /****************************************************************************/
@@ -167,27 +260,8 @@ void ec_cdev_clear(ec_cdev_t *cdev /**< EtherCAT XML device */)
     cdev_del(&cdev->cdev);
 }
 
-#ifdef EC_MASTER_IN_USERSPACE
-
-int eccdev_usecat_ioctl(int fd, unsigned int cmd, void *arg)
-{
-    ec_cdev_priv_t *priv = NULL;
-    ec_master_t *master = NULL;
-
-    if (fd >= MAX_MASTER_NUM) {
-        printf("%s: fd is invalid! fd:%d\n", __func__, fd);
-        return -1;
-    }
-
-    master = sec_masters[fd];
-    priv = sec_privs + fd;
-
-    return ec_ioctl(master, &priv->ctx, cmd, (void __user *) arg);
-}
-
-#else /* EC_MASTER_IN_USERSPACE */
+#ifndef EC_MASTER_IN_USERSPACE
 
-/*****************************************************************************
  * File operations
  ****************************************************************************/
 
diff --git a/master/cdev.h b/master/cdev.h
index 429180ad..e9deb1f0 100644
--- a/master/cdev.h
+++ b/master/cdev.h
@@ -43,9 +43,15 @@ typedef struct {
     struct cdev cdev; /**< Character device. */
 } ec_cdev_t;
 
-/****************************************************************************/
-
 #ifdef EC_MASTER_IN_USERSPACE
+struct ecat_shm_info {
+    uint32_t flag;
+    uint32_t index;
+    uint32_t cmd;
+    uint32_t len;
+} __attribute__((packed));
+
+/****************************************************************************/
 int ec_cdev_usecat_start(ec_master_t *master);
 int ec_cdev_usecat_stop(ec_master_t *master);
 #endif
diff --git a/master/datagram.h b/master/datagram.h
index 13184928..91eb4627 100644
--- a/master/datagram.h
+++ b/master/datagram.h
@@ -31,10 +31,13 @@
 
 #include <linux/list.h>
 #include <linux/time.h>
-#include <linux/timex.h>
 
 #include "globals.h"
 
+#ifndef EC_USERSPACE_MASTER_NEW
+#include <linux/timex.h>
+#endif
+
 /****************************************************************************/
 
 /** EtherCAT datagram type.
diff --git a/master/device.c b/master/device.c
index 598d163a..e8521f70 100644
--- a/master/device.c
+++ b/master/device.c
@@ -57,6 +57,30 @@ enum {
  *
  * \return 0 in case of success, else < 0
  */
+#ifdef EC_USERSPACE_MASTER_NEW
+uint8_t* us_drv_get_tx_buf(int idx);
+static inline struct sk_buff *dev_alloc_ecat_skb(int i)
+{
+    struct sk_buff *buf = NULL;
+
+    buf = malloc(sizeof(struct sk_buff));
+    if(!buf)
+        return NULL;
+
+    buf->len = 0;
+    buf->free_buf = 0;
+#ifdef EC_USERSPACE_MASTER_NEW
+    buf->data = buf->head = buf->tail = us_drv_get_tx_buf(i);
+#endif
+    if (!buf->head) {
+        free(buf);
+        return NULL;
+    }
+
+    return buf;
+}
+#endif
+
 int ec_device_init(
         ec_device_t *device, /**< EtherCAT device */
         ec_master_t *master /**< master owning the device */
@@ -79,7 +103,12 @@ int ec_device_init(
     for (i = 0; i < EC_TX_RING_SIZE; i++) {
         device->tx_skb[i] = NULL;
     }
+#ifdef EC_USERSPACE_MASTER_NEW
+    device->tx_ring_index = (unsigned int)-1;
+#else
     device->tx_ring_index = 0;
+#endif
+
 #ifdef EC_HAVE_CYCLES
     device->cycles_poll = 0;
 #endif
@@ -124,15 +153,23 @@ int ec_device_init(
 #endif
 
     for (i = 0; i < EC_TX_RING_SIZE; i++) {
+#ifdef EC_USERSPACE_MASTER_NEW
+        if (!(device->tx_skb[i] = dev_alloc_ecat_skb(i))) {
+#else
         if (!(device->tx_skb[i] = dev_alloc_skb(ETH_FRAME_LEN + EXTRA_HEADROOM))) {
+#endif
             EC_MASTER_ERR(master, "Error allocating device socket buffer!\n");
             ret = -ENOMEM;
             goto out_tx_ring;
         }
 
         // add Ethernet-II-header
-        skb_reserve(device->tx_skb[i], ETH_HLEN + EXTRA_HEADROOM);
-        eth = (struct ethhdr *) skb_push(device->tx_skb[i], ETH_HLEN);
+#ifdef EC_USERSPACE_MASTER_NEW
+	skb_reserve(device->tx_skb[i], ETH_HLEN);
+#else
+	skb_reserve(device->tx_skb[i], ETH_HLEN + EXTRA_HEADROOM);
+#endif
+	eth = (struct ethhdr *) skb_push(device->tx_skb[i], ETH_HLEN);
         eth->h_proto = htons(0x88A4);
         memset(eth->h_dest, 0xFF, ETH_ALEN);
     }
@@ -141,10 +178,10 @@ int ec_device_init(
 
 out_tx_ring:
     for (i = 0; i < EC_TX_RING_SIZE; i++) {
-        if (device->tx_skb[i]) {
+        if (device->tx_skb[i])
             dev_kfree_skb(device->tx_skb[i]);
-        }
     }
+
 #ifdef EC_DEBUG_IF
     ec_debug_clear(&device->dbg);
 out_return:
@@ -167,6 +204,7 @@ void ec_device_clear(
     }
     for (i = 0; i < EC_TX_RING_SIZE; i++)
         dev_kfree_skb(device->tx_skb[i]);
+
 #ifdef EC_DEBUG_IF
     ec_debug_clear(&device->dbg);
 #endif
diff --git a/master/device.h b/master/device.h
index 82425e34..bc04ec0c 100644
--- a/master/device.h
+++ b/master/device.h
@@ -41,8 +41,12 @@
  * send the same data twice, if it is called twice.
  */
 #ifdef EC_MASTER_IN_USERSPACE
-#define EC_TX_RING_SIZE 16
+#ifdef EC_USERSPACE_MASTER_NEW
+#define EC_TX_RING_SIZE MAX_TX_BD_RING_SIZE
 #else
+#define EC_TX_RING_SIZE 16
+#endif
+#else  /* EC_MASTER_IN_USERSPACE */
 #define EC_TX_RING_SIZE 2
 #endif
 
@@ -66,6 +70,11 @@ typedef struct {
 
 #endif
 
+#ifdef EC_USERSPACE_MASTER_NEW
+#define MAX_TX_BD_RING_SIZE (16)
+#define MAX_RX_BD_RING_SIZE (16)
+#endif
+
 /****************************************************************************/
 
 /**
diff --git a/master/ethercat_master.c b/master/ethercat_master.c
index c2d6fde9..b762918c 100644
--- a/master/ethercat_master.c
+++ b/master/ethercat_master.c
@@ -24,6 +24,25 @@
 
 volatile sig_atomic_t stop = 0;
 
+#ifdef EC_USERSPACE_MASTER_NEW
+int ecus_init(uint32_t master_count, const char *const *master_macs,
+              uint32_t backup_count, const char *const *backup_macs,
+              uint32_t debug_level, uint32_t cycle_ns, uint32_t core_mask);
+int ecus_done(void);
+int ecus_enable_ioctl_poll(void);
+
+#define MAX_MASTER_NUM (32)
+
+static int smaster_count = 1;
+static char *smaster_macs[MAX_MASTER_NUM] = {
+    "04:13:07:02:00:13",
+};
+
+static int sbackup_count = 0;
+static char *sbackup_macs[MAX_MASTER_NUM];
+static int sdebug_level = 0;
+#endif  /* EC_USERSPACE_MASTER_NEW */
+
 static void handler(int sig)
 {
     (void)sig;
@@ -44,9 +63,21 @@ int main(int argc, const char **argv)
     unsigned int debug_level = 0;
     unsigned int master_count = 0;
     unsigned int backup_count = 0;
+
+#ifdef EC_USERSPACE_MASTER_NEW
+    const char **masters = (const char **)smaster_macs;
+    const char **backups = (const char **)sbackup_macs;
+
+    ecus_enable_ioctl_poll();
+
+    master_count = smaster_count;
+    backup_count = sbackup_count;
+    debug_level = sdebug_level;
+#else
     const char **masters = alloca(argc * sizeof(const char *));
     const char **backups = alloca(argc * sizeof(const char *));
     int i;
+
     for (i = 1; i < argc; i++) {
         const char *s = argv[i];
         if (strcmp(s, "--help") == 0) {
@@ -77,9 +108,10 @@ int main(int argc, const char **argv)
             return EXIT_FAILURE;
         }
     }
+#endif
 
     /* Initialize. */
-    int r = ecrt_init(master_count, masters, backup_count, backups, debug_level);
+    int r = ecus_init(master_count, masters, backup_count, backups, debug_level, 0, 0x02);
     if (r) {
         fprintf(stderr, "*** Cannot initialize EtherCAT: %s.\n", strerror(-r));
         return EXIT_FAILURE;
@@ -90,7 +122,7 @@ int main(int argc, const char **argv)
     for (j = 0; j < master_count; j++) {
         if (!ecrt_open_master(j)) {
             fprintf(stderr, "*** Cannot open master %i.\n", j);
-            ecrt_done();
+            ecus_done();
             return EXIT_FAILURE;
         }
     }
@@ -101,6 +133,6 @@ int main(int argc, const char **argv)
     signal(SIGHUP,  handler);
     while (!stop)
         pause();
-    ecrt_done();
+    ecus_done();
     return EXIT_SUCCESS;
 }
diff --git a/master/globals.h b/master/globals.h
index da738e8b..4244b56a 100644
--- a/master/globals.h
+++ b/master/globals.h
@@ -241,8 +241,12 @@ extern const char *ec_device_names[2]; // only main and backup!
  * \param fmt format string (like in printf())
  * \param args arguments (optional)
  */
+#ifdef EC_USERSPACE_MASTER_NEW
+#define EC_DBG(fmt, args...)
+#else
 #define EC_DBG(fmt, args...) \
     printk(KERN_DEBUG "EtherCAT DEBUG: " fmt, ##args)
+#endif
 
 /****************************************************************************/
 
diff --git a/master/ioctl.c b/master/ioctl.c
index a3d4ddd5..56c85dd0 100644
--- a/master/ioctl.c
+++ b/master/ioctl.c
@@ -84,7 +84,7 @@ static void ec_ioctl_strcpy(
         )
 {
     if (source) {
-        strncpy(target, source, EC_IOCTL_STRING_SIZE);
+        strncpy(target, source, EC_IOCTL_STRING_SIZE - 1);
         target[EC_IOCTL_STRING_SIZE - 1] = 0;
     } else {
         target[0] = 0;
@@ -836,6 +836,10 @@ static ATTRIBUTES int ec_ioctl_slave_sdo_upload(
         return -EFAULT;
     }
 
+#ifdef EC_MASTER_IN_USERSPACE
+    data.target = master->ioctl_mem;
+#endif
+
     if (!(target = kmalloc(data.target_size, GFP_KERNEL))) {
         EC_MASTER_ERR(master, "Failed to allocate %zu bytes"
                 " for SDO upload.\n", data.target_size);
@@ -882,6 +886,10 @@ static ATTRIBUTES int ec_ioctl_slave_sdo_download(
         return -EFAULT;
     }
 
+#ifdef EC_MASTER_IN_USERSPACE
+    data.data = master->ioctl_mem;
+#endif
+
     if (!(sdo_data = kmalloc(data.data_size, GFP_KERNEL))) {
         EC_MASTER_ERR(master, "Failed to allocate %zu bytes"
                 " for SDO download.\n", data.data_size);
@@ -930,6 +938,10 @@ static ATTRIBUTES int ec_ioctl_slave_sii_read(
         return -EFAULT;
     }
 
+#ifdef EC_MASTER_IN_USERSPACE
+    data.words = (uint16_t*)master->ioctl_mem;
+#endif
+
     if (down_interruptible(&master->master_sem))
         return -EINTR;
 
@@ -984,6 +996,10 @@ static ATTRIBUTES int ec_ioctl_slave_sii_write(
         return 0;
     }
 
+#ifdef EC_MASTER_IN_USERSPACE
+    data.words = (uint16_t*)master->ioctl_mem;
+#endif
+
     byte_size = sizeof(uint16_t) * data.nwords;
     if (!(words = kmalloc(byte_size, GFP_KERNEL))) {
         EC_MASTER_ERR(master, "Failed to allocate %u bytes"
@@ -1071,6 +1087,10 @@ static ATTRIBUTES int ec_ioctl_slave_reg_read(
         return 0;
     }
 
+#ifdef EC_MASTER_IN_USERSPACE
+    io.data = master->ioctl_mem;
+#endif
+
     // init register request
     ret = ec_reg_request_init(&request, io.size);
     if (ret) {
@@ -1153,6 +1173,10 @@ static ATTRIBUTES int ec_ioctl_slave_reg_write(
         return 0;
     }
 
+#ifdef EC_MASTER_IN_USERSPACE
+    io.data = master->ioctl_mem;
+#endif
+
     // init register request
     ret = ec_reg_request_init(&request, io.size);
     if (ret) {
@@ -4608,6 +4632,10 @@ static ATTRIBUTES int ec_ioctl_slave_foe_read(
         return -EFAULT;
     }
 
+#ifdef EC_MASTER_IN_USERSPACE
+    io.buffer = master->ioctl_mem;
+#endif
+
     ec_foe_request_init(&request, io.file_name);
     ret = ec_foe_request_alloc(&request, 10000); // FIXME
     if (ret) {
@@ -4704,6 +4732,10 @@ static ATTRIBUTES int ec_ioctl_slave_foe_write(
         return -EFAULT;
     }
 
+#ifdef EC_MASTER_IN_USERSPACE
+    io.buffer = master->ioctl_mem;
+#endif
+
     ec_foe_request_init(&request, io.file_name);
 
     ret = ec_foe_request_alloc(&request, io.buffer_size);
@@ -4791,6 +4823,10 @@ static ATTRIBUTES int ec_ioctl_slave_soe_read(
         return -EFAULT;
     }
 
+#ifdef EC_MASTER_IN_USERSPACE
+    ioctl.data = master->ioctl_mem;
+#endif
+
     data = kmalloc(ioctl.mem_size, GFP_KERNEL);
     if (!data) {
         EC_MASTER_ERR(master, "Failed to allocate %zu bytes of IDN data.\n",
@@ -4840,6 +4876,10 @@ static ATTRIBUTES int ec_ioctl_slave_soe_write(
         return -EFAULT;
     }
 
+#ifdef EC_MASTER_IN_USERSPACE
+    ioctl.data = master->ioctl_mem;
+#endif
+
     data = kmalloc(ioctl.data_size, GFP_KERNEL);
     if (!data) {
         EC_MASTER_ERR(master, "Failed to allocate %zu bytes of IDN data.\n",
diff --git a/master/ioctl.h b/master/ioctl.h
index 33bd8b9d..02abfc6a 100644
--- a/master/ioctl.h
+++ b/master/ioctl.h
@@ -847,10 +847,9 @@ typedef struct {
 #define copy_from_user(DST, SRC, SIZE) (memcpy((DST), (SRC), (SIZE)), 0)
 #define copy_to_user(DST, SRC, SIZE) (memcpy((DST), (SRC), (SIZE)), 0)
 #define __copy_to_user copy_to_user
-#define MAX_MASTER_NUM (32)
 #define __user
 
-int eccdev_usecat_ioctl(int fd, unsigned int cmd, void *arg);
+int ec_master_ioctl_poll(void *priv_data);
 
 /* Emulated ioctl via TCP connection for userspace master */
 static inline int ioctl_usecat_open(int master_index, const char *host)
diff --git a/master/master.c b/master/master.c
index d73eda13..3a9fd8f0 100644
--- a/master/master.c
+++ b/master/master.c
@@ -135,6 +135,9 @@ static void sc_reset_task(struct work_struct *work);
 #endif
 
 #ifdef EC_MASTER_IN_USERSPACE
+static int ec_master_start_ioctl_thread(ec_master_t *master);
+static int ec_master_stop_ioctl_thread(ec_master_t *master);
+
 void ec_master_nanosleep(const unsigned long nsecs)
 {
     struct timespec t = { 0, nsecs }, r;
@@ -422,6 +425,7 @@ void ec_master_clear(
     unsigned int dev_idx, i;
 
 #ifdef EC_MASTER_IN_USERSPACE
+    ec_master_stop_ioctl_thread(master);
     ec_cdev_usecat_stop(master);
 #else
 #ifdef EC_RTDM
@@ -1409,7 +1413,19 @@ void ec_master_update_device_stats(
 
 /****************************************************************************/
 
-#ifndef EC_MASTER_IN_USERSPACE
+#ifdef EC_MASTER_IN_USERSPACE
+
+extern int ec_master_ioctl_poll(void *priv_data);
+static int sec_ioctl_poll_flag = 0;
+
+int ecus_enable_ioctl_poll(void)
+{
+    sec_ioctl_poll_flag = 1;
+    return 0;
+}
+
+#else
+
 #ifdef EC_USE_HRTIMER
 
 /*
@@ -1548,6 +1564,59 @@ void ec_master_exec_slave_fsms(
 
 /****************************************************************************/
 
+#ifdef EC_MASTER_IN_USERSPACE
+static void* ec_master_ioctl_thread(void *priv_data)
+{
+    ec_master_t *master = (ec_master_t *)priv_data;
+
+    EC_MASTER_INFO(master, "Starting master ioctl thread.\n");
+
+    while (master->ioctl_thread_run) {
+        if (sec_ioctl_poll_flag)
+            ec_master_ioctl_poll(priv_data);
+
+        ec_master_nanosleep(master->send_interval * 30);
+    }
+
+    EC_MASTER_INFO(master, "Exiting master ioctl thread.\n");
+
+    return NULL;
+}
+
+static int ec_master_start_ioctl_thread(ec_master_t *master)
+{
+    int ret = 0;
+
+    if (!master->ioctl_thread) {
+        ret = pthread_create(&master->ioctl_thread_id, NULL, ec_master_ioctl_thread, master);
+        if (ret == 0) {
+            master->ioctl_thread_run = 1;
+            master->ioctl_thread = &master->ioctl_thread_id;
+	} else {
+            EC_MASTER_WARN(master, "Failed to start master IOCTL thread!\n");
+	}
+    }
+
+    return 0;
+}
+
+static int ec_master_stop_ioctl_thread(ec_master_t *master)
+{
+    int ret = 0;
+
+    if (master->ioctl_thread) {
+        master->ioctl_thread_run = 0;
+
+	ret = pthread_join(*master->ioctl_thread, NULL);
+        master->ioctl_thread = NULL;
+    }
+
+    return ret;
+}
+#endif
+
+/****************************************************************************/
+
 /** Master kernel thread function for IDLE phase.
  */
 static int ec_master_idle_thread(void *priv_data)
@@ -1558,6 +1627,10 @@ static int ec_master_idle_thread(void *priv_data)
     size_t sent_bytes;
 #endif
 
+#ifdef EC_MASTER_IN_USERSPACE
+    ec_master_start_ioctl_thread(master);
+#endif
+
     // send interval in IDLE phase
     ec_master_set_send_interval(master, 1000000 / HZ);
 
@@ -1600,7 +1673,11 @@ static int ec_master_idle_thread(void *priv_data)
 
         if (ec_fsm_master_idle(&master->fsm)) {
 #ifdef EC_USE_HRTIMER
+#ifdef EC_USERSPACE_MASTER_NEW
+            ec_master_nanosleep(master->send_interval * 10);
+#else
             ec_master_nanosleep(master->send_interval * 1000);
+#endif
 #else
             set_current_state(TASK_INTERRUPTIBLE);
             schedule_timeout(1);
@@ -1621,6 +1698,57 @@ static int ec_master_idle_thread(void *priv_data)
 
 /****************************************************************************/
 
+#ifdef EC_USERSPACE_MASTER_NEW
+static uint64_t sop_cycle_us_sum;
+static uint32_t sop_cycle_us = 0;
+
+int ec_master_set_noop_mode(uint32_t cycle_ns)
+{
+    sop_cycle_us = cycle_ns / 1000;
+    return 0;
+}
+
+int ec_master_in_noop_mode(void)
+{
+    return (sop_cycle_us > 0);
+}
+
+uint64_t ec_master_cycle_us(void)
+{
+    return sop_cycle_us_sum;
+}
+
+int ecus_master_operation_loop(ec_master_t *master, int cycle)
+{
+    if (!ec_master_in_noop_mode())
+        return 0;
+
+    if (cycle)
+        sop_cycle_us_sum += sop_cycle_us;
+
+    if (master->active) {
+        ec_datagram_output_stats(&master->fsm_datagram);
+
+        if (master->injection_seq_rt == master->injection_seq_fsm) {
+            // output statistics
+            ec_master_output_stats(master);
+
+            if (ec_fsm_master_exec(&master->fsm)) {
+                // Inject datagrams (let the RT thread queue them, see
+                // ecrt_master_send())
+                master->injection_seq_fsm++;
+            }
+
+            ec_master_exec_slave_fsms(master);
+        }
+    }
+
+    return 0;
+}
+#endif
+
+/****************************************************************************/
+
 /** Master kernel thread function for OPERATION phase.
  */
 static int ec_master_operation_thread(void *priv_data)
@@ -1656,7 +1784,11 @@ static int ec_master_operation_thread(void *priv_data)
 
 #ifdef EC_USE_HRTIMER
         // the op thread should not work faster than the sending RT thread
+#ifdef EC_USERSPACE_MASTER_NEW
+        ec_master_nanosleep(master->send_interval * 50);
+#else
         ec_master_nanosleep(master->send_interval * 1000);
+#endif
 #else
         if (ec_fsm_master_idle(&master->fsm)) {
             set_current_state(TASK_INTERRUPTIBLE);
@@ -2385,6 +2517,16 @@ int ecrt_master_activate(ec_master_t *master)
         ec_master_eoe_start(master);
     }
 #endif
+
+#ifdef EC_USERSPACE_MASTER_NEW
+    ec_master_stop_ioctl_thread(master);
+
+    if (ec_master_in_noop_mode()) {
+        master->thread = NULL;
+        goto no_op_tag;
+    }
+#endif
+
     ret = ec_master_thread_start(master, ec_master_operation_thread,
                 "EtherCAT-OP");
     if (ret < 0) {
@@ -2392,6 +2534,9 @@ int ecrt_master_activate(ec_master_t *master)
         return ret;
     }
 
+#ifdef EC_USERSPACE_MASTER_NEW
+no_op_tag:
+#endif
     /* Allow scanning after a topology change. */
     master->allow_scan = 1;
 
@@ -2760,7 +2905,7 @@ int ecrt_master_get_slave(ec_master_t *master, uint16_t slave_position,
     slave_info->sync_count = slave->sii.sync_count;
     slave_info->sdo_count = ec_slave_sdo_count(slave);
     if (slave->sii.name) {
-        strncpy(slave_info->name, slave->sii.name, EC_MAX_STRING_LENGTH);
+        strncpy(slave_info->name, slave->sii.name, EC_MAX_STRING_LENGTH - 1);
     } else {
         slave_info->name[0] = 0;
     }
diff --git a/master/master.h b/master/master.h
index e9fcb794..fffbc239 100644
--- a/master/master.h
+++ b/master/master.h
@@ -103,6 +103,15 @@
  * \param fmt format string (like in printf())
  * \param args arguments (optional)
  */
+#ifdef EC_USERSPACE_MASTER_NEW
+#define EC_MASTER_DBG(master, level, fmt, args...) \
+    do { \
+        if (master->debug_level > level) { \
+            printk(KERN_DEBUG "EtherCAT DEBUG %u: " fmt, \
+                    master->index, ##args); \
+        } \
+    } while (0)
+#else
 #define EC_MASTER_DBG(master, level, fmt, args...) \
     do { \
         if (master->debug_level >= level) { \
@@ -110,7 +119,7 @@
                     master->index, ##args); \
         } \
     } while (0)
-
+#endif
 
 /** Size of the external datagram ring.
  *
@@ -306,7 +315,13 @@ struct ec_master {
 
     wait_queue_head_t request_queue; /**< Wait queue for external requests
                                        from user space. */
-#ifndef EC_MASTER_IN_USERSPACE
+#ifdef EC_MASTER_IN_USERSPACE
+    pthread_t		ioctl_thread_id;
+    pthread_t		*ioctl_thread; /**< Master IOCTL thread. */
+    uint8_t		*ioctl_mem;
+    uint8_t		ioctl_thread_run;
+    void *priv;
+#else
     struct work_struct sc_reset_work; /**< Task to reset slave configuration. */
     struct irq_work sc_reset_work_kicker; /**< NMI-Safe kicker to trigger
                                             reset task above. */
@@ -387,6 +402,11 @@ void ec_master_request_op(ec_master_t *);
 void ec_master_internal_send_cb(void *);
 void ec_master_internal_receive_cb(void *);
 
+#ifdef EC_USERSPACE_MASTER_NEW
+int ec_master_in_noop_mode(void);
+uint64_t ec_master_cycle_us(void);
+#endif
+
 extern const unsigned int rate_intervals[EC_RATE_COUNT]; // see master.c
 
 /****************************************************************************/
diff --git a/master/module.c b/master/module.c
index 239ba3fe..22d1ae21 100644
--- a/master/module.c
+++ b/master/module.c
@@ -706,10 +706,16 @@ ec_master_t *ecrt_open_master(
     return master;
 }
 
+#ifdef EC_USERSPACE_MASTER_NEW
+int ec_usm_net_init(uint32_t cycle_ns, uint32_t core_mask);
+int __init ec_usm_init_module(void);
+void __exit ec_usm_cleanup_module(void);
+#endif
+
 int __init ec_gen_init_module(void);
 void __exit ec_gen_cleanup_module(void);
 
-int ecrt_init(unsigned int master_count_, const char *const *master_macs,
+static int ecrt_init(unsigned int master_count_, const char *const *master_macs,
               unsigned int backup_count_, const char *const *backup_macs,
               unsigned int debug_level_)
 {
@@ -741,15 +747,59 @@ int ecrt_init(unsigned int master_count_, const char *const *master_macs,
     r = ec_init_module();
     if (r)
         return r;
+
+#ifdef EC_USERSPACE_MASTER_NEW
+    r = ec_usm_init_module();
+#endif
+
+#ifndef EC_USERSPACE_MASTER_NEW
     r = ec_gen_init_module();
+#endif
     if (r)
         ec_cleanup_module();
     return r;
 }
 
-void ecrt_done(void)
+static void ecrt_done(void)
 {
+#ifdef EC_USERSPACE_MASTER_NEW
+    ec_usm_cleanup_module();
+#endif
+
+#ifndef EC_USERSPACE_MASTER_NEW
     ec_gen_cleanup_module();
+#endif
     ec_cleanup_module();
 }
+
+int ecus_init(uint32_t master_count, const char *const *master_macs,
+              uint32_t backup_count, const char *const *backup_macs,
+              uint32_t debug_level, uint32_t cycle_ns, uint32_t core_mask)
+{
+    int ret = 0;
+
+#ifdef EC_USERSPACE_MASTER_NEW
+    ret = ec_usm_net_init(cycle_ns, core_mask);
+    if (ret) {
+        EC_ERR("Failed to init NXP userspace driver! ret:%d\n", ret);
+        goto err_tag;
+    }
 #endif
+
+    ret = ecrt_init(master_count, master_macs, backup_count, backup_macs, debug_level);
+    if (ret) {
+        EC_ERR("Failed to init userspace driver! Error:%s.\n", strerror(-ret));
+        goto err_tag;
+    }
+
+err_tag:
+    return ret;
+}
+
+int ecus_done(void)
+{
+    ecrt_done();
+    return 0;
+}
+
+#endif  /* EC_MASTER_IN_USERSPACE */
diff --git a/master/slave.h b/master/slave.h
index 4e113e28..8b7be567 100644
--- a/master/slave.h
+++ b/master/slave.h
@@ -95,6 +95,15 @@
  * \param fmt format string (like in printf())
  * \param args arguments (optional)
  */
+#ifdef EC_USERSPACE_MASTER_NEW
+#define EC_SLAVE_DBG(slave, level, fmt, args...) \
+    do { \
+        if (slave->master->debug_level > level) { \
+            printk(KERN_DEBUG "EtherCAT DEBUG %u-%u: " fmt, \
+                    slave->master->index, slave->ring_position, ##args); \
+        } \
+    } while (0)
+#else
 #define EC_SLAVE_DBG(slave, level, fmt, args...) \
     do { \
         if (slave->master->debug_level >= level) { \
@@ -102,6 +111,7 @@
                     slave->master->index, slave->ring_position, ##args); \
         } \
     } while (0)
+#endif
 
 /****************************************************************************/
 
diff --git a/master/slave_config.c b/master/slave_config.c
index 87e81a6c..7438823b 100644
--- a/master/slave_config.c
+++ b/master/slave_config.c
@@ -246,6 +246,32 @@ int ec_slave_config_prepare_fmmu(
 
 /****************************************************************************/
 
+#ifdef EC_MASTER_IN_USERSPACE
+#define PREOP (0x02)
+ec_master_t *ecrt_open_master(unsigned int master_index);
+
+int ecus_slave_is_ready(uint32_t master_index, uint16_t alias, uint16_t position)
+{
+    ec_master_t *master = NULL;
+    ec_slave_t *slave = NULL;
+
+    master = ecrt_open_master(master_index);
+    if (!master)
+        return 0;
+
+    slave = ec_master_find_slave(master, alias, position);
+    if (!slave)
+        return 0;
+
+    if (slave->current_state < PREOP)
+        return 0;
+
+    return 1;
+}
+#endif
+
+/****************************************************************************/
+
 /** Attaches the configuration to the addressed slave object.
  *
  * \retval  0 Success.
diff --git a/tool/CommandAlias.cpp b/tool/CommandAlias.cpp
index d3282e91..806c6142 100644
--- a/tool/CommandAlias.cpp
+++ b/tool/CommandAlias.cpp
@@ -135,12 +135,12 @@ void CommandAlias::writeSlaveAlias(
     data.slave_position = slave.position;
     data.offset = 0;
     data.nwords = 8;
-    data.words = new uint16_t[data.nwords];
+    data.words = ioctl_new_buf(uint16_t, data.nwords);
 
     try {
         m.readSii(&data);
     } catch (MasterDeviceException &e) {
-        delete [] data.words;
+        ioctl_del_buf(data.words);
         err << "Failed to read SII: " << e.what();
         throwCommandException(err);
     }
@@ -158,12 +158,12 @@ void CommandAlias::writeSlaveAlias(
     try {
         m.writeSii(&data);
     } catch (MasterDeviceException &e) {
-        delete [] data.words;
+        ioctl_del_buf(data.words);
         err << "Failed to read SII: " << e.what();
         throwCommandException(err);
     }
 
-    delete [] data.words;
+    ioctl_del_buf(data.words);
 }
 
 /****************************************************************************/
diff --git a/tool/CommandData.cpp b/tool/CommandData.cpp
index 6fc58912..7805eb3f 100644
--- a/tool/CommandData.cpp
+++ b/tool/CommandData.cpp
@@ -101,12 +101,12 @@ void CommandData::outputDomainData(
     if (!domain.data_size)
         return;
 
-    processData = new unsigned char[domain.data_size];
+    processData = ioctl_new_buf(uint8_t, domain.data_size);
 
     try {
         m.getData(&data, domain.index, domain.data_size, processData);
     } catch (MasterDeviceException &e) {
-        delete [] processData;
+        ioctl_del_buf(processData);
         throw e;
     }
 
@@ -114,7 +114,7 @@ void CommandData::outputDomainData(
         cout << processData[i];
     cout.flush();
 
-    delete [] processData;
+    ioctl_del_buf(processData);
 }
 
 /****************************************************************************/
diff --git a/tool/CommandDomains.cpp b/tool/CommandDomains.cpp
index 83abf1fd..a69abb81 100644
--- a/tool/CommandDomains.cpp
+++ b/tool/CommandDomains.cpp
@@ -162,12 +162,12 @@ void CommandDomains::showDomain(
     if (!domain.data_size || getVerbosity() != Verbose)
         return;
 
-    processData = new unsigned char[domain.data_size];
+    processData = ioctl_new_buf(uint8_t, domain.data_size);
 
     try {
         m.getData(&data, domain.index, domain.data_size, processData);
     } catch (MasterDeviceException &e) {
-        delete [] processData;
+        ioctl_del_buf(processData);
         throw e;
     }
 
@@ -188,7 +188,7 @@ void CommandDomains::showDomain(
         dataOffset = fmmu.logical_address - domain.logical_base_address;
         if (dataOffset + fmmu.data_size > domain.data_size) {
             stringstream err;
-            delete [] processData;
+            ioctl_del_buf(processData);
             err << "Fmmu information corrupted!";
             throwCommandException(err);
         }
@@ -203,7 +203,7 @@ void CommandDomains::showDomain(
         cout << endl;
     }
 
-    delete [] processData;
+    ioctl_del_buf(processData);
 }
 
 /****************************************************************************/
diff --git a/tool/CommandDownload.cpp b/tool/CommandDownload.cpp
index 4daeb7dd..a059d842 100644
--- a/tool/CommandDownload.cpp
+++ b/tool/CommandDownload.cpp
@@ -165,16 +165,16 @@ void CommandDownload::execute(const StringVector &args)
             throwCommandException(err);
         }
         data.data_size = contents.size();
-        data.data = new uint8_t[data.data_size + 1];
+        data.data = ioctl_new_buf(uint8_t, data.data_size + 1);
 
         try {
             data.data_size = interpretAsType(
                     dataType, contents, data.data, data.data_size);
         } catch (SizeException &e) {
-            delete [] data.data;
+            ioctl_del_buf(data.data);
             throwCommandException(e.what());
         } catch (ios::failure &e) {
-            delete [] data.data;
+            ioctl_del_buf(data.data);
             err << "Invalid value for type '" << dataType->name << "'!";
             throwInvalidUsageException(err);
         }
@@ -186,16 +186,16 @@ void CommandDownload::execute(const StringVector &args)
             data.data_size = DefaultBufferSize;
         }
 
-        data.data = new uint8_t[data.data_size + 1];
+        data.data = ioctl_new_buf(uint8_t, data.data_size + 1);
 
         try {
             data.data_size = interpretAsType(
                     dataType, args[valueIndex], data.data, data.data_size);
         } catch (SizeException &e) {
-            delete [] data.data;
+            ioctl_del_buf(data.data);
             throwCommandException(e.what());
         } catch (ios::failure &e) {
-            delete [] data.data;
+            ioctl_del_buf(data.data);
             err << "Invalid value argument '" << args[valueIndex]
                 << "' for type '" << dataType->name << "'!";
             throwInvalidUsageException(err);
@@ -205,17 +205,17 @@ void CommandDownload::execute(const StringVector &args)
     try {
         m.sdoDownload(&data);
     } catch (MasterDeviceSdoAbortException &e) {
-        delete [] data.data;
+        ioctl_del_buf(data.data);
         err << "SDO transfer aborted with code 0x"
             << setfill('0') << hex << setw(8) << e.abortCode
             << ": " << abortText(e.abortCode);
         throwCommandException(err);
     } catch(MasterDeviceException &e) {
-        delete [] data.data;
+        ioctl_del_buf(data.data);
         throw e;
     }
 
-    delete [] data.data;
+    ioctl_del_buf(data.data);
 }
 
 /****************************************************************************/
diff --git a/tool/CommandFoeRead.cpp b/tool/CommandFoeRead.cpp
index bb329561..7806dfa3 100644
--- a/tool/CommandFoeRead.cpp
+++ b/tool/CommandFoeRead.cpp
@@ -95,14 +95,14 @@ void CommandFoeRead::execute(const StringVector &args)
      */
     data.offset = 0;
     data.buffer_size = 0x8800;
-    data.buffer = new uint8_t[data.buffer_size];
+    data.buffer = ioctl_new_buf(uint8_t, data.buffer_size);
 
     strncpy(data.file_name, args[0].c_str(), sizeof(data.file_name) - 1);
 
     try {
         m.readFoe(&data);
     } catch (MasterDeviceException &e) {
-        delete [] data.buffer;
+        ioctl_del_buf(data.buffer);
         if (data.result) {
             if (data.result == FOE_OPCODE_ERROR) {
                 err << "FoE read aborted with error code 0x"
@@ -124,7 +124,7 @@ void CommandFoeRead::execute(const StringVector &args)
         cout << *(uint8_t *) w ;
     }
 
-    delete [] data.buffer;
+    ioctl_del_buf(data.buffer);
 }
 
 /****************************************************************************/
diff --git a/tool/CommandFoeWrite.cpp b/tool/CommandFoeWrite.cpp
index 6574f3f7..8dc5f14f 100644
--- a/tool/CommandFoeWrite.cpp
+++ b/tool/CommandFoeWrite.cpp
@@ -118,14 +118,14 @@ void CommandFoeWrite::execute(const StringVector &args)
         m.open(MasterDevice::ReadWrite);
     } catch (MasterDeviceException &e) {
         if (data.buffer_size)
-            delete [] data.buffer;
+            ioctl_del_buf(data.buffer);
         throw e;
     }
 
     slaves = selectedSlaves(m);
     if (slaves.size() != 1) {
         if (data.buffer_size)
-            delete [] data.buffer;
+            ioctl_del_buf(data.buffer);
         throwSingleSlaveRequired(slaves.size());
     }
     data.slave_position = slaves.front().position;
@@ -139,7 +139,7 @@ void CommandFoeWrite::execute(const StringVector &args)
         m.writeFoe(&data);
     } catch (MasterDeviceException &e) {
         if (data.buffer_size)
-            delete [] data.buffer;
+            ioctl_del_buf(data.buffer);
         if (data.result) {
             if (data.result == FOE_OPCODE_ERROR) {
                 err << "FoE write aborted with error code 0x"
@@ -160,7 +160,7 @@ void CommandFoeWrite::execute(const StringVector &args)
     }
 
     if (data.buffer_size)
-        delete [] data.buffer;
+        ioctl_del_buf(data.buffer);
 }
 
 /****************************************************************************/
@@ -184,7 +184,7 @@ void CommandFoeWrite::loadFoeData(
 
     if (data->buffer_size) {
         // allocate buffer and read file into buffer
-        data->buffer = new uint8_t[data->buffer_size];
+        data->buffer = ioctl_new_buf(uint8_t, data->buffer_size);
         contents.copy((char *) data->buffer, contents.size());
     }
 }
diff --git a/tool/CommandRegRead.cpp b/tool/CommandRegRead.cpp
index c3595389..2daebc97 100644
--- a/tool/CommandRegRead.cpp
+++ b/tool/CommandRegRead.cpp
@@ -143,23 +143,23 @@ void CommandRegRead::execute(const StringVector &args)
     io.slave_position = slaves.front().position;
     io.emergency = false;
 
-    io.data = new uint8_t[io.size];
+    io.data = ioctl_new_buf(uint8_t, io.size);
 
     try {
         m.readReg(&io);
     } catch (MasterDeviceException &e) {
-        delete [] io.data;
+        ioctl_del_buf(io.data);
         throw e;
     }
 
     try {
         outputData(cout, dataType, io.data, io.size);
     } catch (SizeException &e) {
-        delete [] io.data;
+        ioctl_del_buf(io.data);
         throwCommandException(e.what());
     }
 
-    delete [] io.data;
+    ioctl_del_buf(io.data);
 }
 
 /****************************************************************************/
diff --git a/tool/CommandRegWrite.cpp b/tool/CommandRegWrite.cpp
index 5a1e9d5c..c0de019f 100644
--- a/tool/CommandRegWrite.cpp
+++ b/tool/CommandRegWrite.cpp
@@ -121,16 +121,16 @@ void CommandRegWrite::execute(const StringVector &args)
             io.size = 1024; // FIXME
         }
 
-        io.data = new uint8_t[io.size];
+        io.data = ioctl_new_buf(uint8_t, io.size);
 
         try {
             io.size = interpretAsType(
                     dataType, args[1], io.data, io.size);
         } catch (SizeException &e) {
-            delete [] io.data;
+            ioctl_del_buf(io.data);
             throwCommandException(e.what());
         } catch (ios::failure &e) {
-            delete [] io.data;
+            ioctl_del_buf(io.data);
             err << "Invalid value argument '" << args[1]
                 << "' for type '" << dataType->name << "'!";
             throwInvalidUsageException(err);
@@ -139,7 +139,7 @@ void CommandRegWrite::execute(const StringVector &args)
 
     if ((uint32_t) io.address + io.size > 0xffff) {
         err << "Address and size exceeding 64k!";
-        delete [] io.data;
+        ioctl_del_buf(io.data);
         throwInvalidUsageException(err);
     }
 
@@ -147,7 +147,7 @@ void CommandRegWrite::execute(const StringVector &args)
     try {
         m.open(MasterDevice::ReadWrite);
     } catch (MasterDeviceException &e) {
-        delete [] io.data;
+        ioctl_del_buf(io.data);
         throw e;
     }
 
@@ -158,7 +158,7 @@ void CommandRegWrite::execute(const StringVector &args)
     else {
         SlaveList slaves = selectedSlaves(m);
         if (slaves.size() != 1) {
-            delete [] io.data;
+            ioctl_del_buf(io.data);
             throwSingleSlaveRequired(slaves.size());
         }
         io.slave_position = slaves.front().position;
@@ -169,7 +169,7 @@ void CommandRegWrite::execute(const StringVector &args)
     try {
         m.writeReg(&io);
     } catch (MasterDeviceException &e) {
-        delete [] io.data;
+        ioctl_del_buf(io.data);
         throw e;
     }
 
@@ -177,7 +177,7 @@ void CommandRegWrite::execute(const StringVector &args)
         cerr << "Register writing finished." << endl;
     }
 
-    delete [] io.data;
+    ioctl_del_buf(io.data);
 }
 
 /****************************************************************************/
@@ -204,7 +204,7 @@ void CommandRegWrite::loadRegData(
     io->size = contents.size();
 
     // allocate buffer and read file into buffer
-    io->data = new uint8_t[io->size];
+    io->data = ioctl_new_buf(uint8_t, io->size);
     contents.copy((char *) io->data, contents.size());
 }
 
diff --git a/tool/CommandSiiRead.cpp b/tool/CommandSiiRead.cpp
index f7b474e5..4d1bd0b7 100644
--- a/tool/CommandSiiRead.cpp
+++ b/tool/CommandSiiRead.cpp
@@ -96,12 +96,12 @@ void CommandSiiRead::execute(const StringVector &args)
 
     data.offset = 0;
     data.nwords = slave->sii_nwords;
-    data.words = new uint16_t[data.nwords];
+    data.words = ioctl_new_buf(uint16_t, data.nwords);
 
     try {
         m.readSii(&data);
     } catch (MasterDeviceException &e) {
-        delete [] data.words;
+        ioctl_del_buf(data.words);
         throw e;
     }
 
@@ -167,7 +167,7 @@ void CommandSiiRead::execute(const StringVector &args)
         }
     }
 
-    delete [] data.words;
+    ioctl_del_buf(data.words);
 }
 
 /****************************************************************************/
diff --git a/tool/CommandSiiWrite.cpp b/tool/CommandSiiWrite.cpp
index 0c7adb08..771851af 100644
--- a/tool/CommandSiiWrite.cpp
+++ b/tool/CommandSiiWrite.cpp
@@ -97,7 +97,7 @@ void CommandSiiWrite::execute(const StringVector &args)
         try {
             checkSiiData(&data);
         } catch (CommandException &e) {
-            delete [] data.words;
+            ioctl_del_buf(data.words);
             throw e;
         }
     }
@@ -106,13 +106,13 @@ void CommandSiiWrite::execute(const StringVector &args)
     try {
         m.open(MasterDevice::ReadWrite);
     } catch (MasterDeviceException &e) {
-        delete [] data.words;
+        ioctl_del_buf(data.words);
         throw e;
     }
 
     slaves = selectedSlaves(m);
     if (slaves.size() != 1) {
-        delete [] data.words;
+        ioctl_del_buf(data.words);
         throwSingleSlaveRequired(slaves.size());
     }
     data.slave_position = slaves.front().position;
@@ -122,7 +122,7 @@ void CommandSiiWrite::execute(const StringVector &args)
     try {
         m.writeSii(&data);
     } catch (MasterDeviceException &e) {
-        delete [] data.words;
+        ioctl_del_buf(data.words);
         throw e;
     }
 
@@ -130,7 +130,7 @@ void CommandSiiWrite::execute(const StringVector &args)
         cerr << "SII writing finished." << endl;
     }
 
-    delete [] data.words;
+    ioctl_del_buf(data.words);
 }
 
 /****************************************************************************/
@@ -158,7 +158,7 @@ void CommandSiiWrite::loadSiiData(
     data->nwords = contents.size() / 2;
 
     // allocate buffer and read file into buffer
-    data->words = new uint16_t[data->nwords];
+    data->words = ioctl_new_buf(uint16_t, data->nwords);
     contents.copy((char *) data->words, contents.size());
 }
 
diff --git a/tool/CommandSoeRead.cpp b/tool/CommandSoeRead.cpp
index de30e83e..1ea274d2 100644
--- a/tool/CommandSoeRead.cpp
+++ b/tool/CommandSoeRead.cpp
@@ -140,16 +140,16 @@ void CommandSoeRead::execute(const StringVector &args)
         ioctl.mem_size = 1024;
     }
 
-    ioctl.data = new uint8_t[ioctl.mem_size + 1];
+    ioctl.data = ioctl_new_buf(uint8_t, ioctl.mem_size + 1);
 
     try {
         m.readSoe(&ioctl);
     } catch (MasterDeviceSoeException &e) {
-        delete [] ioctl.data;
+        ioctl_del_buf(ioctl.data);
         err << "SoE read command failed with code " << errorMsg(e.errorCode);
         throwCommandException(err);
     } catch (MasterDeviceException &e) {
-        delete [] ioctl.data;
+        ioctl_del_buf(ioctl.data);
         throw e;
     }
 
@@ -158,11 +158,11 @@ void CommandSoeRead::execute(const StringVector &args)
     try {
         outputData(cout, dataType, ioctl.data, ioctl.data_size);
     } catch (SizeException &e) {
-        delete [] ioctl.data;
+        ioctl_del_buf(ioctl.data);
         throwCommandException(e.what());
     }
 
-    delete [] ioctl.data;
+    ioctl_del_buf(ioctl.data);
 }
 
 /****************************************************************************/
diff --git a/tool/CommandSoeWrite.cpp b/tool/CommandSoeWrite.cpp
index a227d470..68117836 100644
--- a/tool/CommandSoeWrite.cpp
+++ b/tool/CommandSoeWrite.cpp
@@ -150,16 +150,16 @@ void CommandSoeWrite::execute(const StringVector &args)
         }
     }
 
-    ioctl.data = new uint8_t[memSize];
+    ioctl.data = ioctl_new_buf(uint8_t, memSize);
 
     try {
         ioctl.data_size = interpretAsType(
                 dataType, args[valueArgIndex], ioctl.data, memSize);
     } catch (SizeException &e) {
-        delete [] ioctl.data;
+        ioctl_del_buf(ioctl.data);
         throwCommandException(e.what());
     } catch (ios::failure &e) {
-        delete [] ioctl.data;
+        ioctl_del_buf(ioctl.data);
         err << "Invalid value argument '" << args[valueArgIndex]
             << "' for type '" << dataType->name << "'!";
         throwInvalidUsageException(err);
@@ -168,15 +168,15 @@ void CommandSoeWrite::execute(const StringVector &args)
     try {
         m.writeSoe(&ioctl);
     } catch (MasterDeviceSoeException &e) {
-        delete [] ioctl.data;
+        ioctl_del_buf(ioctl.data);
         err << "SoE write command failed with code " << errorMsg(e.errorCode);
         throwCommandException(err);
     } catch (MasterDeviceException &e) {
-        delete [] ioctl.data;
+        ioctl_del_buf(ioctl.data);
         throw e;
     }
 
-    delete [] ioctl.data;
+    ioctl_del_buf(ioctl.data);
 }
 
 /****************************************************************************/
diff --git a/tool/CommandUpload.cpp b/tool/CommandUpload.cpp
index fbae3924..b2b1f8b5 100644
--- a/tool/CommandUpload.cpp
+++ b/tool/CommandUpload.cpp
@@ -143,18 +143,18 @@ void CommandUpload::execute(const StringVector &args)
         data.target_size = DefaultBufferSize;
     }
 
-    data.target = new uint8_t[data.target_size + 1];
+    data.target = ioctl_new_buf(uint8_t, data.target_size + 1);
 
     try {
         m.sdoUpload(&data);
     } catch (MasterDeviceSdoAbortException &e) {
-        delete [] data.target;
+        ioctl_del_buf(data.target);
         err << "SDO transfer aborted with code 0x"
             << setfill('0') << hex << setw(8) << e.abortCode
             << ": " << abortText(e.abortCode);
         throwCommandException(err);
     } catch (MasterDeviceException &e) {
-        delete [] data.target;
+        ioctl_del_buf(data.target);
         throw e;
     }
 
@@ -163,11 +163,11 @@ void CommandUpload::execute(const StringVector &args)
     try {
         outputData(cout, dataType, data.target, data.data_size);
     } catch (SizeException &e) {
-        delete [] data.target;
+        ioctl_del_buf(data.target);
         throwCommandException(e.what());
     }
 
-    delete [] data.target;
+    ioctl_del_buf(data.target);
 }
 
 /****************************************************************************/
diff --git a/tool/Makefile.am b/tool/Makefile.am
index a4656a87..a89e0b5c 100644
--- a/tool/Makefile.am
+++ b/tool/Makefile.am
@@ -25,9 +25,9 @@
 
 EXTRA_DIST =
 
-bin_PROGRAMS = ethercat
+bin_PROGRAMS = ethercat_userspace
 
-ethercat_SOURCES = \
+ethercat_userspace_SOURCES = \
 	Command.cpp \
 	CommandAlias.cpp \
 	CommandCrc.cpp \
@@ -65,7 +65,7 @@ ethercat_SOURCES = \
 	sii_crc.cpp
 
 if ENABLE_EOE
-ethercat_SOURCES += CommandEoe.cpp CommandIp.cpp
+ethercat_userspace_SOURCES += CommandEoe.cpp CommandIp.cpp
 else
 EXTRA_DIST += CommandEoe.cpp CommandIp.cpp
 endif
@@ -118,9 +118,10 @@ REV = `if test -s $(top_srcdir)/revision; then \
 		git -C $(top_srcdir) describe 2>/dev/null || echo "unknown"; \
 	fi`
 
-ethercat_CXXFLAGS = \
+ethercat_userspace_CXXFLAGS = \
 	-I$(top_srcdir)/include \
 	-I$(top_srcdir)/master \
+	-DEC_MASTER_IN_USERSPACE \
 	-Wall -DREV=$(REV) \
 	-fno-strict-aliasing
 
diff --git a/tool/MasterDevice.cpp b/tool/MasterDevice.cpp
index ac256d88..1ae17002 100644
--- a/tool/MasterDevice.cpp
+++ b/tool/MasterDevice.cpp
@@ -32,6 +32,122 @@ using namespace std;
 
 #include "MasterDevice.h"
 
+#ifdef EC_MASTER_IN_USERSPACE
+#include <sys/ipc.h>
+#include <sys/shm.h>
+
+#define IOCTL_MEM_SIZE (1024 * 3)
+
+extern "C" {
+
+static void *smaster_shmem[MAX_MASTER_NUM];
+
+static uint8_t* alloc_share_memory(int index, int *pshmid)
+{
+    uint8_t *pmem = NULL;
+    int shmid = 0;
+    key_t key = 0;
+
+    key = ftok("/tmp/", 0x88A4 + index);
+    if (key == -1) {
+        printf("%s(): ftok failed! key:%d\n", __func__, key);
+        return NULL;
+    }
+
+    shmid = shmget(key, 4096, 0666);
+    if (shmid < 0) {
+        printf("%s(): shmget failed! shmid:%d\n", __func__, shmid);
+        return NULL;
+    }
+
+    pmem = (uint8_t*)shmat(shmid, NULL, 0);
+    if (!pmem) {
+        printf("%s(): shmat failed! shmid:%d\n", __func__, shmid);
+        return NULL;
+    }
+
+    if (pshmid)
+        *pshmid = shmid;
+
+    return pmem;
+}
+
+uint8_t *ecat_get_ioctl_mem(int size)
+{
+    uint8_t *pmem = NULL;
+    int fd = 0;  /* using fd 0 */
+
+    pmem = (uint8_t*)smaster_shmem[fd];
+    if (!pmem) {
+        printf("%s(): smaster_shmem-%d is NULL!\n", __func__, fd);
+        return NULL;
+    }
+
+    if (size > IOCTL_MEM_SIZE) {
+        printf("%s(): size %d is out of range %d!\n", __func__, size, IOCTL_MEM_SIZE);
+        return NULL;
+    }
+
+    return pmem + (4096 - IOCTL_MEM_SIZE);
+}
+
+int ecat_ioctl_len(int fd, unsigned int cmd, void *arg, int len, int flag)
+{
+    volatile struct ecat_shm_info *pshm = NULL;
+    uint8_t *pmem = NULL;
+    uint8_t *parg = NULL;
+    int cnt = 0;
+
+    if (fd >= MAX_MASTER_NUM) {
+        printf("%s(): invalid fd number! fd:%d\n", __func__, fd);
+        return -1;
+    }
+
+    pmem = (uint8_t*)smaster_shmem[fd];
+    if (!pmem) {
+        printf("%s(): smaster_shmem-%d is NULL!\n", __func__, fd);
+        return -2;
+    }
+
+    pshm = (volatile struct ecat_shm_info *)pmem;
+    parg = (uint8_t*)(pmem + sizeof(*pshm));
+
+    pshm->index = fd;
+    pshm->cmd = cmd;
+
+    if (flag == 0) {
+        pshm->len = 0;
+        *(uint64_t *)parg = (uint64_t)arg;
+    } else if (len > 0) {
+        pshm->len = len;
+        memcpy(parg, arg, len);
+    }
+
+    pshm->flag = 1;
+    while (cnt++ < 3000) {  /* wait for max 3s */
+        if (pshm->flag == 2)
+            break;
+
+        usleep(1000);
+    }
+    pshm->flag = 0;
+
+    if (flag && (len > 0))
+        memcpy(arg, parg, len);
+
+    return 0;
+}
+
+}  /* extern "C" */
+
+#undef ioctl
+#define ioctl(f, c, a) ecat_ioctl_len(f, c, a, sizeof(*a), 1)
+#define ioctl_l(f, c, a) ecat_ioctl_len(f, c, (void*)(uint64_t)(a), sizeof(a), 0)
+
+#else
+#define ioctl_l ioctl
+#endif  /* EC_MASTER_IN_USERSPACE */
+
 /****************************************************************************/
 
 MasterDevice::MasterDevice(unsigned int index):
@@ -59,14 +175,26 @@ void MasterDevice::setIndex(unsigned int i)
 
 void MasterDevice::open(Permissions perm)
 {
+    ec_ioctl_module_t module_data;
     stringstream deviceName;
 
     if (fd == -1) { // not already open
-        ec_ioctl_module_t module_data;
-        deviceName << "/dev/EtherCAT" << index;
+#ifdef EC_MASTER_IN_USERSPACE
+        int shmid = 0;
+
+        if (index >= MAX_MASTER_NUM) {
+            stringstream err;
+            err << "invalid master index " << strerror(errno);
+            throw MasterDeviceException(err);
+        }
 
-        if ((fd = ::open(deviceName.str().c_str(),
-                        perm == ReadWrite ? O_RDWR : O_RDONLY)) == -1) {
+        fd = index;
+        smaster_shmem[fd] = alloc_share_memory(fd, &shmid);
+#else
+        deviceName << "/dev/EtherCAT" << index;
+        fd = ::open(deviceName.str().c_str(), perm == ReadWrite ? O_RDWR : O_RDONLY);
+#endif
+        if (fd == -1) {
             stringstream err;
             err << "Failed to open master device " << deviceName.str() << ": "
                 << strerror(errno);
@@ -95,10 +223,17 @@ void MasterDevice::open(Permissions perm)
 
 void MasterDevice::close()
 {
+#ifdef EC_MASTER_IN_USERSPACE
+    if (smaster_shmem[fd]) {
+        shmdt(smaster_shmem[fd]);
+        smaster_shmem[fd] = NULL;
+    }
+#else
     if (fd != -1) {
         ::close(fd);
         fd = -1;
     }
+#endif
 }
 
 /****************************************************************************/
@@ -480,7 +615,7 @@ void MasterDevice::writeFoe(
 
 void MasterDevice::setDebug(unsigned int debugLevel)
 {
-    if (ioctl(fd, EC_IOCTL_MASTER_DEBUG, debugLevel) < 0) {
+    if (ioctl_l(fd, EC_IOCTL_MASTER_DEBUG, debugLevel) < 0) {
         stringstream err;
         err << "Failed to set debug level: " << strerror(errno);
         throw MasterDeviceException(err);
@@ -491,7 +626,7 @@ void MasterDevice::setDebug(unsigned int debugLevel)
 
 void MasterDevice::rescan()
 {
-    if (ioctl(fd, EC_IOCTL_MASTER_RESCAN, 0) < 0) {
+    if (ioctl_l(fd, EC_IOCTL_MASTER_RESCAN, 0) < 0) {
         stringstream err;
         err << "Failed to command rescan: " << strerror(errno);
         throw MasterDeviceException(err);
diff --git a/tool/MasterDevice.h b/tool/MasterDevice.h
index bb6c8a8e..c3da363c 100644
--- a/tool/MasterDevice.h
+++ b/tool/MasterDevice.h
@@ -30,6 +30,28 @@ using namespace std;
 #include "ioctl.h"
 
 /****************************************************************************/
+#ifdef EC_MASTER_IN_USERSPACE
+extern "C" {
+
+#define MAX_MASTER_NUM (32)
+
+uint8_t *ecat_get_ioctl_mem(int size);
+int ecat_ioctl_len(int fd, unsigned int cmd, void *arg, int len, int flag);
+
+struct ecat_shm_info {
+    uint32_t flag;
+    uint32_t index;
+    uint32_t cmd;
+    uint32_t len;
+} __attribute__((packed));
+
+#define ioctl_new_buf(t, s) (t*)ecat_get_ioctl_mem(s)
+#define ioctl_del_buf(p)
+}  /* extern "C" */
+#else
+#define ioctl_new_buf(t, s) new t[s]
+#define ioctl_del_buf(p) delete [] p
+#endif
 
 class MasterDeviceException:
     public runtime_error
-- 
2.43.0

