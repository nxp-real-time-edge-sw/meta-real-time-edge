From 1d4a4d26847443c396d92d4ae62b87f495dd7d49 Mon Sep 17 00:00:00 2001
From: Tao Yang <Tao.Yang1@nxp.com>
Date: Thu, 15 Sep 2022 13:21:11 +0800
Subject: [PATCH] feat(examples): Add pubsub TSN sample applications

Upstream-Status: Pending
---
 CMakeLists.txt                                |    5 +
 examples/CMakeLists.txt                       |   17 +-
 .../pubsub_realtime/opcua_pubsub_publisher.c  | 1029 +++++++++++++++
 .../pubsub_realtime/opcua_pubsub_subscriber.c | 1115 +++++++++++++++++
 examples/pubsub_realtime/thermal.c            |   42 +
 examples/pubsub_realtime/thermal.h            |   12 +
 examples/pubsub_realtime/timestamp.c          |  196 +++
 examples/pubsub_realtime/timestamp.h          |   16 +
 .../open62541/plugin/pubsub_ethernet.h        |    4 +
 plugins/ua_pubsub_ethernet.c                  |   32 +
 10 files changed, 2465 insertions(+), 3 deletions(-)
 create mode 100644 examples/pubsub_realtime/opcua_pubsub_publisher.c
 create mode 100644 examples/pubsub_realtime/opcua_pubsub_subscriber.c
 create mode 100644 examples/pubsub_realtime/thermal.c
 create mode 100644 examples/pubsub_realtime/thermal.h
 create mode 100644 examples/pubsub_realtime/timestamp.c
 create mode 100644 examples/pubsub_realtime/timestamp.h

diff --git a/CMakeLists.txt b/CMakeLists.txt
index 9184b943..bb5a4c3f 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -278,6 +278,11 @@ option(UA_ENABLE_PUBSUB_ETH_UADP_XDP "Enable Subscribe UADP over Ethernet using
 mark_as_advanced(UA_ENABLE_PUBSUB_ETH_UADP_XDP)
 option(UA_ENABLE_PUBSUB_ETH_UADP_ETF "Use ETF implementation for the ETH_UADP publish" OFF)
 mark_as_advanced(UA_ENABLE_PUBSUB_ETH_UADP_ETF)
+option(UA_ENABLE_PUBSUB_ETH_RX_HW_TIMESTAMP "Enable getting Rx HW timestamp on Ethernet packet" OFF)
+mark_as_advanced(UA_ENABLE_PUBSUB_ETH_RX_HW_TIMESTAMP)
+if(UA_ENABLE_PUBSUB_ETH_RX_HW_TIMESTAMP)
+    add_definitions(-DUA_ENABLE_PUBSUB_ETH_RX_HW_TIMESTAMP)
+endif()
 
 if(UA_ENABLE_PUBSUB_ETH_UADP)
     if(NOT CMAKE_SYSTEM MATCHES "Linux")
diff --git a/examples/CMakeLists.txt b/examples/CMakeLists.txt
index 70c84560..268e2486 100644
--- a/examples/CMakeLists.txt
+++ b/examples/CMakeLists.txt
@@ -199,7 +199,7 @@ add_subdirectory(nodeset)
 if(UA_ENABLE_PUBSUB)
     add_example(tutorial_pubsub_connection pubsub/tutorial_pubsub_connection.c)
     add_example(tutorial_pubsub_publish pubsub/tutorial_pubsub_publish.c)
-	add_example(server_pubsub_publisher_iop pubsub/server_pubsub_publisher_iop.c)
+    add_example(server_pubsub_publisher_iop pubsub/server_pubsub_publisher_iop.c)
     add_example(server_pubsub_publish_rt_level pubsub/server_pubsub_publisher_rt_level.c)
     add_example(server_pubsub_rt_information_model pubsub/server_pubsub_rt_field_information_model.c)
     if(CMAKE_SYSTEM MATCHES "Linux")
@@ -210,9 +210,20 @@ if(UA_ENABLE_PUBSUB)
         endif()
     endif()
     if (BUILD_SHARED_LIBS)
-        message(WARNING "PubSub subscriber API is not finished. Build option BUILD_SHARED_LIBS is not supported. Skipping PubSub subscriber examples.")
+        if(CMAKE_SYSTEM MATCHES "Linux")
+            include_directories(${PROJECT_SOURCE_DIR}/../src/server)
+            add_example(opcua_pubsub_publisher pubsub_realtime/opcua_pubsub_publisher.c)
+            target_sources(opcua_pubsub_publisher PRIVATE pubsub_realtime/thermal.c)
+            target_sources(opcua_pubsub_publisher PRIVATE pubsub_realtime/timestamp.c)
+            target_link_libraries(opcua_pubsub_publisher rt pthread)
+            if(UA_ENABLE_PUBSUB_ETH_RX_HW_TIMESTAMP)
+                add_example(opcua_pubsub_subscriber pubsub_realtime/opcua_pubsub_subscriber.c)
+                target_sources(opcua_pubsub_subscriber PRIVATE pubsub_realtime/timestamp.c)
+                target_link_libraries(opcua_pubsub_subscriber rt pthread)
+            endif()
+        endif()
     else (NOT BUILD_SHARED_LIBS)
-	    add_example(server_pubsub_subscribe_rt_level pubsub/server_pubsub_subscriber_rt_level.c)
+        add_example(server_pubsub_subscribe_rt_level pubsub/server_pubsub_subscriber_rt_level.c)
         if(UA_ENABLE_AMALGAMATION)
             message(WARNING "PubSub subscriber tutorial (preview) can not be used with AMALGAMATION. Skipping tutorial_pubsub_subscribe.")
         else(NOT UA_ENABLE_AMALGAMATION)
diff --git a/examples/pubsub_realtime/opcua_pubsub_publisher.c b/examples/pubsub_realtime/opcua_pubsub_publisher.c
new file mode 100644
index 00000000..9fc2802a
--- /dev/null
+++ b/examples/pubsub_realtime/opcua_pubsub_publisher.c
@@ -0,0 +1,1029 @@
+/* This work is licensed under a Creative Commons CCZero 1.0 Universal License.
+ * See http://creativecommons.org/publicdomain/zero/1.0/ for more information.
+ *
+ *    Copyright 2021 NXP
+ */
+
+#define _GNU_SOURCE
+
+#include <sched.h>
+#include <signal.h>
+#include <time.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <pthread.h>
+#include <sys/sysinfo.h>
+#include <open62541/server.h>
+#include <open62541/server_config_default.h>
+#include <open62541/server_pubsub.h>
+#include <open62541/plugin/log_stdout.h>
+#include <open62541/plugin/pubsub_ethernet.h>
+#include <open62541/types_generated.h>
+
+#include "ua_server_internal.h"
+
+#include "timestamp.h"
+#include "thermal.h"
+
+#define MILLI_AS_NANO_SECONDS     (1000 * 1000)
+#define SECONDS_AS_NANO_SECONDS   (1000 * 1000 * 1000)
+#define CLOCKID                   CLOCK_REALTIME
+#define PUB_INTERVAL              1000 /* Publish interval in milliseconds */
+#define SECONDS_SLEEP             5
+#define PUB_SCHED_PRIORITY        78
+#define PUBLISHER_ID              2234
+#define WRITER_GROUP_ID           100
+#define DATA_SET_WRITER_ID        62541
+
+#undef PUBLISHER_MEASUREMENTS
+#if defined(PUBLISHER_MEASUREMENTS)
+#define MAX_MEASUREMENTS          100000
+#define MEASUREMENT_OUTPUT        "publisher_measurement.csv"
+#endif
+
+static UA_Boolean running = true;
+static UA_UInt32 pubIntervalNs;
+static UA_SOCKET pubSockFd = 0;
+
+/* Identifiers */
+static UA_NodeId connectionIdent;
+static UA_NodeId publishedDataSetIdent;
+static UA_NodeId writerGroupIdent;
+
+/* Node ID's for the values to be published */
+static UA_NodeId pubSeqNumNodeId;
+static UA_NodeId pubCycleScheduleTimeNodeId;
+static UA_NodeId pubCycleBeginTimeNodeId;
+static UA_NodeId pubCycleEndTimeNodeId;
+static UA_NodeId pubCycleBeginJitterNodeId;
+static UA_NodeId pubCallbackDurationNodeId;
+static UA_NodeId pubTemperatureNodeId;
+static UA_NodeId pubTxHwTimestampNodeId;
+
+/* The variables for the values to be published */
+static UA_UInt64 *pubSequenceNumber = NULL;
+static UA_UInt64 *pubCycleScheduleTime = NULL;
+static UA_UInt64 *pubCycleBeginTime = NULL;
+static UA_UInt64 *pubCycleEndTime = NULL;
+static UA_Int64 *pubCycleBeginJitter = NULL;
+static UA_UInt64 *pubCallbackDuration = NULL;
+static UA_Double *pubTemperature = NULL;
+static UA_UInt64 *pubTxHwTimestamp = NULL;
+
+/* DataValue for the values to be published */
+static UA_DataValue *staticValuePubSeqNum = NULL;
+static UA_DataValue *staticValuePubCycSched = NULL;
+static UA_DataValue *staticValuePubCycBegin = NULL;
+static UA_DataValue *staticValuePubCycEnd = NULL;
+static UA_DataValue *staticValuePubCycBeginJitter = NULL;
+static UA_DataValue *staticValuePubCallbackDuration = NULL;
+static UA_DataValue *staticValuePubTemperature = NULL;
+static UA_DataValue *staticValuePubTxHwTimestamp = NULL;
+
+#if defined(PUBLISHER_MEASUREMENTS)
+static size_t publisherMeasurementsCounter = 0;
+static UA_UInt32 currentPublishCycleTime[MAX_MEASUREMENTS+1];
+static UA_UInt64 pubCycleScheduleTimeMeasure[MAX_MEASUREMENTS+1];
+static UA_UInt64 pubCycleBeginTimeMeasure[MAX_MEASUREMENTS+1];
+static UA_Int64 pubCycleBeginJitterMeasure[MAX_MEASUREMENTS+1];
+static UA_UInt64 pubCallbackDurationMeasure[MAX_MEASUREMENTS+1];
+static UA_UInt64 pubTxHwTimestampMeasure[MAX_MEASUREMENTS+1];
+#endif
+
+/* Structure to define thread parameters */
+typedef struct {
+    UA_Server *server;
+    void *data;
+    UA_ServerCallback callback;
+    UA_Duration interval_ms;
+    UA_UInt64 *callbackId;
+} threadArg;
+
+
+static UA_UInt64
+timeConversion(struct timespec *timeSpec) {
+    return (UA_UInt64)(timeSpec->tv_sec * SECONDS_AS_NANO_SECONDS + timeSpec->tv_nsec);
+}
+
+static void
+nanoSecondFieldConversion(struct timespec *timeSpec) {
+    while(timeSpec->tv_nsec > (SECONDS_AS_NANO_SECONDS - 1)) {
+        timeSpec->tv_sec += 1;
+        timeSpec->tv_nsec -= SECONDS_AS_NANO_SECONDS;
+    }
+}
+
+static void *userPublisher(void *arg) {
+    UA_Server *server;
+    void *data;
+    UA_ServerCallback pubCallback;
+    UA_Int64 interval_ns;
+    struct timespec now;
+    struct timespec start_time;
+    struct timespec begin;
+    struct timespec end;
+    unsigned long long hw_ts_initial = 0;
+    unsigned long long hw_ts = 0;
+
+    threadArg *threadArgumentsPublisher = (threadArg *)arg;
+
+    server = threadArgumentsPublisher->server;
+    data = threadArgumentsPublisher->data;
+    pubCallback = threadArgumentsPublisher->callback;
+
+    interval_ns = (UA_Int64)(threadArgumentsPublisher->interval_ms * MILLI_AS_NANO_SECONDS);
+
+    /* Starting time is rounded up to whole second after ~5s */
+    clock_gettime(CLOCKID, &now);
+    start_time.tv_sec = now.tv_sec + SECONDS_SLEEP;
+    start_time.tv_nsec = 0;
+
+    UA_LOG_INFO(UA_Log_Stdout, UA_LOGCATEGORY_USERLAND,
+        "Starting the publisher cycle at %ld.%09ld", start_time.tv_sec, start_time.tv_nsec);
+
+    /* The 1st set of published values are set to 0 */
+    if(*pubSequenceNumber == 0) {
+        *pubCycleScheduleTime = 0;
+        *pubCycleBeginTime = 0;
+        *pubCycleEndTime = 0;
+        *pubCycleBeginJitter = 0;
+        *pubCallbackDuration = 0;
+        *pubTemperature = 0.0;
+        *pubTxHwTimestamp = 0;
+    }
+
+    /* Read the outstanding timestamp from MSG_ERRQUEUE */
+    if (getTxHwTimestamp(pubSockFd, &hw_ts_initial) < 0) {
+        UA_LOG_WARNING(UA_Log_Stdout, UA_LOGCATEGORY_USERLAND,
+                       "Initial getTxHwTimestamp : no outstanding timestamp!");
+    }
+
+    while (running) {
+        clock_nanosleep(CLOCKID, TIMER_ABSTIME, &start_time, NULL);
+
+        /* Get time from CLOCK_REALTIME */
+        clock_gettime(CLOCKID, &begin);
+
+        /* Execute the publish callback */
+        pubCallback(server, data);
+
+        /* Get time from CLOCK_REALTIME */
+        clock_gettime(CLOCKID, &end);
+
+        /* Update the published values */
+        *pubSequenceNumber = *pubSequenceNumber + 1;
+        *pubCycleScheduleTime = timeConversion(&start_time);
+        *pubCycleBeginTime = timeConversion(&begin);
+        *pubCycleEndTime = timeConversion(&end);
+        *pubCycleBeginJitter = (UA_Int64)(timeConversion(&begin) - timeConversion(&start_time));
+        *pubCallbackDuration = timeConversion(&end) - timeConversion(&begin);
+        *pubTemperature = get_cpu_temperature();
+        if (getTxHwTimestamp(pubSockFd, &hw_ts) < 0) {
+            UA_LOG_WARNING(UA_Log_Stdout, UA_LOGCATEGORY_USERLAND,
+                           "No Tx Hw timestamp for packet: %ld", *pubSequenceNumber);
+            *pubTxHwTimestamp = 0;
+        }
+        else {
+            *pubTxHwTimestamp = (UA_UInt64)hw_ts;
+        }
+
+        /* The next start_time is incremented by publishing interval.
+         * Make sure that start_time is in the future.
+         */
+        while(timeConversion(&start_time) < timeConversion(&end)) {
+            start_time.tv_nsec += interval_ns;
+            nanoSecondFieldConversion(&start_time);
+        }
+
+#if defined(PUBLISHER_MEASUREMENTS)
+        if(publisherMeasurementsCounter >= MAX_MEASUREMENTS) {
+            /* Once measures are done, stop the UA server */
+            running = UA_FALSE;
+            return (void*)NULL;
+        }
+
+        /* Save current configured publish interval */
+        currentPublishCycleTime[publisherMeasurementsCounter] = pubIntervalNs;
+        /* Save the calculated begin time for the next cycle */
+        pubCycleScheduleTimeMeasure[publisherMeasurementsCounter] = *pubCycleScheduleTime;
+        /* Save the cycle begin time */
+        pubCycleBeginTimeMeasure[publisherMeasurementsCounter] = *pubCycleBeginTime;
+        /* Save the cycle begin time jitter */
+        pubCycleBeginJitterMeasure[publisherMeasurementsCounter] = *pubCycleBeginJitter;
+        /* Save the duration of the publish callback */
+        pubCallbackDurationMeasure[publisherMeasurementsCounter] = *pubCallbackDuration;
+        /* Save the Tx hardware timestamp */
+        pubTxHwTimestampMeasure[publisherMeasurementsCounter] = *pubTxHwTimestamp;
+
+        publisherMeasurementsCounter++;
+
+        /* Write the pubsub measurement data */
+        if(publisherMeasurementsCounter == MAX_MEASUREMENTS) {
+            UA_LOG_INFO(UA_Log_Stdout, UA_LOGCATEGORY_USERLAND,
+                        "Logging the measurements to %s", MEASUREMENT_OUTPUT);
+        
+            FILE *fpPublisher = fopen(MEASUREMENT_OUTPUT, "w");
+            for(UA_UInt32 i = 0; i < publisherMeasurementsCounter; i++) {
+                fprintf(fpPublisher,
+                        "%u, %u, %ld.%09ld, %ld.%09ld, %ld, %ld, %ld\n",
+                        i,
+                        currentPublishCycleTime[i],
+                        pubCycleScheduleTimeMeasure[i] / SECONDS_AS_NANO_SECONDS,
+                        pubCycleScheduleTimeMeasure[i] % SECONDS_AS_NANO_SECONDS,
+                        pubCycleBeginTimeMeasure[i] / SECONDS_AS_NANO_SECONDS,
+                        pubCycleBeginTimeMeasure[i] % SECONDS_AS_NANO_SECONDS,
+                        pubCycleBeginJitterMeasure[i],
+                        pubCallbackDurationMeasure[i],
+                        pubTxHwTimestampMeasure[i]);
+            }
+            fclose(fpPublisher);
+        }
+#endif
+    }
+
+    UA_free(threadArgumentsPublisher);
+
+    return (void*)NULL;
+}
+
+static pthread_t
+threadCreation(int threadPriority, size_t coreAffinity,
+               void *(*threadApp) (void *), void *threadAppArgs) {
+    cpu_set_t cpuset;
+    pthread_t current_thread, publisher_thread;
+    struct sched_param schedParam;
+    UA_Int32 ret = 0;
+
+    /* Return the ID for thread */
+    current_thread = pthread_self();
+    schedParam.sched_priority = threadPriority;
+    ret = pthread_setschedparam(current_thread, SCHED_FIFO, &schedParam);
+    if (ret != 0) {
+        fprintf(stderr, "pthread_setschedparam: %s\n", strerror(ret));
+        exit(1);
+    }
+
+    UA_LOG_INFO(UA_Log_Stdout, UA_LOGCATEGORY_USERLAND, \
+                "Publisher thread priority : %d", schedParam.sched_priority);
+
+    CPU_ZERO(&cpuset);
+    CPU_SET(coreAffinity, &cpuset);
+
+    ret = pthread_setaffinity_np(current_thread, sizeof(cpu_set_t), &cpuset);
+    if (ret != 0) {
+        fprintf(stderr, "pthread_setaffinity_np: %s\n", strerror(ret));
+        exit(1);
+    }
+
+    /* Note: A new thread created by pthread_create inherits a copy of its
+     * creator's CPU affinity mask.
+     */
+    ret = pthread_create(&publisher_thread, NULL, threadApp, threadAppArgs);
+    if (ret != 0) {
+        fprintf(stderr, "pthread_create: %s\n", strerror(ret));
+        exit(1);
+    }
+
+    if (CPU_ISSET(coreAffinity, &cpuset)) {
+        UA_LOG_INFO(UA_Log_Stdout, UA_LOGCATEGORY_USERLAND,
+                    "Publisher on CPU core : %ld", coreAffinity);
+    }
+
+   return publisher_thread;
+}
+
+/* Add a callback for cyclic repetition */
+static UA_StatusCode
+addPubSubApplicationCallback(UA_Server *server, UA_NodeId identifier,
+                             UA_ServerCallback callback, void *data,
+                             UA_Double interval_ms, UA_UInt64 *callbackId) {
+    UA_LOG_INFO(UA_Log_Stdout, UA_LOGCATEGORY_USERLAND,
+                "Publisher cycle time : %lf ms", interval_ms);
+
+    threadArg *threadArgs = (threadArg *) UA_malloc(sizeof(threadArg));
+
+    pubIntervalNs = (UA_UInt32) (interval_ms * MILLI_AS_NANO_SECONDS);
+
+    /* Pass the value required for the threads */
+    threadArgs->server = server;
+    threadArgs->data = data;
+    threadArgs->callback = callback;
+    threadArgs->interval_ms = interval_ms;
+    threadArgs->callbackId = callbackId;
+
+    /* Check the writer group identifier and create the thread accordingly */
+    if(UA_NodeId_equal(&identifier, &writerGroupIdent)) {
+        /* 
+         * Note: Run Publisher on last core because we don't know
+         * the number of cores on differenct SoC
+         */
+        size_t core_num = (size_t)(get_nprocs_conf() - 1);
+        *callbackId = threadCreation(PUB_SCHED_PRIORITY, core_num, userPublisher,
+                                     threadArgs);
+        UA_LOG_INFO(UA_Log_Stdout, UA_LOGCATEGORY_USERLAND,
+                    "Publisher thread callback Id: %ld", *callbackId);
+    }
+
+    return UA_STATUSCODE_GOOD;
+}
+
+static UA_StatusCode
+changePubSubApplicationCallbackInterval(UA_Server *server, UA_NodeId identifier,
+                                        UA_UInt64 callbackId, UA_Double interval_ms) {
+    /* Callback interval need not be modified as it is thread based implementation.
+     * The thread uses nanosleep for calculating cycle time and modification in
+     * nanosleep value changes cycle time */
+    return UA_STATUSCODE_GOOD;
+}
+
+/* Remove the callback added for cyclic repetition */
+static void
+removePubSubApplicationCallback(UA_Server *server, UA_NodeId identifier, UA_UInt64 callbackId) {
+    if(callbackId && (pthread_join(callbackId, NULL) != 0))
+        UA_LOG_WARNING(UA_Log_Stdout, UA_LOGCATEGORY_USERLAND,
+                       "pthread_join failed for thread: %ld\n", callbackId);
+}
+
+/* If the external data source is written over the information model, the
+ * externalDataWriteCallback will be triggered. The user has to take care and assure
+ * that the write leads not to synchronization issues and race conditions. */
+static UA_StatusCode
+externalDataWriteCallback(UA_Server *server, const UA_NodeId *sessionId,
+                          void *sessionContext, const UA_NodeId *nodeId,
+                          void *nodeContext, const UA_NumericRange *range,
+                          const UA_DataValue *data) {
+    //node values are updated by using variables in the memory
+    //UA_Server_write is not used for updating node values.
+    return UA_STATUSCODE_GOOD;
+}
+
+static UA_StatusCode
+externalDataReadNotificationCallback(UA_Server *server, const UA_NodeId *sessionId,
+                                     void *sessionContext, const UA_NodeId *nodeid,
+                                     void *nodeContext, const UA_NumericRange *range) {
+    //allow read without any preparation
+    return UA_STATUSCODE_GOOD;
+}
+
+/*
+ * Connection handling
+ * -------------------
+ * PubSubConnections can be created and deleted on runtime.
+ */
+static void
+addPubSubConnection(UA_Server *server, UA_String *transportProfile,
+                    UA_NetworkAddressUrlDataType *networkAddressUrl) {
+    UA_PubSubConnectionConfig connectionConfig;
+    memset(&connectionConfig, 0, sizeof(UA_PubSubConnectionConfig));
+    connectionConfig.name = UA_STRING("Publisher Connection");
+    connectionConfig.transportProfileUri = *transportProfile;
+    connectionConfig.enabled = UA_TRUE;
+    UA_Variant_setScalar(&connectionConfig.address, networkAddressUrl,
+                         &UA_TYPES[UA_TYPES_NETWORKADDRESSURLDATATYPE]);
+    connectionConfig.publisherId.numeric = PUBLISHER_ID;
+    UA_Server_addPubSubConnection(server, &connectionConfig, &connectionIdent);
+}
+
+/*
+ * PublishedDataSet handling
+ * -------------------------
+ * The PublishedDataSet (PDS) and PubSubConnection are the toplevel entities and
+ * can exist alone. The PDS contains the collection of the published fields. All
+ * other PubSub elements are directly or indirectly linked with the PDS or
+ * connection.
+ */
+static void
+addPublishedDataSet(UA_Server *server) {
+    UA_PublishedDataSetConfig publishedDataSetConfig;
+    memset(&publishedDataSetConfig, 0, sizeof(UA_PublishedDataSetConfig));
+    publishedDataSetConfig.publishedDataSetType = UA_PUBSUB_DATASET_PUBLISHEDITEMS;
+    publishedDataSetConfig.name = UA_STRING("Publisher PDS");
+    UA_Server_addPublishedDataSet(server, &publishedDataSetConfig,
+                                  &publishedDataSetIdent);
+}
+
+/*
+ * DataSetField handling
+ * ---------------------
+ * The DataSetField (DSF) is part of the PDS and describes exactly one published
+ * field.
+ */
+static void
+addDataSetField(UA_Server *server) {
+    UA_DataSetFieldConfig dataSetFieldConfig;
+
+    /* Set the value backend of the nodes to 'external value source' */
+
+    UA_ValueBackend valueBackend;
+    valueBackend.backendType = UA_VALUEBACKENDTYPE_EXTERNAL;
+    valueBackend.backend.external.callback.userWrite = externalDataWriteCallback;
+    valueBackend.backend.external.callback.notificationRead = externalDataReadNotificationCallback;
+
+    /*** Sequence Number ***/
+    pubSequenceNumber = UA_UInt64_new();
+    if(!pubSequenceNumber) {
+        UA_LOG_ERROR(UA_Log_Stdout, UA_LOGCATEGORY_SERVER, "pubSequenceNumber - Bad out of memory");
+        return;
+    }
+    *pubSequenceNumber = 0;
+
+    staticValuePubSeqNum = UA_DataValue_new();
+    if(!staticValuePubSeqNum) {
+        UA_LOG_ERROR(UA_Log_Stdout, UA_LOGCATEGORY_SERVER, "staticValuePubSeqNum - Bad out of memory");
+        return;
+    }
+    UA_Variant_setScalar(&staticValuePubSeqNum->value, pubSequenceNumber, &UA_TYPES[UA_TYPES_UINT64]);
+    staticValuePubSeqNum->value.storageType = UA_VARIANT_DATA_NODELETE;
+    staticValuePubSeqNum->hasValue = UA_TRUE;
+
+    valueBackend.backend.external.value = &staticValuePubSeqNum;
+    UA_Server_setVariableNode_valueBackend(server, pubSeqNumNodeId, valueBackend);
+
+    UA_NodeId f1;
+    memset(&dataSetFieldConfig, 0, sizeof(UA_DataSetFieldConfig));
+    /* setup RT DataSetField config */
+    dataSetFieldConfig.field.variable.rtValueSource.rtInformationModelNode = UA_TRUE;
+    dataSetFieldConfig.field.variable.publishParameters.publishedVariable = pubSeqNumNodeId;
+
+    UA_Server_addDataSetField(server, publishedDataSetIdent, &dataSetFieldConfig, &f1);
+
+    /*** Cycle Schedule Time ***/
+    pubCycleScheduleTime = UA_UInt64_new();
+    if(!pubCycleScheduleTime) {
+        UA_LOG_ERROR(UA_Log_Stdout, UA_LOGCATEGORY_SERVER, "pubCycleScheduleTime - Bad out of memory");
+        return;
+    }
+    *pubCycleScheduleTime = 0;
+
+    staticValuePubCycSched = UA_DataValue_new();
+    if(!staticValuePubCycSched) {
+        UA_LOG_ERROR(UA_Log_Stdout, UA_LOGCATEGORY_SERVER, "staticValuePubCycSched - Bad out of memory");
+        return;
+    }
+    UA_Variant_setScalar(&staticValuePubCycSched->value, pubCycleScheduleTime, &UA_TYPES[UA_TYPES_UINT64]);
+    staticValuePubCycSched->value.storageType = UA_VARIANT_DATA_NODELETE;
+    staticValuePubCycSched->hasValue = UA_TRUE;
+
+    valueBackend.backend.external.value = &staticValuePubCycSched;
+    UA_Server_setVariableNode_valueBackend(server, pubCycleScheduleTimeNodeId, valueBackend);
+
+    UA_NodeId f2;
+    memset(&dataSetFieldConfig, 0, sizeof(UA_DataSetFieldConfig));
+    /* setup RT DataSetField config */
+    dataSetFieldConfig.field.variable.rtValueSource.rtInformationModelNode = UA_TRUE;
+    dataSetFieldConfig.field.variable.publishParameters.publishedVariable = pubCycleScheduleTimeNodeId;
+
+    UA_Server_addDataSetField(server, publishedDataSetIdent, &dataSetFieldConfig, &f2);
+
+    /*** Cycle Begin Time from CLOCK_REALTIME ***/
+    pubCycleBeginTime = UA_UInt64_new();
+    if(!pubCycleBeginTime) {
+        UA_LOG_ERROR(UA_Log_Stdout, UA_LOGCATEGORY_SERVER, "pubCycleBeginTime - Bad out of memory");
+        return;
+    }
+    *pubCycleBeginTime = 0;
+
+    staticValuePubCycBegin = UA_DataValue_new();
+    if(!staticValuePubCycBegin) {
+        UA_LOG_ERROR(UA_Log_Stdout, UA_LOGCATEGORY_SERVER, "staticValuePubCycBegin - Bad out of memory");
+        return;
+    }
+    UA_Variant_setScalar(&staticValuePubCycBegin->value, pubCycleBeginTime, &UA_TYPES[UA_TYPES_UINT64]);
+    staticValuePubCycBegin->value.storageType = UA_VARIANT_DATA_NODELETE;
+    staticValuePubCycBegin->hasValue = UA_TRUE;
+
+    valueBackend.backend.external.value = &staticValuePubCycBegin;
+    UA_Server_setVariableNode_valueBackend(server, pubCycleBeginTimeNodeId, valueBackend);
+
+    UA_NodeId f3;
+    memset(&dataSetFieldConfig, 0, sizeof(UA_DataSetFieldConfig));
+    /* setup RT DataSetField config */
+    dataSetFieldConfig.field.variable.rtValueSource.rtInformationModelNode = UA_TRUE;
+    dataSetFieldConfig.field.variable.publishParameters.publishedVariable = pubCycleBeginTimeNodeId;
+
+    UA_Server_addDataSetField(server, publishedDataSetIdent, &dataSetFieldConfig, &f3);
+
+    /*** Cycle End Time ***/
+    pubCycleEndTime = UA_UInt64_new();
+    if(!pubCycleEndTime) {
+        UA_LOG_ERROR(UA_Log_Stdout, UA_LOGCATEGORY_SERVER, "pubCycleEndTime - Bad out of memory");
+        return;
+    }
+    *pubCycleEndTime = 0;
+
+    staticValuePubCycEnd = UA_DataValue_new();
+    if(!staticValuePubCycEnd) {
+        UA_LOG_ERROR(UA_Log_Stdout, UA_LOGCATEGORY_SERVER, "staticValuePubCycEnd - Bad out of memory");
+        return;
+    }
+    UA_Variant_setScalar(&staticValuePubCycEnd->value, pubCycleEndTime, &UA_TYPES[UA_TYPES_UINT64]);
+    staticValuePubCycEnd->value.storageType = UA_VARIANT_DATA_NODELETE;
+    staticValuePubCycEnd->hasValue = UA_TRUE;
+
+    valueBackend.backend.external.value = &staticValuePubCycEnd;
+    UA_Server_setVariableNode_valueBackend(server, pubCycleEndTimeNodeId, valueBackend);
+
+    UA_NodeId f4;
+    memset(&dataSetFieldConfig, 0, sizeof(UA_DataSetFieldConfig));
+    /* setup RT DataSetField config */
+    dataSetFieldConfig.field.variable.rtValueSource.rtInformationModelNode = UA_TRUE;
+    dataSetFieldConfig.field.variable.publishParameters.publishedVariable = pubCycleEndTimeNodeId;
+
+    UA_Server_addDataSetField(server, publishedDataSetIdent, &dataSetFieldConfig, &f4);
+
+    /*** Cycle Begin Jitter ***/
+    pubCycleBeginJitter = UA_Int64_new();
+    if(!pubCycleBeginJitter) {
+        UA_LOG_ERROR(UA_Log_Stdout, UA_LOGCATEGORY_SERVER, "pubCycleBeginJitter - Bad out of memory");
+        return;
+    }
+    *pubCycleBeginJitter = 0;
+
+    staticValuePubCycBeginJitter = UA_DataValue_new();
+    if(!staticValuePubCycBeginJitter) {
+        UA_LOG_ERROR(UA_Log_Stdout, UA_LOGCATEGORY_SERVER, "staticValuePubCycBeginJitter - Bad out of memory");
+        return;
+    }
+    UA_Variant_setScalar(&staticValuePubCycBeginJitter->value, pubCycleBeginJitter, &UA_TYPES[UA_TYPES_INT64]);
+    staticValuePubCycBeginJitter->value.storageType = UA_VARIANT_DATA_NODELETE;
+    staticValuePubCycBeginJitter->hasValue = UA_TRUE;
+
+    valueBackend.backend.external.value = &staticValuePubCycBeginJitter;
+    UA_Server_setVariableNode_valueBackend(server, pubCycleBeginJitterNodeId, valueBackend);
+
+    UA_NodeId f5;
+    memset(&dataSetFieldConfig, 0, sizeof(UA_DataSetFieldConfig));
+    /* setup RT DataSetField config */
+    dataSetFieldConfig.field.variable.rtValueSource.rtInformationModelNode = UA_TRUE;
+    dataSetFieldConfig.field.variable.publishParameters.publishedVariable = pubCycleBeginJitterNodeId;
+
+    UA_Server_addDataSetField(server, publishedDataSetIdent, &dataSetFieldConfig, &f5);
+
+    /*** Publisher Callback Duration ***/
+    pubCallbackDuration = UA_UInt64_new();
+    if(!pubCallbackDuration) {
+        UA_LOG_ERROR(UA_Log_Stdout, UA_LOGCATEGORY_SERVER, "pubCallbackDuration - Bad out of memory");
+        return;
+    }
+    *pubCallbackDuration = 0;
+
+    staticValuePubCallbackDuration = UA_DataValue_new();
+    if(!staticValuePubCallbackDuration) {
+        UA_LOG_ERROR(UA_Log_Stdout, UA_LOGCATEGORY_SERVER, "staticValuePubCallbackDuration - Bad out of memory");
+        return;
+    }
+    UA_Variant_setScalar(&staticValuePubCallbackDuration->value, pubCallbackDuration, &UA_TYPES[UA_TYPES_UINT64]);
+    staticValuePubCallbackDuration->value.storageType = UA_VARIANT_DATA_NODELETE;
+    staticValuePubCallbackDuration->hasValue = UA_TRUE;
+
+    valueBackend.backend.external.value = &staticValuePubCallbackDuration;
+    UA_Server_setVariableNode_valueBackend(server, pubCallbackDurationNodeId, valueBackend);
+
+    UA_NodeId f6;
+    memset(&dataSetFieldConfig, 0, sizeof(UA_DataSetFieldConfig));
+    /* setup RT DataSetField config */
+    dataSetFieldConfig.field.variable.rtValueSource.rtInformationModelNode = UA_TRUE;
+    dataSetFieldConfig.field.variable.publishParameters.publishedVariable = pubCallbackDurationNodeId;
+
+    UA_Server_addDataSetField(server, publishedDataSetIdent, &dataSetFieldConfig, &f6);
+
+    /*** Publisher Temperature ***/
+    pubTemperature = UA_Double_new();
+    if(!pubTemperature) {
+        UA_LOG_ERROR(UA_Log_Stdout, UA_LOGCATEGORY_SERVER, "pubTemperature - Bad out of memory");
+        return;
+    }
+    *pubTemperature = 0.0;
+
+    staticValuePubTemperature = UA_DataValue_new();
+    if(!staticValuePubTemperature) {
+        UA_LOG_ERROR(UA_Log_Stdout, UA_LOGCATEGORY_SERVER, "staticValuePubTemperature - Bad out of memory");
+        return;
+    }
+    UA_Variant_setScalar(&staticValuePubTemperature->value, pubTemperature, &UA_TYPES[UA_TYPES_DOUBLE]);
+    staticValuePubTemperature->value.storageType = UA_VARIANT_DATA_NODELETE;
+    staticValuePubTemperature->hasValue = UA_TRUE;
+    
+    valueBackend.backend.external.value = &staticValuePubTemperature;
+    UA_Server_setVariableNode_valueBackend(server, pubTemperatureNodeId, valueBackend);
+    
+    UA_NodeId f7;
+    memset(&dataSetFieldConfig, 0, sizeof(UA_DataSetFieldConfig));
+    /* setup RT DataSetField config */
+    dataSetFieldConfig.field.variable.rtValueSource.rtInformationModelNode = UA_TRUE;
+    dataSetFieldConfig.field.variable.publishParameters.publishedVariable = pubTemperatureNodeId;
+    
+    UA_Server_addDataSetField(server, publishedDataSetIdent, &dataSetFieldConfig, &f7);
+
+    /*** Publisher Tx timestamp ***/
+    pubTxHwTimestamp = UA_UInt64_new();
+    if(!pubTxHwTimestamp) {
+        UA_LOG_ERROR(UA_Log_Stdout, UA_LOGCATEGORY_SERVER, "pubTxHwTimestamp - Bad out of memory");
+        return;
+    }
+    *pubTxHwTimestamp = 0;
+
+    staticValuePubTxHwTimestamp = UA_DataValue_new();
+    if(!staticValuePubTxHwTimestamp) {
+        UA_LOG_ERROR(UA_Log_Stdout, UA_LOGCATEGORY_SERVER, "staticValuePubTxHwTimestamp - Bad out of memory");
+        return;
+    }
+    UA_Variant_setScalar(&staticValuePubTxHwTimestamp->value, pubTxHwTimestamp, &UA_TYPES[UA_TYPES_UINT64]);
+    staticValuePubTxHwTimestamp->value.storageType = UA_VARIANT_DATA_NODELETE;
+    staticValuePubTxHwTimestamp->hasValue = UA_TRUE;
+
+    valueBackend.backend.external.value = &staticValuePubTxHwTimestamp;
+    UA_Server_setVariableNode_valueBackend(server, pubTxHwTimestampNodeId, valueBackend);
+
+    UA_NodeId f8;
+    memset(&dataSetFieldConfig, 0, sizeof(UA_DataSetFieldConfig));
+    /* setup RT DataSetField config */
+    dataSetFieldConfig.field.variable.rtValueSource.rtInformationModelNode = UA_TRUE;
+    dataSetFieldConfig.field.variable.publishParameters.publishedVariable = pubTxHwTimestampNodeId;
+
+    UA_Server_addDataSetField(server, publishedDataSetIdent, &dataSetFieldConfig, &f8);
+}
+
+/*
+ * WriterGroup handling
+ * --------------------
+ * The WriterGroup (WG) is part of the connection and contains the primary
+ * configuration parameters for the message creation.
+ */
+static void
+addWriterGroup(UA_Server *server) {
+    UA_WriterGroupConfig writerGroupConfig;
+    memset(&writerGroupConfig, 0, sizeof(UA_WriterGroupConfig));
+    writerGroupConfig.name = UA_STRING("Demo WriterGroup");
+    writerGroupConfig.publishingInterval = PUB_INTERVAL;
+    writerGroupConfig.enabled = UA_FALSE;
+    writerGroupConfig.writerGroupId = WRITER_GROUP_ID;
+    writerGroupConfig.encodingMimeType = UA_PUBSUB_ENCODING_UADP;
+    writerGroupConfig.rtLevel = UA_PUBSUB_RT_FIXED_SIZE;
+    writerGroupConfig.pubsubManagerCallback.addCustomCallback = addPubSubApplicationCallback;
+    writerGroupConfig.pubsubManagerCallback.changeCustomCallbackInterval = changePubSubApplicationCallbackInterval;
+    writerGroupConfig.pubsubManagerCallback.removeCustomCallback = removePubSubApplicationCallback;
+
+    writerGroupConfig.messageSettings.encoding = UA_EXTENSIONOBJECT_DECODED;
+    writerGroupConfig.messageSettings.content.decoded.type = &UA_TYPES[UA_TYPES_UADPWRITERGROUPMESSAGEDATATYPE];
+    /* The configuration flags for the messages are encapsulated inside the
+     * message- and transport settings extension objects. These extension
+     * objects are defined by the standard. e.g.
+     * UadpWriterGroupMessageDataType */
+    UA_UadpWriterGroupMessageDataType *writerGroupMessage = UA_UadpWriterGroupMessageDataType_new();
+    /* Change message settings of writerGroup to send PublisherId,
+     * WriterGroupId in GroupHeader and DataSetWriterId in PayloadHeader
+     * of NetworkMessage */
+    writerGroupMessage->networkMessageContentMask = (UA_UadpNetworkMessageContentMask)(UA_UADPNETWORKMESSAGECONTENTMASK_PUBLISHERID |
+                                                     (UA_UadpNetworkMessageContentMask)UA_UADPNETWORKMESSAGECONTENTMASK_GROUPHEADER |
+                                                     (UA_UadpNetworkMessageContentMask)UA_UADPNETWORKMESSAGECONTENTMASK_WRITERGROUPID |
+                                                     (UA_UadpNetworkMessageContentMask)UA_UADPNETWORKMESSAGECONTENTMASK_PAYLOADHEADER);
+    writerGroupConfig.messageSettings.content.decoded.data = writerGroupMessage;
+
+    UA_Server_addWriterGroup(server, connectionIdent, &writerGroupConfig,
+                             &writerGroupIdent);
+
+    UA_UadpWriterGroupMessageDataType_delete(writerGroupMessage);
+}
+
+/*
+ * DataSetWriter handling
+ * ----------------------
+ * A DataSetWriter (DSW) is the glue between the WG and the PDS. The DSW is
+ * linked to exactly one PDS and contains additional informations for the
+ * message generation.
+ */
+static void
+addDataSetWriter(UA_Server *server) {
+    UA_NodeId dataSetWriterIdent;
+    UA_DataSetWriterConfig dataSetWriterConfig;
+    memset(&dataSetWriterConfig, 0, sizeof(UA_DataSetWriterConfig));
+    dataSetWriterConfig.name = UA_STRING("Demo DataSetWriter");
+    dataSetWriterConfig.dataSetWriterId = DATA_SET_WRITER_ID;
+    dataSetWriterConfig.keyFrameCount = 10;
+    UA_Server_addDataSetWriter(server, writerGroupIdent, publishedDataSetIdent,
+                               &dataSetWriterConfig, &dataSetWriterIdent);
+}
+
+static void
+addServerNodes(UA_Server *server) {
+    UA_Int64 initValInt64 = 0;
+    UA_UInt64 initValUInt64 = 0;
+    UA_Double initValDouble = 0.0;
+    UA_NodeId objectId;
+    UA_NodeId newNodeId;
+
+    UA_ObjectAttributes oAttr = UA_ObjectAttributes_default;
+    oAttr.displayName = UA_LOCALIZEDTEXT("en-US", "Publisher");
+    UA_Server_addObjectNode(server, UA_NODEID_NULL,
+                            UA_NODEID_NUMERIC(0, UA_NS0ID_OBJECTSFOLDER),
+                            UA_NODEID_NUMERIC(0, UA_NS0ID_ORGANIZES),
+                            UA_QUALIFIEDNAME(1, "Publisher"),
+                            UA_NODEID_NUMERIC(0, UA_NS0ID_BASEOBJECTTYPE),
+                            oAttr, NULL, &objectId);
+
+    UA_NodeId_init(&pubSeqNumNodeId);
+    pubSeqNumNodeId = UA_NODEID_STRING(1, "publisher.sequence.number");
+    UA_VariableAttributes vAttr = UA_VariableAttributes_default;
+    vAttr.dataType = UA_TYPES[UA_TYPES_UINT64].typeId;
+    UA_Variant_setScalar(&vAttr.value, &initValUInt64, &UA_TYPES[UA_TYPES_UINT64]);
+    vAttr.displayName = UA_LOCALIZEDTEXT("en-US", "Publisher Sequence Number");
+    vAttr.accessLevel = UA_ACCESSLEVELMASK_READ | UA_ACCESSLEVELMASK_WRITE;
+    newNodeId = UA_NODEID_STRING(1, "PublisherSequenceNumber");
+    UA_Server_addVariableNode(server, newNodeId, objectId,
+                              UA_NODEID_NUMERIC(0, UA_NS0ID_HASCOMPONENT),
+                              UA_QUALIFIEDNAME(1, "Publisher Sequence Number"),
+                              UA_NODEID_NUMERIC(0, UA_NS0ID_BASEDATAVARIABLETYPE),
+                              vAttr, NULL, &pubSeqNumNodeId);
+
+    UA_NodeId_init(&pubCycleScheduleTimeNodeId);
+    pubCycleScheduleTimeNodeId = UA_NODEID_STRING(1, "publisher.cycle.schedule.time");
+    vAttr = UA_VariableAttributes_default;
+    vAttr.dataType = UA_TYPES[UA_TYPES_UINT64].typeId;
+    UA_Variant_setScalar(&vAttr.value, &initValUInt64, &UA_TYPES[UA_TYPES_UINT64]);
+    vAttr.displayName = UA_LOCALIZEDTEXT("en-US", "Publisher Cycle Schedule Time");
+    vAttr.accessLevel = UA_ACCESSLEVELMASK_READ | UA_ACCESSLEVELMASK_WRITE;
+    newNodeId = UA_NODEID_STRING(1, "PublisherCycleScheduleTime");
+    UA_Server_addVariableNode(server, newNodeId, objectId,
+                              UA_NODEID_NUMERIC(0, UA_NS0ID_HASCOMPONENT),
+                              UA_QUALIFIEDNAME(1, "Publisher Cycle Schedule Time"),
+                              UA_NODEID_NUMERIC(0, UA_NS0ID_BASEDATAVARIABLETYPE),
+                              vAttr, NULL, &pubCycleScheduleTimeNodeId);
+
+    UA_NodeId_init(&pubCycleBeginTimeNodeId);
+    pubCycleBeginTimeNodeId = UA_NODEID_STRING(1, "publisher.cycle.begin.time");
+    vAttr = UA_VariableAttributes_default;
+    vAttr.dataType = UA_TYPES[UA_TYPES_UINT64].typeId;
+    UA_Variant_setScalar(&vAttr.value, &initValUInt64, &UA_TYPES[UA_TYPES_UINT64]);
+    vAttr.displayName = UA_LOCALIZEDTEXT("en-US", "Publisher Cycle Begin Time");
+    vAttr.accessLevel = UA_ACCESSLEVELMASK_READ | UA_ACCESSLEVELMASK_WRITE;
+    newNodeId = UA_NODEID_STRING(1, "PublisherCycleBeginTime");
+    UA_Server_addVariableNode(server, newNodeId, objectId,
+                              UA_NODEID_NUMERIC(0, UA_NS0ID_HASCOMPONENT),
+                              UA_QUALIFIEDNAME(1, "Publisher Cycle Begin Time"),
+                              UA_NODEID_NUMERIC(0, UA_NS0ID_BASEDATAVARIABLETYPE),
+                              vAttr, NULL, &pubCycleBeginTimeNodeId);
+
+    UA_NodeId_init(&pubCycleEndTimeNodeId);
+    pubCycleEndTimeNodeId = UA_NODEID_STRING(1, "publisher.cycle.end.time");
+    vAttr = UA_VariableAttributes_default;
+    vAttr.dataType = UA_TYPES[UA_TYPES_UINT64].typeId;
+    UA_Variant_setScalar(&vAttr.value, &initValUInt64, &UA_TYPES[UA_TYPES_UINT64]);
+    vAttr.displayName = UA_LOCALIZEDTEXT("en-US", "Publisher Cycle End Time");
+    vAttr.accessLevel = UA_ACCESSLEVELMASK_READ | UA_ACCESSLEVELMASK_WRITE;
+    newNodeId = UA_NODEID_STRING(1, "PublisherCycleEndTime");
+    UA_Server_addVariableNode(server, newNodeId, objectId,
+                              UA_NODEID_NUMERIC(0, UA_NS0ID_HASCOMPONENT),
+                              UA_QUALIFIEDNAME(1, "Publisher Cycle End Time"),
+                              UA_NODEID_NUMERIC(0, UA_NS0ID_BASEDATAVARIABLETYPE),
+                              vAttr, NULL, &pubCycleEndTimeNodeId);
+
+    UA_NodeId_init(&pubCycleBeginJitterNodeId);
+    pubCycleBeginJitterNodeId = UA_NODEID_STRING(1, "publisher.cycle.begin.jitter");
+    vAttr = UA_VariableAttributes_default;
+    vAttr.dataType = UA_TYPES[UA_TYPES_INT64].typeId;
+    UA_Variant_setScalar(&vAttr.value, &initValInt64, &UA_TYPES[UA_TYPES_INT64]);
+    vAttr.displayName = UA_LOCALIZEDTEXT("en-US", "Publisher Cycle Begin Jitter");
+    vAttr.accessLevel = UA_ACCESSLEVELMASK_READ | UA_ACCESSLEVELMASK_WRITE;
+    newNodeId = UA_NODEID_STRING(1, "PublisherCycleBeginJitter");
+    UA_Server_addVariableNode(server, newNodeId, objectId,
+                              UA_NODEID_NUMERIC(0, UA_NS0ID_HASCOMPONENT),
+                              UA_QUALIFIEDNAME(1, "Publisher Cycle Begin Jitter"),
+                              UA_NODEID_NUMERIC(0, UA_NS0ID_BASEDATAVARIABLETYPE),
+                              vAttr, NULL, &pubCycleBeginJitterNodeId);
+
+    UA_NodeId_init(&pubCallbackDurationNodeId);
+    pubCallbackDurationNodeId = UA_NODEID_STRING(1, "publisher.callback.duration");
+    vAttr = UA_VariableAttributes_default;
+    vAttr.dataType = UA_TYPES[UA_TYPES_UINT64].typeId;
+    UA_Variant_setScalar(&vAttr.value, &initValUInt64, &UA_TYPES[UA_TYPES_UINT64]);
+    vAttr.displayName = UA_LOCALIZEDTEXT("en-US", "Publisher Callback Duration");
+    vAttr.accessLevel = UA_ACCESSLEVELMASK_READ | UA_ACCESSLEVELMASK_WRITE;
+    newNodeId = UA_NODEID_STRING(1, "PublisherCallbackDuration");
+    UA_Server_addVariableNode(server, newNodeId, objectId,
+                              UA_NODEID_NUMERIC(0, UA_NS0ID_HASCOMPONENT),
+                              UA_QUALIFIEDNAME(1, "Publisher Callback Duration"),
+                              UA_NODEID_NUMERIC(0, UA_NS0ID_BASEDATAVARIABLETYPE),
+                              vAttr, NULL, &pubCallbackDurationNodeId);
+
+    UA_NodeId_init(&pubTemperatureNodeId);
+    pubTemperatureNodeId = UA_NODEID_STRING(1, "publisher.cpu.temperature");
+    vAttr = UA_VariableAttributes_default;
+    vAttr.dataType = UA_TYPES[UA_TYPES_DOUBLE].typeId;
+    UA_Variant_setScalar(&vAttr.value, &initValDouble, &UA_TYPES[UA_TYPES_DOUBLE]);
+    vAttr.displayName = UA_LOCALIZEDTEXT("en-US", "Publisher CPU Temperature");
+    vAttr.accessLevel = UA_ACCESSLEVELMASK_READ | UA_ACCESSLEVELMASK_WRITE;
+    newNodeId = UA_NODEID_STRING(1, "PublisherCPUTemperature");
+    UA_Server_addVariableNode(server, newNodeId, objectId,
+                              UA_NODEID_NUMERIC(0, UA_NS0ID_HASCOMPONENT),
+                              UA_QUALIFIEDNAME(1, "Publisher CPU Temperature"),
+                              UA_NODEID_NUMERIC(0, UA_NS0ID_BASEDATAVARIABLETYPE),
+                              vAttr, NULL, &pubTemperatureNodeId);
+
+    UA_NodeId_init(&pubTxHwTimestampNodeId);
+    pubTxHwTimestampNodeId = UA_NODEID_STRING(1, "publisher.tx.hw.timestamp");
+    vAttr = UA_VariableAttributes_default;
+    vAttr.dataType = UA_TYPES[UA_TYPES_UINT64].typeId;
+    UA_Variant_setScalar(&vAttr.value, &initValUInt64, &UA_TYPES[UA_TYPES_UINT64]);
+    vAttr.displayName = UA_LOCALIZEDTEXT("en-US", "Publisher Tx HW Timestamp");
+    vAttr.accessLevel = UA_ACCESSLEVELMASK_READ | UA_ACCESSLEVELMASK_WRITE;
+    newNodeId = UA_NODEID_STRING(1, "PublisherTxHwTimestamp");
+    UA_Server_addVariableNode(server, newNodeId, objectId,
+                              UA_NODEID_NUMERIC(0, UA_NS0ID_HASCOMPONENT),
+                              UA_QUALIFIEDNAME(1, "Publisher Tx HW Timestamp"),
+                              UA_NODEID_NUMERIC(0, UA_NS0ID_BASEDATAVARIABLETYPE),
+                              vAttr, NULL, &pubTxHwTimestampNodeId);
+}
+
+/* Stop signal */
+static void stopHandler(int sign) {
+    UA_LOG_INFO(UA_Log_Stdout, UA_LOGCATEGORY_SERVER, "Received ctrl-c");
+    running = false;
+}
+
+static int
+run(UA_String *transportProfile, UA_NetworkAddressUrlDataType *networkAddressUrl) {
+    signal(SIGINT, stopHandler);
+    signal(SIGTERM, stopHandler);
+
+    UA_StatusCode retval = UA_STATUSCODE_GOOD;
+    UA_Server *server = UA_Server_new();
+    if(!server) {
+        UA_LOG_ERROR(UA_Log_Stdout, UA_LOGCATEGORY_SERVER, "Can't allocate a UA_Server");
+        return EXIT_FAILURE;
+    }
+
+    UA_ServerConfig *config = UA_Server_getConfig(server);
+    UA_ServerConfig_setDefault(config);
+
+    config->pubsubTransportLayers =
+        (UA_PubSubTransportLayer *) UA_malloc(sizeof(UA_PubSubTransportLayer));
+    if(!config->pubsubTransportLayers) {
+        UA_LOG_ERROR(UA_Log_Stdout, UA_LOGCATEGORY_SERVER, "Can't allocate a UA_PubSubTransportLayer");
+        UA_Server_delete(server);
+        return EXIT_FAILURE;
+    }
+    config->pubsubTransportLayers[0] = UA_PubSubTransportLayerEthernet();
+    config->pubsubTransportLayersSize++;
+
+    addServerNodes(server);
+
+    addPubSubConnection(server, transportProfile, networkAddressUrl);
+    addPublishedDataSet(server);
+    addDataSetField(server);
+    addWriterGroup(server);
+    addDataSetWriter(server);
+
+    UA_PubSubConnection *connection;
+    TAILQ_FOREACH(connection, &server->pubSubManager.connections, listEntry) {
+        if (UA_NodeId_equal(&connection->identifier, &connectionIdent)) {
+            pubSockFd = connection->channel->sockfd;
+            break;
+        }
+    }
+    UA_LOG_INFO(UA_Log_Stdout, UA_LOGCATEGORY_USERLAND, "Publisher socket FD : %d", pubSockFd);
+
+    int ret;
+    ret = getTxHwTimestampConfig(pubSockFd, (char *)networkAddressUrl->networkInterface.data);
+    if (ret < 0) {
+        UA_LOG_WARNING(UA_Log_Stdout, UA_LOGCATEGORY_USERLAND, "Publisher Tx HW timestamp : Disabled");
+        retval |= UA_STATUSCODE_BADINTERNALERROR;
+    } else {
+        UA_LOG_INFO(UA_Log_Stdout, UA_LOGCATEGORY_USERLAND, "Publisher Tx HW timestamp : Enabled");
+    }
+    ret = configSocketHwTimestamp(pubSockFd);
+    if (ret < 0) {
+        UA_LOG_WARNING(UA_Log_Stdout, UA_LOGCATEGORY_USERLAND, "configSocketHwTimestamp failed!");
+        retval |= UA_STATUSCODE_BADINTERNALERROR;
+    }
+
+    /* Freeze the PubSub configuration (and start implicitly the publish callback) */
+    UA_Server_freezeWriterGroupConfiguration(server, writerGroupIdent);
+    UA_Server_setWriterGroupOperational(server, writerGroupIdent);
+
+    /* Run the server */
+    retval |= UA_Server_run(server, &running);
+
+    UA_Server_unfreezeWriterGroupConfiguration(server, writerGroupIdent);
+    UA_Server_delete(server);
+
+    /* Free external data source */
+    if(pubSequenceNumber != NULL) {
+        UA_free(pubSequenceNumber);
+    }
+    if(pubCycleScheduleTime != NULL) {
+        UA_free(pubCycleScheduleTime);
+    }
+    if(pubCycleBeginTime != NULL) {
+        UA_free(pubCycleBeginTime);
+    }
+    if(pubCycleEndTime != NULL) {
+        UA_free(pubCycleEndTime);
+    }
+    if(pubCycleBeginJitter != NULL) {
+        UA_free(pubCycleBeginJitter);
+    }
+    if(pubCallbackDuration != NULL) {
+        UA_free(pubCallbackDuration);
+    }
+    if(pubTemperature != NULL) {
+        UA_free(pubTemperature);
+    }
+    if(pubTxHwTimestamp != NULL) {
+        UA_free(pubTxHwTimestamp);
+    }
+
+    if(staticValuePubSeqNum != NULL) {
+        UA_DataValue_delete(staticValuePubSeqNum);
+    }
+    if(staticValuePubCycSched != NULL) {
+        UA_DataValue_delete(staticValuePubCycSched);
+    }
+    if(staticValuePubCycBegin != NULL) {
+        UA_DataValue_delete(staticValuePubCycBegin);
+    }
+    if(staticValuePubCycEnd != NULL) {
+        UA_DataValue_delete(staticValuePubCycEnd);
+    }
+    if(staticValuePubCycBeginJitter != NULL) {
+        UA_DataValue_delete(staticValuePubCycBeginJitter);
+    }
+    if(staticValuePubCallbackDuration != NULL) {
+        UA_DataValue_delete(staticValuePubCallbackDuration);
+    }
+    if(staticValuePubTemperature != NULL) {
+        UA_DataValue_delete(staticValuePubTemperature);
+    }
+    if(staticValuePubTxHwTimestamp != NULL) {
+        UA_DataValue_delete(staticValuePubTxHwTimestamp);
+    }
+
+    return retval == UA_STATUSCODE_GOOD ? EXIT_SUCCESS : EXIT_FAILURE;
+}
+
+static void
+usage(void)
+{
+    printf("\nUsage:"
+           "\n\topcua_pubsub_publisher -u <url> -d <device>\n"
+           "\n\tExample: opcua_pubsub_publisher -u opc.eth://01-00-5E-00-00-01 -d eth1\n");
+    printf("\nOptions:\n"
+           "\t-u [url]          network address URL (default: opc.eth://01-00-5E-00-00-01)\n"
+           "\t-d [dev]          ethernet device (default: eth1)\n"
+           "\t-h                prints this message and exits\n\n");
+}
+
+int main(int argc, char **argv) {
+    int rc = 0;
+    int option;
+    UA_Boolean eth_required = false;
+    UA_String transportProfile =
+        UA_STRING("http://opcfoundation.org/UA-Profile/Transport/pubsub-eth-uadp");
+    UA_NetworkAddressUrlDataType networkAddressUrl =
+        {UA_STRING("eth1"), UA_STRING("opc.eth://01-00-5E-00-00-01")};
+
+    while ((option = getopt(argc, argv, "hu:d:")) != -1) {
+        switch (option) {
+
+        case 'u':
+            if (strncmp(optarg, "opc.eth://", 10) == 0) {
+                networkAddressUrl.url = UA_STRING(optarg);
+                eth_required = true;
+            } else {
+                printf("invalid -u option\n");
+                usage();
+                goto err;
+            }
+            break;
+
+        case 'd':
+            networkAddressUrl.networkInterface = UA_STRING(optarg);
+            break;
+
+        case 'h':
+            usage();
+            return EXIT_SUCCESS;
+
+        default:
+            rc = -1;
+            usage();
+            goto err;
+        }
+    }
+
+    if (eth_required && networkAddressUrl.networkInterface.length == 0) {
+        printf("-d option required for Ethernet multicast\n");
+        usage();
+        goto err;
+    }
+
+    UA_LOG_INFO(UA_Log_Stdout, UA_LOGCATEGORY_USERLAND, "Transport Profile   : %s", transportProfile.data);
+    UA_LOG_INFO(UA_Log_Stdout, UA_LOGCATEGORY_USERLAND, "Network Address URL : %s", networkAddressUrl.url.data);
+    UA_LOG_INFO(UA_Log_Stdout, UA_LOGCATEGORY_USERLAND, "Ethernet Interface  : %s", networkAddressUrl.networkInterface.data);
+
+    return run(&transportProfile, &networkAddressUrl);
+
+err:
+    return rc;
+}
diff --git a/examples/pubsub_realtime/opcua_pubsub_subscriber.c b/examples/pubsub_realtime/opcua_pubsub_subscriber.c
new file mode 100644
index 00000000..e046d67c
--- /dev/null
+++ b/examples/pubsub_realtime/opcua_pubsub_subscriber.c
@@ -0,0 +1,1115 @@
+/* This work is licensed under a Creative Commons CCZero 1.0 Universal License.
+ * See http://creativecommons.org/publicdomain/zero/1.0/ for more information.
+ *
+ *    Copyright 2021 NXP
+ */
+
+#define _GNU_SOURCE
+
+#include <sched.h>
+#include <signal.h>
+#include <time.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <pthread.h>
+#include <sys/sysinfo.h>
+#include <open62541/server.h>
+#include <open62541/server_config_default.h>
+#include <open62541/server_pubsub.h>
+#include <open62541/plugin/log_stdout.h>
+#include <open62541/plugin/pubsub_ethernet.h>
+#include <open62541/types_generated.h>
+
+#include "ua_server_internal.h"
+
+#include "timestamp.h"
+
+#define MILLI_AS_NANO_SECONDS     (1000 * 1000)
+#define SECONDS_AS_NANO_SECONDS   (1000 * 1000 * 1000)
+#define CLOCKID                   CLOCK_REALTIME
+#define CYCLE_TIME                1000 /* Cycle interval in milliseconds */
+#define SUB_SCHED_PRIORITY        81
+#define PUBLISHER_ID_SUB          2234  /* Same as on the publisher */
+#define WRITER_GROUP_ID_SUB       100   /* Same as on the publisher */
+#define DATA_SET_WRITER_ID_SUB    62541 /* Same as on the publisher */
+#define PUBSUB_CONFIG_FIELD_COUNT 8
+
+static UA_Boolean running = true;
+static UA_DataSetReaderConfig readerConfig;
+static UA_SOCKET subSockFd = 0;
+
+/* Identifiers */
+static UA_NodeId connectionIdent;
+static UA_NodeId readerGroupIdent;
+static UA_NodeId readerIdent;
+
+/* Node ID's to save the subscribed values */
+static UA_NodeId subSeqNumNodeId;
+static UA_NodeId subCycleScheduleTimeNodeId;
+static UA_NodeId subCycleBeginTimeNodeId;
+static UA_NodeId subCycleEndTimeNodeId;
+static UA_NodeId subCycleBeginJitterNodeId;
+static UA_NodeId subCallbackDurationNodeId;
+static UA_NodeId subTemperatureNodeId;
+static UA_NodeId subTxHwTimestampNodeId;
+/* Node ID used by subscriber */
+static UA_NodeId subRxHwTimestampNodeId;
+static UA_NodeId pubToSubPathDelayNodeId;
+
+/* The variables to save the subscribed values */
+static UA_UInt64 *subSequenceNumber = NULL;
+static UA_UInt64 *subCycleScheduleTime = NULL;
+static UA_UInt64 *subCycleBeginTime = NULL;
+static UA_UInt64 *subCycleEndTime = NULL;
+static UA_Int64 *subCycleBeginJitter = NULL;
+static UA_UInt64 *subCallbackDuration = NULL;
+static UA_Double *subTemperature = NULL;
+static UA_UInt64 *subTxHwTimestamp = NULL;
+/* Variable used by subscriber */
+static UA_UInt64 lastSequenceNumber = 0;
+static UA_UInt64 lastSubRxHwTimestamp = 0;
+static UA_UInt64 *subRxHwTimestamp = NULL;
+static UA_Int64 *pubToSubPathDelay = NULL;
+
+/* DataValue for the subscribed values */
+static UA_DataValue *staticValueSubSeqNum = NULL;
+static UA_DataValue *staticValueSubCycSched = NULL;
+static UA_DataValue *staticValueSubCycBegin = NULL;
+static UA_DataValue *staticValueSubCycEnd = NULL;
+static UA_DataValue *staticValueSubCycBeginJitter = NULL;
+static UA_DataValue *staticValueSubCallbackDuration = NULL;
+static UA_DataValue *staticValueSubTemperature = NULL;
+static UA_DataValue *staticValueSubTxHwTimestamp = NULL;
+/* DataValue used by subscriber */
+static UA_DataValue *staticValueSubRxHwTimestamp = NULL;
+static UA_DataValue *staticValuePubToSubPathDelay = NULL;
+
+/* Structure to define thread parameters */
+typedef struct {
+    UA_Server *server;
+    void *data;
+    UA_ServerCallback callback;
+    UA_Duration interval_ms;
+    UA_UInt64 *callbackId;
+} threadArg;
+
+static UA_UInt64
+timeConversion(struct timespec *timeSpec) {
+    return (UA_UInt64)(timeSpec->tv_sec * SECONDS_AS_NANO_SECONDS + timeSpec->tv_nsec);
+}
+
+static void
+nanoSecondFieldConversion(struct timespec *timeSpec) {
+    while(timeSpec->tv_nsec > (SECONDS_AS_NANO_SECONDS - 1)) {
+        timeSpec->tv_sec += 1;
+        timeSpec->tv_nsec -= SECONDS_AS_NANO_SECONDS;
+    }
+}
+
+static void *userSubscriber(void *arg) {
+    UA_Server *server;
+    void *data;
+    UA_ServerCallback subCallback;
+    struct timespec now;
+    struct timespec start_time;
+    struct timespec end;
+
+    threadArg *threadArgumentsSubscriber = (threadArg *)arg;
+
+    server = threadArgumentsSubscriber->server;
+    data = threadArgumentsSubscriber->data;
+    subCallback = threadArgumentsSubscriber->callback;
+
+    /* Starting time is rounded up to whole second with 500us offset
+     * to account for the application delay on the publisher and the path
+     * delay from publisher to subscriber
+     */
+    clock_gettime(CLOCKID, &now);
+    start_time.tv_sec = now.tv_sec + 1;
+    start_time.tv_nsec = 500000;
+
+    UA_LOG_INFO(UA_Log_Stdout, UA_LOGCATEGORY_USERLAND,
+        "Starting the subscriber cycle at %ld.%09ld", start_time.tv_sec, start_time.tv_nsec);
+
+    while (running) {
+        clock_nanosleep(CLOCKID, TIMER_ABSTIME, &start_time, NULL);
+
+        lastSequenceNumber = *subSequenceNumber;
+
+        /* 
+         * NOTE: Because the current packet carries the Tx HW timestamp of the
+         * previous packet, get the Rx HW timestamp of the previous packet here
+         * so that we have a pair of Rx/Tx HW timestamp for the same packet.
+         */
+        *subRxHwTimestamp = lastSubRxHwTimestamp;
+
+        /* Read subscribed data */
+        subCallback(server, data);
+
+        /* Get time from CLOCK_REALTIME */
+        clock_gettime(CLOCKID, &end);
+
+        /*
+         * NOTE: Only when a new packet is received, subSequenceNumber will get
+         * incremented, then we will have the updated subTxHwTimestamp for the
+         * last packet. If subSequenceNumber is equal to the previous value, it
+         * means that no packet is received in this cycle.
+         */
+        if (*subSequenceNumber == (lastSequenceNumber + 1)) {
+            /* 
+             * NOTE: Publisher to subscriber path delay is calculated as the Rx HW
+             * timestamp on the subscriber minus the Tx HW timestamp on the publisher.
+             */
+            *pubToSubPathDelay = (UA_Int64)(*subRxHwTimestamp - *subTxHwTimestamp);
+        }
+
+        UA_LOG_INFO(UA_Log_Stdout, UA_LOGCATEGORY_USERLAND, "Packet Sequence Number : %ld", *subSequenceNumber);
+
+        /*
+         * Get the Rx HW timestamp of the current received packet
+         *
+         * NOTE: rxHwTimestamp is updated in UA_PubSubChannelEthernet_receive()
+         */
+        lastSubRxHwTimestamp = rxHwTimestamp;
+
+        /* The next start_time is incremented by cycle interval.
+         * Make sure that start_time is in the future.
+         */
+        while(timeConversion(&start_time) < timeConversion(&end)) {
+            start_time.tv_nsec += (long)(CYCLE_TIME * MILLI_AS_NANO_SECONDS);
+            nanoSecondFieldConversion(&start_time);
+        }
+    }
+
+    UA_free(threadArgumentsSubscriber);
+
+    return (void*)NULL;
+}
+
+static pthread_t
+threadCreation(int threadPriority, size_t coreAffinity,
+               void *(*threadApp) (void *), void *threadAppArgs) {
+    cpu_set_t cpuset;
+    pthread_t current_thread, publisher_thread;
+    struct sched_param schedParam;
+    UA_Int32 ret = 0;
+
+    /* Return the ID for thread */
+    current_thread = pthread_self();
+    schedParam.sched_priority = threadPriority;
+    ret = pthread_setschedparam(current_thread, SCHED_FIFO, &schedParam);
+    if (ret != 0) {
+        fprintf(stderr, "pthread_setschedparam: %s\n", strerror(ret));
+        exit(1);
+    }
+
+    UA_LOG_INFO(UA_Log_Stdout, UA_LOGCATEGORY_USERLAND, \
+                "Subscriber thread priority : %d", schedParam.sched_priority);
+
+    CPU_ZERO(&cpuset);
+    CPU_SET(coreAffinity, &cpuset);
+
+    ret = pthread_setaffinity_np(current_thread, sizeof(cpu_set_t), &cpuset);
+    if (ret != 0) {
+        fprintf(stderr, "pthread_setaffinity_np: %s\n", strerror(ret));
+        exit(1);
+    }
+
+    /* Note: A new thread created by pthread_create inherits a copy of its
+     * creator's CPU affinity mask.
+     */
+    ret = pthread_create(&publisher_thread, NULL, threadApp, threadAppArgs);
+    if (ret != 0) {
+        fprintf(stderr, "pthread_create: %s\n", strerror(ret));
+        exit(1);
+    }
+
+    if (CPU_ISSET(coreAffinity, &cpuset)) {
+        UA_LOG_INFO(UA_Log_Stdout, UA_LOGCATEGORY_USERLAND,
+                    "Publisher on CPU core : %ld", coreAffinity);
+    }
+
+   return publisher_thread;
+}
+
+/* Add a callback for cyclic repetition */
+static UA_StatusCode
+addPubSubApplicationCallback(UA_Server *server, UA_NodeId identifier,
+                             UA_ServerCallback callback, void *data,
+                             UA_Double interval_ms, UA_UInt64 *callbackId) {
+    threadArg *threadArgs = (threadArg *) UA_malloc(sizeof(threadArg));
+
+    /* Pass the value required for the threads */
+    threadArgs->server = server;
+    threadArgs->data = data;
+    threadArgs->callback = callback;
+    threadArgs->interval_ms = interval_ms;
+    threadArgs->callbackId = callbackId;
+
+    /* 
+     * Note: Run Subscriber on last core because we don't know
+     * the number of cores on differenct SoC
+     */
+    size_t core_num = (size_t)(get_nprocs_conf() - 1);
+    *callbackId = threadCreation(SUB_SCHED_PRIORITY, core_num, userSubscriber,
+                                 threadArgs);
+    UA_LOG_INFO(UA_Log_Stdout, UA_LOGCATEGORY_USERLAND,
+                "Subscriber thread callback Id: %ld", *callbackId);
+
+    return UA_STATUSCODE_GOOD;
+}
+
+static UA_StatusCode
+changePubSubApplicationCallbackInterval(UA_Server *server, UA_NodeId identifier,
+                                        UA_UInt64 callbackId, UA_Double interval_ms) {
+    /* Callback interval need not be modified as it is thread based implementation.
+     * The thread uses nanosleep for calculating cycle time and modification in
+     * nanosleep value changes cycle time */
+    return UA_STATUSCODE_GOOD;
+}
+
+/* Remove the callback added for cyclic repetition */
+static void
+removePubSubApplicationCallback(UA_Server *server, UA_NodeId identifier, UA_UInt64 callbackId) {
+    if(callbackId && (pthread_join(callbackId, NULL) != 0))
+        UA_LOG_WARNING(UA_Log_Stdout, UA_LOGCATEGORY_USERLAND,
+                       "pthread_join failed for thread: %ld\n", callbackId);
+}
+
+/* If the external data source is written over the information model, the
+ * externalDataWriteCallback will be triggered. The user has to take care and assure
+ * that the write leads not to synchronization issues and race conditions. */
+static UA_StatusCode
+externalDataWriteCallback(UA_Server *server, const UA_NodeId *sessionId,
+                          void *sessionContext, const UA_NodeId *nodeId,
+                          void *nodeContext, const UA_NumericRange *range,
+                          const UA_DataValue *data) {
+    //node values are updated by using variables in the memory
+    //UA_Server_write is not used for updating node values.
+    return UA_STATUSCODE_GOOD;
+}
+
+static UA_StatusCode
+externalDataReadNotificationCallback(UA_Server *server, const UA_NodeId *sessionId,
+                                     void *sessionContext, const UA_NodeId *nodeid,
+                                     void *nodeContext, const UA_NumericRange *range) {
+    //allow read without any preparation
+    return UA_STATUSCODE_GOOD;
+}
+
+/* Define MetaData for TargetVariables */
+static void
+fillTestDataSetMetaData(UA_DataSetMetaDataType *pMetaData) {
+    if(pMetaData == NULL) {
+        return;
+    }
+
+    UA_DataSetMetaDataType_init(pMetaData);
+    pMetaData->name = UA_STRING("DataSet 1");
+
+    /* Static definition of number of fields size to PUBSUB_CONFIG_FIELD_COUNT
+     * to create targetVariables.
+     */
+    pMetaData->fieldsSize = PUBSUB_CONFIG_FIELD_COUNT;
+    pMetaData->fields = (UA_FieldMetaData *)UA_Array_new(pMetaData->fieldsSize,
+                         &UA_TYPES[UA_TYPES_FIELDMETADATA]);
+
+    UA_FieldMetaData_init(&pMetaData->fields[0]);
+    UA_NodeId_copy(&UA_TYPES[UA_TYPES_UINT64].typeId,
+                   &pMetaData->fields[0].dataType);
+    pMetaData->fields[0].builtInType = UA_NS0ID_UINT64;
+    pMetaData->fields[0].name = UA_STRING ("Publisher Sequence Number");
+    pMetaData->fields[0].valueRank = -1; /* scalar */
+
+    UA_FieldMetaData_init(&pMetaData->fields[1]);
+    UA_NodeId_copy(&UA_TYPES[UA_TYPES_UINT64].typeId,
+                   &pMetaData->fields[1].dataType);
+    pMetaData->fields[1].builtInType = UA_NS0ID_UINT64;
+    pMetaData->fields[1].name = UA_STRING ("Publisher Cycle Schedule Time");
+    pMetaData->fields[1].valueRank = -1; /* scalar */
+
+    UA_FieldMetaData_init(&pMetaData->fields[2]);
+    UA_NodeId_copy(&UA_TYPES[UA_TYPES_UINT64].typeId,
+                   &pMetaData->fields[2].dataType);
+    pMetaData->fields[2].builtInType = UA_NS0ID_UINT64;
+    pMetaData->fields[2].name = UA_STRING ("Publisher Cycle Begin Time");
+    pMetaData->fields[2].valueRank = -1; /* scalar */
+
+    UA_FieldMetaData_init(&pMetaData->fields[3]);
+    UA_NodeId_copy(&UA_TYPES[UA_TYPES_UINT64].typeId,
+                   &pMetaData->fields[3].dataType);
+    pMetaData->fields[3].builtInType = UA_NS0ID_UINT64;
+    pMetaData->fields[3].name = UA_STRING ("Publisher Cycle End Time");
+    pMetaData->fields[3].valueRank = -1; /* scalar */
+
+    UA_FieldMetaData_init(&pMetaData->fields[4]);
+    UA_NodeId_copy(&UA_TYPES[UA_TYPES_INT64].typeId,
+                   &pMetaData->fields[4].dataType);
+    pMetaData->fields[4].builtInType = UA_NS0ID_INT64;
+    pMetaData->fields[4].name = UA_STRING ("Publisher Cycle Begin Jitter");
+    pMetaData->fields[4].valueRank = -1; /* scalar */
+
+    UA_FieldMetaData_init(&pMetaData->fields[5]);
+    UA_NodeId_copy(&UA_TYPES[UA_TYPES_UINT64].typeId,
+                   &pMetaData->fields[5].dataType);
+    pMetaData->fields[5].builtInType = UA_NS0ID_UINT64;
+    pMetaData->fields[5].name = UA_STRING ("Publisher Callback Duration");
+    pMetaData->fields[5].valueRank = -1; /* scalar */
+
+    UA_FieldMetaData_init(&pMetaData->fields[6]);
+    UA_NodeId_copy(&UA_TYPES[UA_TYPES_DOUBLE].typeId,
+                   &pMetaData->fields[6].dataType);
+    pMetaData->fields[6].builtInType = UA_NS0ID_DOUBLE;
+    pMetaData->fields[6].name = UA_STRING ("Publisher Temperature");
+    pMetaData->fields[6].valueRank = -1; /* scalar */
+
+    UA_FieldMetaData_init(&pMetaData->fields[7]);
+    UA_NodeId_copy(&UA_TYPES[UA_TYPES_UINT64].typeId,
+                   &pMetaData->fields[7].dataType);
+    pMetaData->fields[7].builtInType = UA_NS0ID_UINT64;
+    pMetaData->fields[7].name = UA_STRING ("Publisher Tx HW Timestamp");
+    pMetaData->fields[7].valueRank = -1; /* scalar */
+}
+
+/*
+ * Connection handling
+ * -------------------
+ * Add new connection to the server.
+ */
+static UA_StatusCode
+addPubSubConnection(UA_Server *server, UA_String *transportProfile,
+                    UA_NetworkAddressUrlDataType *networkAddressUrl) {
+    if((server == NULL) || (transportProfile == NULL) || (networkAddressUrl == NULL)) {
+        return UA_STATUSCODE_BADINTERNALERROR;
+    }
+
+    UA_StatusCode retval = UA_STATUSCODE_GOOD;
+    UA_PubSubConnectionConfig connectionConfig;
+    memset(&connectionConfig, 0, sizeof(UA_PubSubConnectionConfig));
+    connectionConfig.name = UA_STRING("Subscriber Connection");
+    connectionConfig.transportProfileUri = *transportProfile;
+    connectionConfig.enabled = UA_TRUE;
+    UA_Variant_setScalar(&connectionConfig.address, networkAddressUrl,
+                         &UA_TYPES[UA_TYPES_NETWORKADDRESSURLDATATYPE]);
+    connectionConfig.publisherId.numeric = UA_UInt32_random();
+    retval |= UA_Server_addPubSubConnection(server, &connectionConfig, &connectionIdent);
+    if (retval != UA_STATUSCODE_GOOD) {
+        return retval;
+    }
+
+    return retval;
+}
+
+/*
+ * ReaderGroup handling
+ * --------------------
+ * Add ReaderGroup to the created connection.
+ */
+static UA_StatusCode
+addReaderGroup(UA_Server *server) {
+    if(server == NULL) {
+        return UA_STATUSCODE_BADINTERNALERROR;
+    }
+
+    UA_StatusCode retval = UA_STATUSCODE_GOOD;
+    UA_ReaderGroupConfig readerGroupConfig;
+    memset(&readerGroupConfig, 0, sizeof(UA_ReaderGroupConfig));
+    readerGroupConfig.name = UA_STRING("Demo ReaderGroup");
+    readerGroupConfig.rtLevel = UA_PUBSUB_RT_FIXED_SIZE;
+    readerGroupConfig.pubsubManagerCallback.addCustomCallback = addPubSubApplicationCallback;
+    readerGroupConfig.pubsubManagerCallback.changeCustomCallbackInterval = changePubSubApplicationCallbackInterval;
+    readerGroupConfig.pubsubManagerCallback.removeCustomCallback = removePubSubApplicationCallback;
+
+    retval |= UA_Server_addReaderGroup(server, connectionIdent, &readerGroupConfig,
+                                       &readerGroupIdent);
+
+    return retval;
+}
+
+/*
+ * SubscribedDataSet handling
+ * ----------------------
+ * Set SubscribedDataSet type to TargetVariables data type.
+ * Add subscribedvariables to the DataSetReader.
+ */
+static UA_StatusCode
+addSubscribedVariables(UA_Server *server) {
+    if(server == NULL) {
+        return UA_STATUSCODE_BADINTERNALERROR;
+    }
+
+    UA_StatusCode retval = UA_STATUSCODE_GOOD;
+
+    /* Set the subscribed data to TargetVariable type */
+    readerConfig.subscribedDataSetType = UA_PUBSUB_SDS_TARGET;
+    /* Create the TargetVariables with respect to DataSetMetaData fields */
+    readerConfig.subscribedDataSet.subscribedDataSetTarget.targetVariablesSize = readerConfig.dataSetMetaData.fieldsSize;
+    readerConfig.subscribedDataSet.subscribedDataSetTarget.targetVariables = (UA_FieldTargetVariable *)
+        UA_calloc(readerConfig.dataSetMetaData.fieldsSize, sizeof(UA_FieldTargetVariable));
+
+    if(!readerConfig.subscribedDataSet.subscribedDataSetTarget.targetVariables) {
+        UA_LOG_ERROR(UA_Log_Stdout, UA_LOGCATEGORY_SERVER, "FieldTargetVariable - Bad out of memory");
+        return UA_STATUSCODE_BADOUTOFMEMORY;
+    }
+
+    /* Set the value backend of the nodes to 'external value source' */
+    UA_ValueBackend valueBackend;
+    valueBackend.backendType = UA_VALUEBACKENDTYPE_EXTERNAL;
+    valueBackend.backend.external.callback.userWrite = externalDataWriteCallback;
+    valueBackend.backend.external.callback.notificationRead = externalDataReadNotificationCallback;
+
+    /*** Sequence Number ***/
+    subSequenceNumber = UA_UInt64_new();
+    if(!subSequenceNumber) {
+        UA_LOG_ERROR(UA_Log_Stdout, UA_LOGCATEGORY_SERVER, "subSequenceNumber - Bad out of memory");
+        return UA_STATUSCODE_BADOUTOFMEMORY;
+    }
+    *subSequenceNumber = 0;
+
+    staticValueSubSeqNum = UA_DataValue_new();
+    if(!staticValueSubSeqNum) {
+        UA_LOG_ERROR(UA_Log_Stdout, UA_LOGCATEGORY_SERVER, "staticValueSubSeqNum - Bad out of memory");
+        return UA_STATUSCODE_BADOUTOFMEMORY;
+    }
+    UA_Variant_setScalar(&staticValueSubSeqNum->value, subSequenceNumber, &UA_TYPES[UA_TYPES_UINT64]);
+    staticValueSubSeqNum->hasValue = UA_TRUE;
+
+    valueBackend.backend.external.value = &staticValueSubSeqNum;
+    UA_Server_setVariableNode_valueBackend(server, subSeqNumNodeId, valueBackend);
+
+    /* For creating TargetVariables */
+    UA_FieldTargetDataType_init(&readerConfig.subscribedDataSet.subscribedDataSetTarget.targetVariables[0].targetVariable);
+    readerConfig.subscribedDataSet.subscribedDataSetTarget.targetVariables[0].targetVariable.attributeId  = UA_ATTRIBUTEID_VALUE;
+    readerConfig.subscribedDataSet.subscribedDataSetTarget.targetVariables[0].targetVariable.targetNodeId = subSeqNumNodeId;
+
+    /*** Cycle Schedule Time ***/
+    subCycleScheduleTime = UA_UInt64_new();
+    if(!subCycleScheduleTime) {
+        UA_LOG_ERROR(UA_Log_Stdout, UA_LOGCATEGORY_SERVER, "subCycleScheduleTime - Bad out of memory");
+        return UA_STATUSCODE_BADOUTOFMEMORY;
+    }
+    *subCycleScheduleTime = 0;
+
+    staticValueSubCycSched = UA_DataValue_new();
+    if(!staticValueSubCycSched) {
+        UA_LOG_ERROR(UA_Log_Stdout, UA_LOGCATEGORY_SERVER, "staticValueSubCycSched - Bad out of memory");
+        return UA_STATUSCODE_BADOUTOFMEMORY;
+    }
+    UA_Variant_setScalar(&staticValueSubCycSched->value, subCycleScheduleTime, &UA_TYPES[UA_TYPES_UINT64]);
+    staticValueSubCycSched->hasValue = UA_TRUE;
+
+    valueBackend.backend.external.value = &staticValueSubCycSched;
+    UA_Server_setVariableNode_valueBackend(server, subCycleScheduleTimeNodeId, valueBackend);
+
+    /* For creating TargetVariables */
+    UA_FieldTargetDataType_init(&readerConfig.subscribedDataSet.subscribedDataSetTarget.targetVariables[1].targetVariable);
+    readerConfig.subscribedDataSet.subscribedDataSetTarget.targetVariables[1].targetVariable.attributeId = UA_ATTRIBUTEID_VALUE;
+    readerConfig.subscribedDataSet.subscribedDataSetTarget.targetVariables[1].targetVariable.targetNodeId = subCycleScheduleTimeNodeId;
+
+    /*** Cycle Begin Time from CLOCK_REALTIME ***/
+    subCycleBeginTime = UA_UInt64_new();
+    if(!subCycleBeginTime) {
+        UA_LOG_ERROR(UA_Log_Stdout, UA_LOGCATEGORY_SERVER, "subCycleBeginTime - Bad out of memory");
+        return UA_STATUSCODE_BADOUTOFMEMORY;
+    }
+    *subCycleBeginTime = 0;
+
+    staticValueSubCycBegin = UA_DataValue_new();
+    if(!staticValueSubCycBegin) {
+        UA_LOG_ERROR(UA_Log_Stdout, UA_LOGCATEGORY_SERVER, "staticValueSubCycBegin - Bad out of memory");
+        return UA_STATUSCODE_BADOUTOFMEMORY;
+    }
+    UA_Variant_setScalar(&staticValueSubCycBegin->value, subCycleBeginTime, &UA_TYPES[UA_TYPES_UINT64]);
+    staticValueSubCycBegin->hasValue = UA_TRUE;
+
+    valueBackend.backend.external.value = &staticValueSubCycBegin;
+    UA_Server_setVariableNode_valueBackend(server, subCycleBeginTimeNodeId, valueBackend);
+
+    /* For creating TargetVariables */
+    UA_FieldTargetDataType_init(&readerConfig.subscribedDataSet.subscribedDataSetTarget.targetVariables[2].targetVariable);
+    readerConfig.subscribedDataSet.subscribedDataSetTarget.targetVariables[2].targetVariable.attributeId = UA_ATTRIBUTEID_VALUE;
+    readerConfig.subscribedDataSet.subscribedDataSetTarget.targetVariables[2].targetVariable.targetNodeId = subCycleBeginTimeNodeId;
+
+    /*** Cycle End Time ***/
+    subCycleEndTime = UA_UInt64_new();
+    if(!subCycleEndTime) {
+        UA_LOG_ERROR(UA_Log_Stdout, UA_LOGCATEGORY_SERVER, "subCycleEndTime - Bad out of memory");
+        return UA_STATUSCODE_BADOUTOFMEMORY;
+    }
+    *subCycleEndTime = 0;
+
+    staticValueSubCycEnd = UA_DataValue_new();
+    if(!staticValueSubCycEnd) {
+        UA_LOG_ERROR(UA_Log_Stdout, UA_LOGCATEGORY_SERVER, "staticValueSubCycEnd - Bad out of memory");
+        return UA_STATUSCODE_BADOUTOFMEMORY;
+    }
+    UA_Variant_setScalar(&staticValueSubCycEnd->value, subCycleEndTime, &UA_TYPES[UA_TYPES_UINT64]);
+    staticValueSubCycEnd->hasValue = UA_TRUE;
+
+    valueBackend.backend.external.value = &staticValueSubCycEnd;
+    UA_Server_setVariableNode_valueBackend(server, subCycleEndTimeNodeId, valueBackend);
+
+    /* For creating TargetVariables */
+    UA_FieldTargetDataType_init(&readerConfig.subscribedDataSet.subscribedDataSetTarget.targetVariables[3].targetVariable);
+    readerConfig.subscribedDataSet.subscribedDataSetTarget.targetVariables[3].targetVariable.attributeId = UA_ATTRIBUTEID_VALUE;
+    readerConfig.subscribedDataSet.subscribedDataSetTarget.targetVariables[3].targetVariable.targetNodeId = subCycleEndTimeNodeId;
+
+    /*** Cycle Begin Jitter ***/
+    subCycleBeginJitter = UA_Int64_new();
+    if(!subCycleBeginJitter) {
+        UA_LOG_ERROR(UA_Log_Stdout, UA_LOGCATEGORY_SERVER, "subCycleBeginJitter - Bad out of memory");
+        return UA_STATUSCODE_BADOUTOFMEMORY;
+    }
+    *subCycleBeginJitter = 0;
+
+    staticValueSubCycBeginJitter = UA_DataValue_new();
+    if(!staticValueSubCycBeginJitter) {
+        UA_LOG_ERROR(UA_Log_Stdout, UA_LOGCATEGORY_SERVER, "staticValueSubCycBeginJitter - Bad out of memory");
+        return UA_STATUSCODE_BADOUTOFMEMORY;
+    }
+    UA_Variant_setScalar(&staticValueSubCycBeginJitter->value, subCycleBeginJitter, &UA_TYPES[UA_TYPES_INT64]);
+    staticValueSubCycBeginJitter->hasValue = UA_TRUE;
+
+    valueBackend.backend.external.value = &staticValueSubCycBeginJitter;
+    UA_Server_setVariableNode_valueBackend(server, subCycleBeginJitterNodeId, valueBackend);
+
+    /* For creating TargetVariables */
+    UA_FieldTargetDataType_init(&readerConfig.subscribedDataSet.subscribedDataSetTarget.targetVariables[4].targetVariable);
+    readerConfig.subscribedDataSet.subscribedDataSetTarget.targetVariables[4].targetVariable.attributeId = UA_ATTRIBUTEID_VALUE;
+    readerConfig.subscribedDataSet.subscribedDataSetTarget.targetVariables[4].targetVariable.targetNodeId = subCycleBeginJitterNodeId;
+
+    /*** Publisher Callback Duration ***/
+    subCallbackDuration = UA_UInt64_new();
+    if(!subCallbackDuration) {
+        UA_LOG_ERROR(UA_Log_Stdout, UA_LOGCATEGORY_SERVER, "subCallbackDuration - Bad out of memory");
+        return UA_STATUSCODE_BADOUTOFMEMORY;
+    }
+    *subCallbackDuration = 0;
+
+    staticValueSubCallbackDuration = UA_DataValue_new();
+    if(!staticValueSubCallbackDuration) {
+        UA_LOG_ERROR(UA_Log_Stdout, UA_LOGCATEGORY_SERVER, "staticValueSubCallbackDuration - Bad out of memory");
+        return UA_STATUSCODE_BADOUTOFMEMORY;
+    }
+    UA_Variant_setScalar(&staticValueSubCallbackDuration->value, subCallbackDuration, &UA_TYPES[UA_TYPES_UINT64]);
+    staticValueSubCallbackDuration->hasValue = UA_TRUE;
+
+    valueBackend.backend.external.value = &staticValueSubCallbackDuration;
+    UA_Server_setVariableNode_valueBackend(server, subCallbackDurationNodeId, valueBackend);
+
+    /* For creating TargetVariables */
+    UA_FieldTargetDataType_init(&readerConfig.subscribedDataSet.subscribedDataSetTarget.targetVariables[5].targetVariable);
+    readerConfig.subscribedDataSet.subscribedDataSetTarget.targetVariables[5].targetVariable.attributeId  = UA_ATTRIBUTEID_VALUE;
+    readerConfig.subscribedDataSet.subscribedDataSetTarget.targetVariables[5].targetVariable.targetNodeId = subCallbackDurationNodeId;
+
+    /*** Publisher Temperature ***/
+    subTemperature = UA_Double_new();
+    if(!subTemperature) {
+        UA_LOG_ERROR(UA_Log_Stdout, UA_LOGCATEGORY_SERVER, "subTemperature - Bad out of memory");
+        return UA_STATUSCODE_BADOUTOFMEMORY;
+    }
+    *subTemperature = 0.0;
+
+    staticValueSubTemperature = UA_DataValue_new();
+    if(!staticValueSubTemperature) {
+        UA_LOG_ERROR(UA_Log_Stdout, UA_LOGCATEGORY_SERVER, "staticValueSubTemperature - Bad out of memory");
+        return UA_STATUSCODE_BADOUTOFMEMORY;
+    }
+    UA_Variant_setScalar(&staticValueSubTemperature->value, subTemperature, &UA_TYPES[UA_TYPES_DOUBLE]);
+    staticValueSubTemperature->hasValue = UA_TRUE;
+    
+    valueBackend.backend.external.value = &staticValueSubTemperature;
+    UA_Server_setVariableNode_valueBackend(server, subTemperatureNodeId, valueBackend);
+
+    /* For creating TargetVariables */
+    UA_FieldTargetDataType_init(&readerConfig.subscribedDataSet.subscribedDataSetTarget.targetVariables[6].targetVariable);
+    readerConfig.subscribedDataSet.subscribedDataSetTarget.targetVariables[6].targetVariable.attributeId  = UA_ATTRIBUTEID_VALUE;
+    readerConfig.subscribedDataSet.subscribedDataSetTarget.targetVariables[6].targetVariable.targetNodeId = subTemperatureNodeId;
+
+    /*** Publisher Tx HW timestamp ***/
+    subTxHwTimestamp = UA_UInt64_new();
+    if(!subTxHwTimestamp) {
+        UA_LOG_ERROR(UA_Log_Stdout, UA_LOGCATEGORY_SERVER, "subTxHwTimestamp - Bad out of memory");
+        return UA_STATUSCODE_BADOUTOFMEMORY;
+    }
+    *subTxHwTimestamp = 0;
+
+    staticValueSubTxHwTimestamp = UA_DataValue_new();
+    if(!staticValueSubTxHwTimestamp) {
+        UA_LOG_ERROR(UA_Log_Stdout, UA_LOGCATEGORY_SERVER, "staticValueSubTxHwTimestamp - Bad out of memory");
+        return UA_STATUSCODE_BADOUTOFMEMORY;
+    }
+    UA_Variant_setScalar(&staticValueSubTxHwTimestamp->value, subTxHwTimestamp, &UA_TYPES[UA_TYPES_UINT64]);
+    staticValueSubTxHwTimestamp->hasValue = UA_TRUE;
+
+    valueBackend.backend.external.value = &staticValueSubTxHwTimestamp;
+    UA_Server_setVariableNode_valueBackend(server, subTxHwTimestampNodeId, valueBackend);
+
+    /* For creating TargetVariables */
+    UA_FieldTargetDataType_init(&readerConfig.subscribedDataSet.subscribedDataSetTarget.targetVariables[7].targetVariable);
+    readerConfig.subscribedDataSet.subscribedDataSetTarget.targetVariables[7].targetVariable.attributeId  = UA_ATTRIBUTEID_VALUE;
+    readerConfig.subscribedDataSet.subscribedDataSetTarget.targetVariables[7].targetVariable.targetNodeId = subTxHwTimestampNodeId;
+
+    /*
+     * NOTE: Subscriber Rx HW timestamp and Publisher-to-Subscriber path delay
+     * is not part of subscribedDataSet.
+     */
+
+    /*** Subscriber Rx HW timestamp ***/
+    subRxHwTimestamp = UA_UInt64_new();
+    if(!subRxHwTimestamp) {
+        UA_LOG_ERROR(UA_Log_Stdout, UA_LOGCATEGORY_SERVER, "subTxHwTimestamp - Bad out of memory");
+        return UA_STATUSCODE_BADOUTOFMEMORY;
+    }
+    *subRxHwTimestamp = 0;
+
+    staticValueSubRxHwTimestamp = UA_DataValue_new();
+    if(!staticValueSubRxHwTimestamp) {
+        UA_LOG_ERROR(UA_Log_Stdout, UA_LOGCATEGORY_SERVER, "staticValueSubRxHwTimestamp - Bad out of memory");
+        return UA_STATUSCODE_BADOUTOFMEMORY;
+    }
+    UA_Variant_setScalar(&staticValueSubRxHwTimestamp->value, subRxHwTimestamp, &UA_TYPES[UA_TYPES_UINT64]);
+    staticValueSubRxHwTimestamp->hasValue = UA_TRUE;
+
+    valueBackend.backend.external.value = &staticValueSubRxHwTimestamp;
+    UA_Server_setVariableNode_valueBackend(server, subRxHwTimestampNodeId, valueBackend);
+
+    /*** Publisher-to-Subscriber path delay ***/
+    pubToSubPathDelay = UA_Int64_new();
+    if(!pubToSubPathDelay) {
+        UA_LOG_ERROR(UA_Log_Stdout, UA_LOGCATEGORY_SERVER, "pubToSubPathDelay - Bad out of memory");
+        return UA_STATUSCODE_BADOUTOFMEMORY;
+    }
+    *pubToSubPathDelay = 0;
+
+    staticValuePubToSubPathDelay = UA_DataValue_new();
+    if(!staticValuePubToSubPathDelay) {
+        UA_LOG_ERROR(UA_Log_Stdout, UA_LOGCATEGORY_SERVER, "staticValuePubToSubPathDelay - Bad out of memory");
+        return UA_STATUSCODE_BADOUTOFMEMORY;
+    }
+    UA_Variant_setScalar(&staticValuePubToSubPathDelay->value, pubToSubPathDelay, &UA_TYPES[UA_TYPES_INT64]);
+    staticValuePubToSubPathDelay->hasValue = UA_TRUE;
+
+    valueBackend.backend.external.value = &staticValuePubToSubPathDelay;
+    UA_Server_setVariableNode_valueBackend(server, pubToSubPathDelayNodeId, valueBackend);
+
+    return retval;
+}
+
+/*
+ * DataSetReader handling
+ * ----------------------
+ * Add DataSetReader to the ReaderGroup.
+ */
+static UA_StatusCode
+addDataSetReader(UA_Server *server) {
+    if(server == NULL) {
+        return UA_STATUSCODE_BADINTERNALERROR;
+    }
+
+    UA_StatusCode retval = UA_STATUSCODE_GOOD;
+    memset(&readerConfig, 0, sizeof(UA_DataSetReaderConfig));
+    readerConfig.name = UA_STRING("DataSet Reader");
+    /* Parameters to filter which DataSetMessage has to be processed
+     * by the DataSetReader */
+    UA_UInt16 publisherIdentifier = PUBLISHER_ID_SUB;
+    readerConfig.publisherId.type = &UA_TYPES[UA_TYPES_UINT16];
+    readerConfig.publisherId.data = &publisherIdentifier;
+    readerConfig.writerGroupId = WRITER_GROUP_ID_SUB;
+    readerConfig.dataSetWriterId = DATA_SET_WRITER_ID_SUB;
+
+    readerConfig.messageSettings.encoding = UA_EXTENSIONOBJECT_DECODED;
+    readerConfig.messageSettings.content.decoded.type = &UA_TYPES[UA_TYPES_UADPDATASETREADERMESSAGEDATATYPE];
+    UA_UadpDataSetReaderMessageDataType *dataSetReaderMessage = UA_UadpDataSetReaderMessageDataType_new();
+    dataSetReaderMessage->networkMessageContentMask = (UA_UadpNetworkMessageContentMask)(UA_UADPNETWORKMESSAGECONTENTMASK_PUBLISHERID |
+                                                       (UA_UadpNetworkMessageContentMask)UA_UADPNETWORKMESSAGECONTENTMASK_GROUPHEADER |
+                                                       (UA_UadpNetworkMessageContentMask)UA_UADPNETWORKMESSAGECONTENTMASK_WRITERGROUPID |
+                                                       (UA_UadpNetworkMessageContentMask)UA_UADPNETWORKMESSAGECONTENTMASK_PAYLOADHEADER);
+    readerConfig.messageSettings.content.decoded.data = dataSetReaderMessage;
+
+    /* Setting up MetaData configuration in DataSetReader */
+    fillTestDataSetMetaData(&readerConfig.dataSetMetaData);
+    retval |= addSubscribedVariables(server);
+    retval |= UA_Server_addDataSetReader(server, readerGroupIdent, &readerConfig,
+                                         &readerIdent);
+
+    for(size_t i = 0; i < readerConfig.dataSetMetaData.fieldsSize; i++)
+    {
+        UA_FieldTargetDataType_clear(&readerConfig.subscribedDataSet.subscribedDataSetTarget.targetVariables[i].targetVariable);
+    }
+    UA_free(readerConfig.subscribedDataSet.subscribedDataSetTarget.targetVariables);
+    UA_free(readerConfig.dataSetMetaData.fields);
+
+    UA_UadpDataSetReaderMessageDataType_delete(dataSetReaderMessage);
+
+    return retval;
+}
+
+static void
+addServerNodes(UA_Server *server) {
+    UA_Int64 initValInt64 = 0;
+    UA_UInt64 initValUInt64 = 0;
+    UA_Double initValDouble = 0.0;
+    UA_NodeId objectId;
+    UA_NodeId newNodeId;
+
+    UA_ObjectAttributes oAttr = UA_ObjectAttributes_default;
+    oAttr.displayName = UA_LOCALIZEDTEXT("en-US", "Subscriber");
+    UA_Server_addObjectNode(server, UA_NODEID_NULL,
+                            UA_NODEID_NUMERIC(0, UA_NS0ID_OBJECTSFOLDER),
+                            UA_NODEID_NUMERIC(0, UA_NS0ID_ORGANIZES),
+                            UA_QUALIFIEDNAME(1, "Subscriber"),
+                            UA_NODEID_NUMERIC(0, UA_NS0ID_BASEOBJECTTYPE),
+                            oAttr, NULL, &objectId);
+
+    UA_NodeId_init(&subSeqNumNodeId);
+    subSeqNumNodeId = UA_NODEID_STRING(1, "pub.sequence.number");
+    UA_VariableAttributes vAttr = UA_VariableAttributes_default;
+    vAttr.dataType = UA_TYPES[UA_TYPES_UINT64].typeId;
+    UA_Variant_setScalar(&vAttr.value, &initValUInt64, &UA_TYPES[UA_TYPES_UINT64]);
+    vAttr.displayName = UA_LOCALIZEDTEXT("en-US", "Pub Sequence Number");
+    vAttr.accessLevel = UA_ACCESSLEVELMASK_READ | UA_ACCESSLEVELMASK_WRITE;
+    newNodeId = UA_NODEID_STRING(1, "PubSequenceNumber");
+    UA_Server_addVariableNode(server, newNodeId, objectId,
+                              UA_NODEID_NUMERIC(0, UA_NS0ID_HASCOMPONENT),
+                              UA_QUALIFIEDNAME(1, "Pub Sequence Number"),
+                              UA_NODEID_NUMERIC(0, UA_NS0ID_BASEDATAVARIABLETYPE),
+                              vAttr, NULL, &subSeqNumNodeId);
+
+    UA_NodeId_init(&subCycleScheduleTimeNodeId);
+    subCycleScheduleTimeNodeId = UA_NODEID_STRING(1, "pub.cycle.schedule.time");
+    vAttr = UA_VariableAttributes_default;
+    vAttr.dataType = UA_TYPES[UA_TYPES_UINT64].typeId;
+    UA_Variant_setScalar(&vAttr.value, &initValUInt64, &UA_TYPES[UA_TYPES_UINT64]);
+    vAttr.displayName = UA_LOCALIZEDTEXT("en-US", "Pub Cycle Schedule Time");
+    vAttr.accessLevel = UA_ACCESSLEVELMASK_READ | UA_ACCESSLEVELMASK_WRITE;
+    newNodeId = UA_NODEID_STRING(1, "PubCycleScheduleTime");
+    UA_Server_addVariableNode(server, newNodeId, objectId,
+                              UA_NODEID_NUMERIC(0, UA_NS0ID_HASCOMPONENT),
+                              UA_QUALIFIEDNAME(1, "Pub Cycle Schedule Time"),
+                              UA_NODEID_NUMERIC(0, UA_NS0ID_BASEDATAVARIABLETYPE),
+                              vAttr, NULL, &subCycleScheduleTimeNodeId);
+
+    UA_NodeId_init(&subCycleBeginTimeNodeId);
+    subCycleBeginTimeNodeId = UA_NODEID_STRING(1, "pub.cycle.begin.time");
+    vAttr = UA_VariableAttributes_default;
+    vAttr.dataType = UA_TYPES[UA_TYPES_UINT64].typeId;
+    UA_Variant_setScalar(&vAttr.value, &initValUInt64, &UA_TYPES[UA_TYPES_UINT64]);
+    vAttr.displayName = UA_LOCALIZEDTEXT("en-US", "Pub Cycle Begin Time");
+    vAttr.accessLevel = UA_ACCESSLEVELMASK_READ | UA_ACCESSLEVELMASK_WRITE;
+    newNodeId = UA_NODEID_STRING(1, "PubCycleBeginTime");
+    UA_Server_addVariableNode(server, newNodeId, objectId,
+                              UA_NODEID_NUMERIC(0, UA_NS0ID_HASCOMPONENT),
+                              UA_QUALIFIEDNAME(1, "Pub Cycle Begin Time"),
+                              UA_NODEID_NUMERIC(0, UA_NS0ID_BASEDATAVARIABLETYPE),
+                              vAttr, NULL, &subCycleBeginTimeNodeId);
+
+    UA_NodeId_init(&subCycleEndTimeNodeId);
+    subCycleEndTimeNodeId = UA_NODEID_STRING(1, "pub.cycle.end.time");
+    vAttr = UA_VariableAttributes_default;
+    vAttr.dataType = UA_TYPES[UA_TYPES_UINT64].typeId;
+    UA_Variant_setScalar(&vAttr.value, &initValUInt64, &UA_TYPES[UA_TYPES_UINT64]);
+    vAttr.displayName = UA_LOCALIZEDTEXT("en-US", "Pub Cycle End Time");
+    vAttr.accessLevel = UA_ACCESSLEVELMASK_READ | UA_ACCESSLEVELMASK_WRITE;
+    newNodeId = UA_NODEID_STRING(1, "PubCycleEndTime");
+    UA_Server_addVariableNode(server, newNodeId, objectId,
+                              UA_NODEID_NUMERIC(0, UA_NS0ID_HASCOMPONENT),
+                              UA_QUALIFIEDNAME(1, "Pub Cycle End Time"),
+                              UA_NODEID_NUMERIC(0, UA_NS0ID_BASEDATAVARIABLETYPE),
+                              vAttr, NULL, &subCycleEndTimeNodeId);
+
+    UA_NodeId_init(&subCycleBeginJitterNodeId);
+    subCycleBeginJitterNodeId = UA_NODEID_STRING(1, "pub.cycle.begin.jitter");
+    vAttr = UA_VariableAttributes_default;
+    vAttr.dataType = UA_TYPES[UA_TYPES_INT64].typeId;
+    UA_Variant_setScalar(&vAttr.value, &initValInt64, &UA_TYPES[UA_TYPES_INT64]);
+    vAttr.displayName = UA_LOCALIZEDTEXT("en-US", "Pub Cycle Begin Jitter");
+    vAttr.accessLevel = UA_ACCESSLEVELMASK_READ | UA_ACCESSLEVELMASK_WRITE;
+    newNodeId = UA_NODEID_STRING(1, "PubCycleBeginJitter");
+    UA_Server_addVariableNode(server, newNodeId, objectId,
+                              UA_NODEID_NUMERIC(0, UA_NS0ID_HASCOMPONENT),
+                              UA_QUALIFIEDNAME(1, "Pub Cycle Begin Jitter"),
+                              UA_NODEID_NUMERIC(0, UA_NS0ID_BASEDATAVARIABLETYPE),
+                              vAttr, NULL, &subCycleBeginJitterNodeId);
+
+    UA_NodeId_init(&subCallbackDurationNodeId);
+    subCallbackDurationNodeId = UA_NODEID_STRING(1, "pub.callback.duration");
+    vAttr = UA_VariableAttributes_default;
+    vAttr.dataType = UA_TYPES[UA_TYPES_UINT64].typeId;
+    UA_Variant_setScalar(&vAttr.value, &initValUInt64, &UA_TYPES[UA_TYPES_UINT64]);
+    vAttr.displayName = UA_LOCALIZEDTEXT("en-US", "Pub Callback Duration");
+    vAttr.accessLevel = UA_ACCESSLEVELMASK_READ | UA_ACCESSLEVELMASK_WRITE;
+    newNodeId = UA_NODEID_STRING(1, "PubCallbackDuration");
+    UA_Server_addVariableNode(server, newNodeId, objectId,
+                              UA_NODEID_NUMERIC(0, UA_NS0ID_HASCOMPONENT),
+                              UA_QUALIFIEDNAME(1, "Pub Callback Duration"),
+                              UA_NODEID_NUMERIC(0, UA_NS0ID_BASEDATAVARIABLETYPE),
+                              vAttr, NULL, &subCallbackDurationNodeId);
+
+    UA_NodeId_init(&subTemperatureNodeId);
+    subTemperatureNodeId = UA_NODEID_STRING(1, "pub.cpu.temperature");
+    vAttr = UA_VariableAttributes_default;
+    vAttr.dataType = UA_TYPES[UA_TYPES_DOUBLE].typeId;
+    UA_Variant_setScalar(&vAttr.value, &initValDouble, &UA_TYPES[UA_TYPES_DOUBLE]);
+    vAttr.displayName = UA_LOCALIZEDTEXT("en-US", "Pub CPU Temperature");
+    vAttr.accessLevel = UA_ACCESSLEVELMASK_READ | UA_ACCESSLEVELMASK_WRITE;
+    newNodeId = UA_NODEID_STRING(1, "PubCPUTemperature");
+    UA_Server_addVariableNode(server, newNodeId, objectId,
+                              UA_NODEID_NUMERIC(0, UA_NS0ID_HASCOMPONENT),
+                              UA_QUALIFIEDNAME(1, "Pub CPU Temperature"),
+                              UA_NODEID_NUMERIC(0, UA_NS0ID_BASEDATAVARIABLETYPE),
+                              vAttr, NULL, &subTemperatureNodeId);
+
+    UA_NodeId_init(&subTxHwTimestampNodeId);
+    subTxHwTimestampNodeId = UA_NODEID_STRING(1, "pub.tx.hw.timestamp");
+    vAttr = UA_VariableAttributes_default;
+    vAttr.dataType = UA_TYPES[UA_TYPES_UINT64].typeId;
+    UA_Variant_setScalar(&vAttr.value, &initValUInt64, &UA_TYPES[UA_TYPES_UINT64]);
+    vAttr.displayName = UA_LOCALIZEDTEXT("en-US", "Pub Tx HW Timestamp");
+    vAttr.accessLevel = UA_ACCESSLEVELMASK_READ | UA_ACCESSLEVELMASK_WRITE;
+    newNodeId = UA_NODEID_STRING(1, "PubTxHWTimestamp");
+    UA_Server_addVariableNode(server, newNodeId, objectId,
+                              UA_NODEID_NUMERIC(0, UA_NS0ID_HASCOMPONENT),
+                              UA_QUALIFIEDNAME(1, "Pub Tx HW Timestamp"),
+                              UA_NODEID_NUMERIC(0, UA_NS0ID_BASEDATAVARIABLETYPE),
+                              vAttr, NULL, &subTxHwTimestampNodeId);
+
+    UA_NodeId_init(&subRxHwTimestampNodeId);
+    subRxHwTimestampNodeId = UA_NODEID_STRING(1, "sub.rx.hw.timestamp");
+    vAttr = UA_VariableAttributes_default;
+    vAttr.dataType = UA_TYPES[UA_TYPES_UINT64].typeId;
+    UA_Variant_setScalar(&vAttr.value, &initValUInt64, &UA_TYPES[UA_TYPES_UINT64]);
+    vAttr.displayName = UA_LOCALIZEDTEXT("en-US", "Sub Rx HW Timestamp");
+    vAttr.accessLevel = UA_ACCESSLEVELMASK_READ | UA_ACCESSLEVELMASK_WRITE;
+    newNodeId = UA_NODEID_STRING(1, "SubRxHWTimestamp");
+    UA_Server_addVariableNode(server, newNodeId, objectId,
+                              UA_NODEID_NUMERIC(0, UA_NS0ID_HASCOMPONENT),
+                              UA_QUALIFIEDNAME(1, "Sub Rx HW Timestamp"),
+                              UA_NODEID_NUMERIC(0, UA_NS0ID_BASEDATAVARIABLETYPE),
+                              vAttr, NULL, &subRxHwTimestampNodeId);
+
+    UA_NodeId_init(&pubToSubPathDelayNodeId);
+    pubToSubPathDelayNodeId = UA_NODEID_STRING(1, "pub.to.sub.path.delay");
+    vAttr = UA_VariableAttributes_default;
+    vAttr.dataType = UA_TYPES[UA_TYPES_INT64].typeId;
+    UA_Variant_setScalar(&vAttr.value, &initValInt64, &UA_TYPES[UA_TYPES_INT64]);
+    vAttr.displayName = UA_LOCALIZEDTEXT("en-US", "Pub to Sub Path Delay");
+    vAttr.accessLevel = UA_ACCESSLEVELMASK_READ | UA_ACCESSLEVELMASK_WRITE;
+    newNodeId = UA_NODEID_STRING(1, "PubToSubPathDelay");
+    UA_Server_addVariableNode(server, newNodeId, objectId,
+                              UA_NODEID_NUMERIC(0, UA_NS0ID_HASCOMPONENT),
+                              UA_QUALIFIEDNAME(1, "Pub to Sub Path Delay"),
+                              UA_NODEID_NUMERIC(0, UA_NS0ID_BASEDATAVARIABLETYPE),
+                              vAttr, NULL, &pubToSubPathDelayNodeId);
+}
+
+/* Stop signal */
+static void stopHandler(int sign) {
+    UA_LOG_INFO(UA_Log_Stdout, UA_LOGCATEGORY_SERVER, "Received ctrl-c");
+    running = false;
+}
+
+static int
+run(UA_String *transportProfile, UA_NetworkAddressUrlDataType *networkAddressUrl) {
+    signal(SIGINT, stopHandler);
+    signal(SIGTERM, stopHandler);
+
+    UA_StatusCode retval = UA_STATUSCODE_GOOD;
+    UA_Server *server = UA_Server_new();
+    if(!server) {
+        UA_LOG_ERROR(UA_Log_Stdout, UA_LOGCATEGORY_SERVER, "Can't allocate a UA_Server");
+        return EXIT_FAILURE;
+    }
+
+    UA_ServerConfig *config = UA_Server_getConfig(server);
+    UA_ServerConfig_setMinimal(config, 4801, NULL);
+
+    config->pubsubTransportLayers =
+        (UA_PubSubTransportLayer *) UA_malloc(sizeof(UA_PubSubTransportLayer));
+    if(!config->pubsubTransportLayers) {
+        UA_LOG_ERROR(UA_Log_Stdout, UA_LOGCATEGORY_SERVER, "Can't allocate a UA_PubSubTransportLayer");
+        UA_Server_delete(server);
+        return EXIT_FAILURE;
+    }
+    config->pubsubTransportLayers[0] = UA_PubSubTransportLayerEthernet();
+    config->pubsubTransportLayersSize++;
+
+    addServerNodes(server);
+
+    /* Add PubSubConnection */
+    retval |= addPubSubConnection(server, transportProfile, networkAddressUrl);
+    if (retval != UA_STATUSCODE_GOOD) {
+        return EXIT_FAILURE;
+    }
+
+    /* Add ReaderGroup to the created PubSubConnection */
+    retval |= addReaderGroup(server);
+    if (retval != UA_STATUSCODE_GOOD) {
+        return EXIT_FAILURE;
+    }
+
+    /* Add DataSetReader to the created ReaderGroup */
+    retval |= addDataSetReader(server);
+    if (retval != UA_STATUSCODE_GOOD) {
+        return EXIT_FAILURE;
+    }
+
+    UA_PubSubConnection *connection;
+    TAILQ_FOREACH(connection, &server->pubSubManager.connections, listEntry) {
+        if (UA_NodeId_equal(&connection->identifier, &connectionIdent)) {
+            subSockFd = connection->channel->sockfd;
+            break;
+        }
+    }
+    UA_LOG_INFO(UA_Log_Stdout, UA_LOGCATEGORY_USERLAND, "Subscriber socket FD : %d", subSockFd);
+
+    int ret;
+    ret = getRxHwTimestampConfig(subSockFd, (char *)networkAddressUrl->networkInterface.data);
+    if (ret < 0) {
+        UA_LOG_WARNING(UA_Log_Stdout, UA_LOGCATEGORY_USERLAND, "Subscriber Rx HW timestamp : Disabled");
+        retval |= UA_STATUSCODE_BADINTERNALERROR;
+    } else {
+        UA_LOG_INFO(UA_Log_Stdout, UA_LOGCATEGORY_USERLAND, "Subscriber Rx HW timestamp : Enabled");
+    }
+    ret = configSocketHwTimestamp(subSockFd);
+    if (ret < 0) {
+        UA_LOG_WARNING(UA_Log_Stdout, UA_LOGCATEGORY_USERLAND, "configSocketHwTimestamp failed!");
+        retval |= UA_STATUSCODE_BADINTERNALERROR;
+    }
+
+    /* Freeze the PubSub configuration (and start implicitly the subscribe callback) */
+    UA_Server_freezeReaderGroupConfiguration(server, readerGroupIdent);
+    UA_Server_setReaderGroupOperational(server, readerGroupIdent);
+
+    /* Run the server */
+    retval |= UA_Server_run(server, &running);
+
+    UA_Server_unfreezeReaderGroupConfiguration(server, readerGroupIdent);
+    UA_Server_delete(server);
+
+    /* Free external data source */
+    if(subSequenceNumber != NULL) {
+        UA_free(subSequenceNumber);
+    }
+    if(subCycleScheduleTime != NULL) {
+        UA_free(subCycleScheduleTime);
+    }
+    if(subCycleBeginTime != NULL) {
+        UA_free(subCycleBeginTime);
+    }
+    if(subCycleEndTime != NULL) {
+        UA_free(subCycleEndTime);
+    }
+    if(subCycleBeginJitter != NULL) {
+        UA_free(subCycleBeginJitter);
+    }
+    if(subCallbackDuration != NULL) {
+        UA_free(subCallbackDuration);
+    }
+    if(subTemperature != NULL) {
+        UA_free(subTemperature);
+    }
+    if(subRxHwTimestamp != NULL) {
+        UA_free(subRxHwTimestamp);
+    }
+    if(pubToSubPathDelay != NULL) {
+        UA_free(pubToSubPathDelay);
+    }
+
+    if(staticValueSubSeqNum != NULL) {
+        UA_DataValue_delete(staticValueSubSeqNum);
+    }
+    if(staticValueSubCycSched != NULL) {
+        UA_DataValue_delete(staticValueSubCycSched);
+    }
+    if(staticValueSubCycBegin != NULL) {
+        UA_DataValue_delete(staticValueSubCycBegin);
+    }
+    if(staticValueSubCycEnd != NULL) {
+        UA_DataValue_delete(staticValueSubCycEnd);
+    }
+    if(staticValueSubCycBeginJitter != NULL) {
+        UA_DataValue_delete(staticValueSubCycBeginJitter);
+    }
+    if(staticValueSubCallbackDuration != NULL) {
+        UA_DataValue_delete(staticValueSubCallbackDuration);
+    }
+    if(staticValueSubTemperature != NULL) {
+        UA_DataValue_delete(staticValueSubTemperature);
+    }
+    if(staticValueSubRxHwTimestamp != NULL) {
+        UA_DataValue_delete(staticValueSubRxHwTimestamp);
+    }
+    if(staticValuePubToSubPathDelay != NULL) {
+        UA_DataValue_delete(staticValuePubToSubPathDelay);
+    }
+
+    return retval == UA_STATUSCODE_GOOD ? EXIT_SUCCESS : EXIT_FAILURE;
+}
+
+static void
+usage(void)
+{
+    printf("\nUsage:"
+           "\n\topcua_pubsub_subscriber -u <url> -d <device>\n"
+           "\n\tExample: opcua_pubsub_subscriber -u opc.eth://01-00-5E-00-00-01 -d eth1\n");
+    printf("\nOptions:\n"
+           "\t-u [url]          network address URL (default: opc.eth://01-00-5E-00-00-01)\n"
+           "\t-d [dev]          ethernet device (default: eth1)\n"
+           "\t-h                prints this message and exits\n\n");
+}
+
+int main(int argc, char **argv) {
+    int rc = 0;
+    int option;
+    UA_Boolean eth_required = false;
+    UA_String transportProfile =
+        UA_STRING("http://opcfoundation.org/UA-Profile/Transport/pubsub-eth-uadp");
+    UA_NetworkAddressUrlDataType networkAddressUrl =
+        {UA_STRING("eth1"), UA_STRING("opc.eth://01-00-5E-00-00-01")};
+
+    while ((option = getopt(argc, argv, "hu:d:")) != -1) {
+        switch (option) {
+
+        case 'u':
+            if (strncmp(optarg, "opc.eth://", 10) == 0) {
+                networkAddressUrl.url = UA_STRING(optarg);
+                eth_required = true;
+            } else {
+                printf("invalid -u option\n");
+                usage();
+                goto err;
+            }
+            break;
+
+        case 'd':
+            networkAddressUrl.networkInterface = UA_STRING(optarg);
+            break;
+
+        case 'h':
+            usage();
+            return EXIT_SUCCESS;
+
+        default:
+            rc = -1;
+            usage();
+            goto err;
+        }
+    }
+
+    if (eth_required && networkAddressUrl.networkInterface.length == 0) {
+        printf("-d option required for Ethernet multicast\n");
+        usage();
+        goto err;
+    }
+
+    UA_LOG_INFO(UA_Log_Stdout, UA_LOGCATEGORY_USERLAND, "Transport Profile   : %s", transportProfile.data);
+    UA_LOG_INFO(UA_Log_Stdout, UA_LOGCATEGORY_USERLAND, "Network Address URL : %s", networkAddressUrl.url.data);
+    UA_LOG_INFO(UA_Log_Stdout, UA_LOGCATEGORY_USERLAND, "Ethernet Interface  : %s", networkAddressUrl.networkInterface.data);
+
+    return run(&transportProfile, &networkAddressUrl);
+
+err:
+    return rc;
+}
diff --git a/examples/pubsub_realtime/thermal.c b/examples/pubsub_realtime/thermal.c
new file mode 100644
index 00000000..dd11aa09
--- /dev/null
+++ b/examples/pubsub_realtime/thermal.c
@@ -0,0 +1,42 @@
+/*
+ * Copyright 2021 NXP
+ *
+ * SPDX-License-Identifier: (GPL-2.0 OR MIT)
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <errno.h>
+
+#include "thermal.h"
+
+#define SYSFS_THERMAL_ZONE0 "/sys/class/thermal/thermal_zone0/temp"
+
+double get_cpu_temperature(void)
+{
+    int fd;
+    char buf[10];
+    ssize_t len;
+    double celsius;
+
+    fd = open(SYSFS_THERMAL_ZONE0, O_RDONLY);
+    if (fd < 0) {
+        return 0;
+    }
+    else {
+        len = read(fd, buf, sizeof(buf)-1);
+        if (len < 0) {
+            fprintf(stderr, "read %s: %s\n", SYSFS_THERMAL_ZONE0, strerror(errno));
+        }
+        buf[len] = 0;
+
+        celsius = (double)atoi(buf) / 1000;
+
+        close(fd);
+    }
+
+    return celsius;
+}
diff --git a/examples/pubsub_realtime/thermal.h b/examples/pubsub_realtime/thermal.h
new file mode 100644
index 00000000..1ee4f6bb
--- /dev/null
+++ b/examples/pubsub_realtime/thermal.h
@@ -0,0 +1,12 @@
+/*
+ * Copyright 2021 NXP
+ *
+ * SPDX-License-Identifier: (GPL-2.0 OR MIT)
+ */
+
+#ifndef _THERMAL_H_
+#define _THERMAL_H_
+
+double get_cpu_temperature(void);
+
+#endif /* _THERMAL_H_ */
diff --git a/examples/pubsub_realtime/timestamp.c b/examples/pubsub_realtime/timestamp.c
new file mode 100644
index 00000000..1eb6a348
--- /dev/null
+++ b/examples/pubsub_realtime/timestamp.c
@@ -0,0 +1,196 @@
+/*
+ * Copyright 2021 NXP
+ *
+ * SPDX-License-Identifier: (GPL-2.0 OR MIT)
+ */
+
+#define _GNU_SOURCE
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <string.h>
+#include <poll.h>
+#include <sys/time.h>
+#include <sys/socket.h>
+#include <sys/ioctl.h>
+#include <arpa/inet.h>
+#include <net/if.h>
+#include <linux/net_tstamp.h>
+#include <linux/sockios.h>
+
+#include "timestamp.h"
+
+#define TIMEOUT 1000 /* in millisecond */
+#define NSECS_PER_SEC 1000000000
+
+/*
+ * Prerequisite:
+ * 
+ *       (1) Enable transmit time stamping by running ptp4l
+ *       (2) Enable receive time stamping for any incoming packet
+ *           by executing 'hwstamp_ctl -i eth1 -r 1'
+ */
+int configSocketHwTimestamp(int sock)
+{
+    int ret = 0;
+    int flags = 0;
+
+    /* set socket options for hardware time stamping */
+    flags = SOF_TIMESTAMPING_TX_HARDWARE | SOF_TIMESTAMPING_RX_HARDWARE |
+            SOF_TIMESTAMPING_RAW_HARDWARE;
+
+    ret = setsockopt(sock, SOL_SOCKET, SO_TIMESTAMPING, &flags, sizeof(flags));
+    if (ret < 0) {
+        fprintf(stderr, "setsockopt SO_TIMESTAMPING failed : %s\n", strerror(errno));
+        return ret;
+    }
+
+    return 0;
+}
+
+/*
+ * Get the Tx HW timestmap configuration for the given ethernet interface
+ */
+int getTxHwTimestampConfig(int sock, char *ifname)
+{
+    struct ifreq ifreq;
+    struct hwtstamp_config hwconfig;
+    int ret = 0;
+
+    memset(&ifreq, 0, sizeof(ifreq));
+    memset(&hwconfig, 0, sizeof(hwconfig));
+    strncpy(ifreq.ifr_name, ifname, sizeof(ifreq.ifr_name) - 1);
+    ifreq.ifr_data = (char *)&hwconfig;
+
+    ret = ioctl(sock, SIOCGHWTSTAMP, &ifreq);
+    if (ret < 0) {
+        fprintf(stderr, "ioctl SIOCGHWTSTAMP failed : %s\n", strerror(errno));
+        return ret;
+    }
+
+    /* HWTSTAMP_TX_ON - hardware time stamping for outgoing packets enabled */
+    if (hwconfig.tx_type != HWTSTAMP_TX_ON) {
+        fprintf(stderr, "Tx HW timestamp disabled! Please run ptp4l to enable it!\n");
+        return -1;
+    }
+
+    return 0;
+}
+
+/*
+ * Get the Rx HW timestmap configuration for the given ethernet interface
+ */
+int getRxHwTimestampConfig(int sock, char *ifname)
+{
+    struct ifreq ifreq;
+    struct hwtstamp_config hwconfig;
+    int ret = 0;
+
+    memset(&ifreq, 0, sizeof(ifreq));
+    memset(&hwconfig, 0, sizeof(hwconfig));
+    strncpy(ifreq.ifr_name, ifname, sizeof(ifreq.ifr_name) - 1);
+    ifreq.ifr_data = (char *)&hwconfig;
+
+    ret = ioctl(sock, SIOCGHWTSTAMP, &ifreq);
+    if (ret < 0) {
+        fprintf(stderr, "ioctl SIOCGHWTSTAMP failed : %s\n", strerror(errno));
+        return ret;
+    }
+
+    /* HWTSTAMP_FILTER_ALL - time stamp any incoming packet */
+    if (hwconfig.rx_filter != HWTSTAMP_FILTER_ALL) {
+        fprintf(stderr, "Rx HW timestamp disabled! Please run 'hwstamp_ctl -i %s -r 1' to enable it!\n",
+               ifname);
+        return -1;
+    }
+
+    return 0;
+}
+
+
+/*
+ * For transmit timestamps the outgoing packet is looped back to the
+ * socket's error queue with the send timestamp(s) attached. A process
+ * receives the timestamps by calling recvmsg() with flag MSG_ERRQUEUE
+ * set and with a msg_control buffer sufficiently large to receive the
+ * relevant metadata structures.
+ *
+ * Reading from the error queue is always a non-blocking operation. To
+ * block waiting on a timestamp, use poll or select. poll() will return
+ * POLLERR in pollfd.revents if any data is ready on the error queue.
+ */
+int getTxHwTimestamp(int sock, unsigned long long *timestamp)
+{
+    struct pollfd pfd;
+    nfds_t nfds = 1;
+    int ret;
+    struct msghdr msg;
+    struct iovec entry;
+    char data[256];
+    union {
+        struct cmsghdr cm;
+        char buf[512];
+    } u;
+    ssize_t cnt;
+    struct cmsghdr *cmsg;
+    struct timespec *ts = NULL;
+
+    memset(&pfd, 0, sizeof(pfd));
+    pfd.fd = sock;
+    pfd.events = POLLPRI;
+    ret = poll(&pfd, nfds, TIMEOUT);
+    if (ret < 0) {
+        fprintf(stderr, "poll for tx timestamp failed : %s\n", strerror(errno));
+        return ret;
+    } else if (ret == 0) {
+        fprintf(stderr, "timed out while polling for tx timestamp!\n");
+        return -1;
+    }
+
+    memset(&msg, 0, sizeof(msg));
+    entry.iov_base = data;
+    entry.iov_len = sizeof(data);
+    msg.msg_iov = &entry;
+    msg.msg_iovlen = 1;
+    msg.msg_control = u.buf;
+    msg.msg_controllen = sizeof(u.buf);
+
+    cnt = recvmsg(sock, &msg, MSG_ERRQUEUE | MSG_DONTWAIT);
+    if (cnt < 0) {
+        fprintf(stderr, "recvmsg for tx timestamp failed : %s\n", strerror(errno));
+        return -1;
+    }
+
+    for (cmsg = CMSG_FIRSTHDR(&msg); cmsg != NULL; cmsg = CMSG_NXTHDR(&msg, cmsg)) {
+        if (cmsg->cmsg_level == SOL_SOCKET && cmsg->cmsg_type == SO_TIMESTAMPING) {
+            if (cmsg->cmsg_len < sizeof(*ts) * 3) {
+                fprintf(stderr, "short SO_TIMESTAMPING message!\n");
+            } else {
+                ts = (struct timespec *)CMSG_DATA(cmsg);
+                *timestamp = (unsigned long long)(ts[2].tv_sec * NSECS_PER_SEC + ts[2].tv_nsec);
+            }
+            break;
+        }
+    }
+
+    return 0;
+}
+
+/* 
+ * NOTE: The timestamp got from ioctl SIOCGSTAMPNS is not hardware timestamp.
+ *       The clock used for this timestamp is CLOCK_REALTIME.
+ */
+int getRxTimestamp(int sock, unsigned long long *timestamp)
+{
+    struct timespec ts;
+
+    if (ioctl(sock, SIOCGSTAMPNS, &ts) == -1) {
+        fprintf(stderr, "SIOCGSTAMPNS : %s\n", strerror(errno));
+        return -1;
+    }
+
+    *timestamp = (unsigned long long)(ts.tv_sec * NSECS_PER_SEC + ts.tv_nsec);
+
+    return 0;
+}
diff --git a/examples/pubsub_realtime/timestamp.h b/examples/pubsub_realtime/timestamp.h
new file mode 100644
index 00000000..db7682ec
--- /dev/null
+++ b/examples/pubsub_realtime/timestamp.h
@@ -0,0 +1,16 @@
+/*
+ * Copyright 2021 NXP
+ *
+ * SPDX-License-Identifier: (GPL-2.0 OR MIT)
+ */
+
+#ifndef _TIMESTAMP_H_
+#define _TIMESTAMP_H_
+
+int configSocketHwTimestamp(int sock);
+int getTxHwTimestampConfig(int sock, char *ifname);
+int getRxHwTimestampConfig(int sock, char *ifname);
+int getTxHwTimestamp(int sock, unsigned long long *timestamp);
+int getRxTimestamp(int sock, unsigned long long *timestamp);
+
+#endif /* _TIMESTAMP_H_ */
diff --git a/plugins/include/open62541/plugin/pubsub_ethernet.h b/plugins/include/open62541/plugin/pubsub_ethernet.h
index cbf62683..f95c2b7a 100644
--- a/plugins/include/open62541/plugin/pubsub_ethernet.h
+++ b/plugins/include/open62541/plugin/pubsub_ethernet.h
@@ -11,6 +11,10 @@
 
 _UA_BEGIN_DECLS
 
+#ifdef UA_ENABLE_PUBSUB_ETH_RX_HW_TIMESTAMP
+UA_EXPORT extern UA_UInt64 rxHwTimestamp;
+#endif
+
 UA_PubSubTransportLayer UA_EXPORT
 UA_PubSubTransportLayerEthernet(void);
 
diff --git a/plugins/ua_pubsub_ethernet.c b/plugins/ua_pubsub_ethernet.c
index ead8dffa..73684685 100644
--- a/plugins/ua_pubsub_ethernet.c
+++ b/plugins/ua_pubsub_ethernet.c
@@ -38,6 +38,10 @@ typedef struct {
     UA_Byte targetAddress[ETH_ALEN];
 } UA_PubSubChannelDataEthernet;
 
+#ifdef UA_ENABLE_PUBSUB_ETH_RX_HW_TIMESTAMP
+UA_UInt64 rxHwTimestamp;
+#endif
+
 /*
  * OPC-UA specification Part 14:
  *
@@ -420,6 +424,14 @@ UA_PubSubChannelEthernet_receive(UA_PubSubChannel *channel, UA_ByteString *messa
     UA_Int32        receiveFlags;
     UA_StatusCode   retval = UA_STATUSCODE_GOOD;
     UA_UInt16       rcvCount = 0;
+#ifdef UA_ENABLE_PUBSUB_ETH_RX_HW_TIMESTAMP
+    union {
+        struct cmsghdr cm;
+        char buf[512];
+    } u;
+    struct cmsghdr *cmsg;
+    struct timespec *ts = NULL;
+#endif
 
     memset(&tmptv, 0, sizeof(tmptv));
 
@@ -477,6 +489,10 @@ UA_PubSubChannelEthernet_receive(UA_PubSubChannel *channel, UA_ByteString *messa
         iov[1].iov_len  = remainingMessageLength;
         msg.msg_iov     = iov;
         msg.msg_iovlen  = 2;
+#ifdef UA_ENABLE_PUBSUB_ETH_RX_HW_TIMESTAMP
+        msg.msg_control = u.buf;
+        msg.msg_controllen = sizeof(u.buf);
+#endif
 
         dataLen = recvmsg(channel->sockfd, &msg, receiveFlags);
         if(dataLen < 0) {
@@ -503,6 +519,22 @@ UA_PubSubChannelEthernet_receive(UA_PubSubChannel *channel, UA_ByteString *messa
             break;
         }
 
+#ifdef UA_ENABLE_PUBSUB_ETH_RX_HW_TIMESTAMP
+        rxHwTimestamp = 0;
+        for (cmsg = CMSG_FIRSTHDR(&msg); cmsg != NULL; cmsg = CMSG_NXTHDR(&msg, cmsg)) {
+            if (cmsg->cmsg_level == SOL_SOCKET && cmsg->cmsg_type == SO_TIMESTAMPING) {
+                if (cmsg->cmsg_len < sizeof(*ts) * 3) {
+                    UA_LOG_ERROR(UA_Log_Stdout, UA_LOGCATEGORY_SERVER,
+                                 "short SO_TIMESTAMPING message!\n");
+                } else {
+                    ts = (struct timespec *)CMSG_DATA(cmsg);
+                    rxHwTimestamp = (UA_UInt64)(ts[2].tv_sec * 1000000000 + ts[2].tv_nsec);
+                }
+                break;
+            }
+        }
+#endif
+
         /* Make sure we match our target */
         if(memcmp(eth_hdr.ether_dhost, channelDataEthernet->targetAddress, ETH_ALEN) != 0) {
             retval = UA_STATUSCODE_GOODNODATA;
-- 
2.17.1

