From 5977428aa5de9111d4a2668102992cc6c92f5c6c Mon Sep 17 00:00:00 2001
From: Davide Cavion <davide@rfnm.io>
Date: Wed, 5 Jul 2023 15:19:40 +0200
Subject: [PATCH 2/7] Basic structure for a bit-banging ws2812b LED driver

Signed-off-by: Davide Cavion <davide@rfnm.io>
---
 arch/arm64/boot/dts/freescale/imx8mp-rfnm.dts |  15 ++
 arch/arm64/configs/imx8mp_rfnm_defconfig      |  18 +-
 drivers/leds/Kconfig                          |   7 +
 drivers/leds/Makefile                         |   2 +
 drivers/leds/leds-rfnm-wsled.c                | 197 ++++++++++++++++++
 5 files changed, 222 insertions(+), 17 deletions(-)
 create mode 100644 drivers/leds/leds-rfnm-wsled.c

diff --git a/arch/arm64/boot/dts/freescale/imx8mp-rfnm.dts b/arch/arm64/boot/dts/freescale/imx8mp-rfnm.dts
index a727eab6c7f5..7ac531f0a867 100644
--- a/arch/arm64/boot/dts/freescale/imx8mp-rfnm.dts
+++ b/arch/arm64/boot/dts/freescale/imx8mp-rfnm.dts
@@ -66,6 +66,15 @@ reg_usdhc2_vmmc: regulator-usdhc2 {
 		enable-active-high;
 	};
 
+	rfnm_wsled {
+		compatible = "rfnm,wsled";
+		wsled1-gpios = <&gpio3 7 GPIO_ACTIVE_HIGH>;
+		wsled2-gpios = <&gpio3 8 GPIO_ACTIVE_HIGH>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_wsled>;
+		status = "okay";
+	};
+
 
 	sound-hdmi {
 		compatible = "fsl,imx-audio-hdmi";
@@ -704,6 +713,12 @@ MX8MP_IOMUXC_SD2_WP__GPIO2_IO20            0x00000146
     	};
     */
 
+	pinctrl_wsled: wsledgrp {
+		fsl,pins = <
+			MX8MP_IOMUXC_NAND_DATA01__GPIO3_IO07       0x00000016 // needed to enable clocking to this gpio peripheral
+			MX8MP_IOMUXC_NAND_DATA02__GPIO3_IO08       0x00000016 // needed to enable clocking to this gpio peripheral
+		>;
+	};
 
     pinctrl_ecspi1: ecspi1grp {
 		fsl,pins = <
diff --git a/arch/arm64/configs/imx8mp_rfnm_defconfig b/arch/arm64/configs/imx8mp_rfnm_defconfig
index 15b4b6033583..66e224758394 100644
--- a/arch/arm64/configs/imx8mp_rfnm_defconfig
+++ b/arch/arm64/configs/imx8mp_rfnm_defconfig
@@ -1,25 +1,9 @@
 CONFIG_BOOT_PRINTK_DELAY=y
 CONFIG_RFNM_BOOTCONFIG=y
 CONFIG_STRICT_DEVMEM=n
-CONFIG_IIO_BUFFER_CB=y
-CONFIG_IIO_BUFFER_DMA=y
-CONFIG_IIO_BUFFER_DMAENGINE=y
-CONFIG_IIO_BUFFER_HW_CONSUMER=y
-CONFIG_IIO_KFIFO_BUF=y
-CONFIG_IIO_TRIGGERED_BUFFER=y
-CONFIG_IIO_CONFIGFS=y
-CONFIG_IIO_TRIGGER=y
-CONFIG_IIO_CONSUMERS_PER_TRIGGER=2
-CONFIG_IIO_SW_DEVICE=y
-CONFIG_IIO_SW_TRIGGER=y
-CONFIG_IIO_TRIGGERED_EVENT=y
-CONFIG_GENERIC_PTDUMP=y
-CONFIG_DYNAMIC_DEBUG=y
-CONFIG_DYNAMIC_DEBUG_CORE=y
-CONFIG_PTDUMP_CORE=y
-CONFIG_PTDUMP_DEBUGFS=y
 CONFIG_USB_GADGETFS=y
 CONFIG_RFNM_SI5510=y
+CONFIG_LEDS_RFNM_WSLED=y
 CONFIG_SENSORS_TMP102=y
 CONFIG_SYSVIPC=y
 CONFIG_POSIX_MQUEUE=y
diff --git a/drivers/leds/Kconfig b/drivers/leds/Kconfig
index 025df008c3c6..ef063cc74a53 100644
--- a/drivers/leds/Kconfig
+++ b/drivers/leds/Kconfig
@@ -881,6 +881,13 @@ config LEDS_ACER_A500
 	help
 	  This option enables support for the Power Button LED of
 	  Acer Iconia Tab A500.
+	  
+config LEDS_RFNM_WSLED
+	tristate "Enable RFNM's WS2812B driver"
+	depends on LEDS_CLASS
+	help
+	  This simple driver bitbangs LEDs connected to GPIOs, so it 
+	  depends on CPU frequency, which is assumed as 1600 MHz. 
 
 source "drivers/leds/blink/Kconfig"
 
diff --git a/drivers/leds/Makefile b/drivers/leds/Makefile
index f25f71ea627b..7d9b50dd5c2f 100644
--- a/drivers/leds/Makefile
+++ b/drivers/leds/Makefile
@@ -7,6 +7,8 @@ obj-$(CONFIG_LEDS_CLASS_FLASH)		+= led-class-flash.o
 obj-$(CONFIG_LEDS_CLASS_MULTICOLOR)	+= led-class-multicolor.o
 obj-$(CONFIG_LEDS_TRIGGERS)		+= led-triggers.o
 
+obj-$(CONFIG_LEDS_RFNM_WSLED)			+= leds-rfnm-wsled.o
+
 # LED Platform Drivers (keep this sorted, M-| sort)
 obj-$(CONFIG_LEDS_88PM860X)		+= leds-88pm860x.o
 obj-$(CONFIG_LEDS_ACER_A500)		+= leds-acer-a500.o
diff --git a/drivers/leds/leds-rfnm-wsled.c b/drivers/leds/leds-rfnm-wsled.c
new file mode 100644
index 000000000000..a02fae987936
--- /dev/null
+++ b/drivers/leds/leds-rfnm-wsled.c
@@ -0,0 +1,197 @@
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+#include <linux/leds.h>
+#include <linux/module.h>
+#include <linux/io.h>
+#include <linux/of_device.h>
+#include <linux/gpio/consumer.h>
+
+
+uint32_t rfnm_wsled_chain[2][4] = {
+	// first is the arm cycle prefetch
+	// 4th is the first LED (motherboard)
+	// 3rd is the first LED on daughterboard
+	// 2nd is the second LED on daughterboard
+	// color order is (left to right) GRB
+	{0xaaaaaaaa, 0x30ff00, 0, 0},
+	{0xaaaaaaaa, 0x30ff00, 0, 0}
+};
+
+void __iomem *rfnm_wsled_io;
+
+void rfnm_wsled_send_chain(uint8_t chain_id) {
+
+	uint16_t bitmap;
+	
+	if(chain_id == 0) {
+		bitmap = 0x80;
+	} else {
+		bitmap = 0x100;
+	}
+	
+	volatile unsigned int *addr;
+	addr = (volatile unsigned int *) rfnm_wsled_io;
+
+	uint32_t initial = *addr;
+	uint32_t cond_high = initial | bitmap;
+	uint32_t cond_low = initial & ~(bitmap);
+
+	// 1000 = 1.06us
+	// 200 = 160ns
+
+	int z;
+
+	// do not trigger reset condition here, assume application layer takes care of it
+	//*addr = cond_low; for(z = 0; z < 250000; z++) asm volatile ("nop");
+
+	uint32_t send[4];
+	for(z = 0; z < 4; z++) {
+		send[z] = rfnm_wsled_chain[chain_id][z];
+	}
+	int8_t current_bit = 0;
+	uint8_t current_led = 0;
+
+	uint8_t bit = (send[current_led] & (1 << current_bit)) >> current_bit;
+
+	for(current_led = 0; current_led < 4; current_led++) {
+		for(current_bit = 23; current_bit >= 0; current_bit--) {
+
+			if(current_led != 0) {
+				*addr = cond_high; // reset condition while prefetching the loop
+			}
+
+			bit = (send[current_led] & (1 << current_bit)) >> current_bit;
+
+#if 0
+			// reset time -> 280us+
+			// send one   -> high for 790 +- 210 ns; then low for 790 +- 210 ns
+			// send zero  -> high for 300 +- 80 ns; then low for 790 +- 210 ns
+
+
+			if(bit) {
+				for(z = 0; z < 625; z++) asm volatile ("nop");
+			} else {
+				for(z = 0; z < 230; z++) asm volatile ("nop");
+			}
+
+			*addr = cond_low;
+
+			if(bit) {
+				for(z = 0; z < 625; z++) asm volatile ("nop");
+			} else {
+				for(z = 0; z < 625; z++) asm volatile ("nop");
+			}
+#endif
+#if 0
+			// total bit length = 1.25us +- 600ns
+			// send one  -> high for 800 +- 150 ns; then low for 450 +- 150ns
+			// send zero -> high for 400 +- 150 ns; then low for 850 +- 150ns
+
+
+			if(bit) {
+				for(z = 0; z < 625; z++) asm volatile ("nop");
+			} else {
+				for(z = 0; z < 310; z++) asm volatile ("nop");
+			}
+
+			*addr = cond_low;
+
+			if(bit) {
+				for(z = 0; z < 360; z++) asm volatile ("nop");
+			} else {
+				for(z = 0; z < 675; z++) asm volatile ("nop");
+			}
+#endif
+#if 1
+			// datasheet is all lies...
+
+			// reset time -> 280us+
+			// send one  -> high for 620 ns; then low for 930 ns
+			// send zero -> high for 300 ns; then low for 930 ns
+
+
+			if(bit) {
+				for(z = 0; z < 495; z++) asm volatile ("nop");
+			} else {
+				for(z = 0; z < 235; z++) asm volatile ("nop");
+			}
+
+			*addr = cond_low;
+
+			if(bit) {
+				for(z = 0; z < 730; z++) asm volatile ("nop");
+			} else {
+				for(z = 0; z < 730; z++) asm volatile ("nop");
+			}
+#endif
+		}
+	}
+
+	*addr = cond_low;
+}
+
+EXPORT_SYMBOL(rfnm_wsled_send_chain);
+
+struct gpio_desc *rfnm_wsled1_gpio;
+struct gpio_desc *rfnm_wsled2_gpio;
+
+static int rfnm_wsled_probe(struct platform_device *pdev)
+{
+	int error, z;
+
+	rfnm_wsled1_gpio = devm_gpiod_get(&pdev->dev, "wsled1", GPIOD_OUT_LOW);
+	if (IS_ERR(rfnm_wsled1_gpio)) {
+		error = PTR_ERR(rfnm_wsled1_gpio);
+		printk("Failed to get enable gpio: %d\n", error);
+		return error;
+	}
+
+	rfnm_wsled2_gpio = devm_gpiod_get(&pdev->dev, "wsled2", GPIOD_OUT_LOW);
+	if (IS_ERR(rfnm_wsled2_gpio)) {
+		error = PTR_ERR(rfnm_wsled2_gpio);
+		printk("Failed to get enable gpio: %d\n", error);
+		return error;
+	}
+
+	rfnm_wsled_io = ioremap(0x30220000, SZ_4K);
+
+	for(z = 0; z < 450000; z++) asm volatile ("nop");
+
+	rfnm_wsled_send_chain(0);
+	rfnm_wsled_send_chain(1);
+
+	printk("RFNM: WSLED driver");
+
+	return 0;
+}
+
+void rfnm_wsled_set(uint8_t chain_id, uint8_t led_id, uint8_t r, uint8_t g, uint8_t b) {
+	if(led_id > 3) {
+		printk("wrong led_id");
+		return;
+	}
+	if(chain_id > 1) {
+		printk("wrong chain_id");
+		return;
+	}
+	rfnm_wsled_chain[chain_id][1 + led_id] = b | (r << 8) | (g << 16);
+}
+
+EXPORT_SYMBOL(rfnm_wsled_set);
+
+static const struct of_device_id rfnm_wsled_match_table[] = {
+	{ .compatible = "rfnm,wsled", },
+	{}
+};
+
+MODULE_DEVICE_TABLE(of, rfnm_wsled_match_table);
+
+static struct platform_driver rfnm_wsled_driver = {
+	.probe		= rfnm_wsled_probe,
+	.driver		= {
+		.name		= "rfnm-wsled-led",
+		.of_match_table = rfnm_wsled_match_table,
+	},
+};
+
+module_platform_driver(rfnm_wsled_driver);
-- 
2.25.1

