From ff20c24dc333f8114d897453a057ddc0187d9fd9 Mon Sep 17 00:00:00 2001
From: Davide Cavion <davide@rfnm.io>
Date: Wed, 3 Jan 2024 20:53:56 +0100
Subject: [PATCH 7/7] Hack the TCPM driver to support USB-PD without requesting
 a hard link reset during init (which is required for some USB-PD adapters,
 but works in most cases)

Signed-off-by: Davide Cavion <davide@rfnm.io>
---
 drivers/usb/typec/tcpm/tcpm.c | 51 ++++++++++++++++++++++++++++-------
 1 file changed, 41 insertions(+), 10 deletions(-)

diff --git a/drivers/usb/typec/tcpm/tcpm.c b/drivers/usb/typec/tcpm/tcpm.c
index 468b60f0cd72..8686b729f26a 100644
--- a/drivers/usb/typec/tcpm/tcpm.c
+++ b/drivers/usb/typec/tcpm/tcpm.c
@@ -31,6 +31,8 @@
 #include <linux/usb/tcpm.h>
 #include <linux/usb/typec_altmode.h>
 
+#include <linux/rfnm-shared.h>
+
 #include <uapi/linux/sched/types.h>
 
 #define FOREACH_STATE(S)			\
@@ -849,6 +851,18 @@ static void tcpm_ams_finish(struct tcpm_port *port)
 {
 	tcpm_log(port, "AMS %s finished", tcpm_ams_str[port->ams]);
 
+	if(port->ams == POWER_NEGOTIATION) {
+		struct rfnm_bootconfig *cfg;
+		struct rfnm_eeprom_data *eeprom_data;
+		cfg = memremap(RFNM_BOOTCONFIG_PHYADDR, SZ_4M, MEMREMAP_WB);
+
+		cfg->usb_pd_negotiation_in_progress = 0xff;
+
+		printk("RFNM: USB PD negotiation finished\n");
+
+		memunmap(cfg);
+	}	
+
 	if (port->pd_capable && port->pwr_role == TYPEC_SOURCE) {
 		if (port->negotiated_rev >= PD_REV30)
 			tcpm_set_cc(port, SINK_TX_OK);
@@ -2898,16 +2912,19 @@ static void tcpm_pd_rx_handler(struct kthread_work *work)
 		if (!!(le16_to_cpu(msg->header) & PD_HEADER_DATA_ROLE) ==
 		    (port->data_role == TYPEC_HOST)) {
 			tcpm_log(port,
-				 "Data role mismatch, initiating error recovery");
-			tcpm_set_state(port, ERROR_RECOVERY, 0);
-		} else {
+				 "Data role mismatch, initiating error recovery (note: no, forcing it not to)");
+				port->data_role = (port->data_role == TYPEC_DEVICE) ? TYPEC_HOST : TYPEC_DEVICE;
+				tcpm_set_attached_state(port, true);
+		}
+//			tcpm_set_state(port, ERROR_RECOVERY, 0);
+//		} else {
 			if (le16_to_cpu(msg->header) & PD_HEADER_EXT_HDR)
 				tcpm_pd_ext_msg_request(port, msg);
 			else if (cnt)
 				tcpm_pd_data_request(port, msg);
 			else
 				tcpm_pd_ctrl_request(port, msg);
-		}
+//		}
 	}
 
 done:
@@ -4090,9 +4107,20 @@ static void run_state_machine(struct tcpm_port *port)
 		if ((port->cc1 == TYPEC_CC_OPEN &&
 		     port->cc2 != TYPEC_CC_OPEN) ||
 		    (port->cc1 != TYPEC_CC_OPEN &&
-		     port->cc2 == TYPEC_CC_OPEN))
-			tcpm_set_state(port, SNK_DEBOUNCED,
-				       PD_T_CC_DEBOUNCE);
+		     port->cc2 == TYPEC_CC_OPEN)) {
+				tcpm_set_state(port, SNK_DEBOUNCED,
+						PD_T_CC_DEBOUNCE);
+
+				struct rfnm_bootconfig *cfg;
+				struct rfnm_eeprom_data *eeprom_data;
+				cfg = memremap(RFNM_BOOTCONFIG_PHYADDR, SZ_4M, MEMREMAP_WB);
+
+				cfg->usb_pd_negotiation_in_progress = 1;
+
+				printk("RFNM: USB PD negotiation in progress\n");
+
+				memunmap(cfg);
+			}
 		else if (tcpm_port_is_disconnected(port))
 			tcpm_set_state(port, SNK_UNATTACHED,
 				       PD_T_PD_DEBOUNCE);
@@ -4231,9 +4259,11 @@ static void run_state_machine(struct tcpm_port *port)
 			port->vbus_never_low = false;
 			tcpm_set_state(port, SNK_SOFT_RESET,
 				       PD_T_SINK_WAIT_CAP);
+			tcpm_log(port, "RFNM first reset...");
 		} else {
 			tcpm_set_state(port, hard_reset_state(port),
 				       PD_T_SINK_WAIT_CAP);
+			tcpm_log(port, "RFNM hard reset :(");
 		}
 		break;
 	case SNK_NEGOTIATE_CAPABILITIES:
@@ -4339,7 +4369,7 @@ static void run_state_machine(struct tcpm_port *port)
 		 * For now, this driver only supports SOP for DISCOVER_IDENTITY, thus using
 		 * port->explicit_contract.
 		 */
-		if (port->explicit_contract)
+		if (port->explicit_contract && port->data_role == TYPEC_HOST)
 			mod_send_discover_delayed_work(port, 0);
 		else
 			port->send_discover = false;
@@ -5845,7 +5875,8 @@ static void tcpm_init(struct tcpm_port *port)
 	 * Should possibly wait for VBUS to settle if it was enabled locally
 	 * since tcpm_reset_port() will disable VBUS.
 	 */
-	port->vbus_present = port->tcpc->get_vbus(port->tcpc);
+	//port->vbus_present = port->tcpc->get_vbus(port->tcpc);
+	port->vbus_present = true;
 	if (port->vbus_present)
 		port->vbus_never_low = true;
 
@@ -5876,7 +5907,7 @@ static void tcpm_init(struct tcpm_port *port)
 	 * Some adapters need a clean slate at startup, and won't recover
 	 * otherwise. So do not try to be fancy and force a clean disconnect.
 	 */
-	tcpm_set_state(port, PORT_RESET, 0);
+	//tcpm_set_state(port, PORT_RESET, 0);
 }
 
 static int tcpm_port_type_set(struct typec_port *p, enum typec_port_type type)
-- 
2.25.1

